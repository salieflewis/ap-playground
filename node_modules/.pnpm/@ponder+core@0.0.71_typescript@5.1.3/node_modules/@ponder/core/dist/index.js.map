{"version":3,"sources":["../src/index.ts","../src/build/handlers.ts","../src/Ponder.ts","../src/build/service.ts","../src/errors/user.ts","../src/schema/schema.ts","../src/server/graphql/schema.ts","../src/server/graphql/entity.ts","../src/server/graphql/plural.ts","../src/server/graphql/singular.ts","../src/build/schema.ts","../src/codegen/service.ts","../src/utils/exists.ts","../src/codegen/contract.ts","../src/codegen/entity.ts","../src/codegen/event.ts","../src/codegen/prettier.ts","../src/config/abi.ts","../src/config/networks.ts","../src/config/contracts.ts","../src/config/database.ts","../src/utils/print.ts","../src/errors/base.ts","../src/errors/postgres.ts","../src/errors/sqlite.ts","../src/config/logFilters.ts","../src/config/logFilterKey.ts","../src/errors/service.ts","../src/event-aggregator/service.ts","../src/event-store/postgres/store.ts","../src/utils/decode.ts","../src/utils/encode.ts","../src/utils/intervals.ts","../src/event-store/postgres/format.ts","../src/event-store/postgres/migrations.ts","../src/event-store/sqlite/store.ts","../src/event-store/sqlite/format.ts","../src/event-store/sqlite/migrations.ts","../src/historical-sync/service.ts","../src/errors/queue.ts","../src/utils/format.ts","../src/utils/queue.ts","../src/utils/timer.ts","../src/historical-sync/intervals.ts","../src/logs/service.ts","../src/metrics/service.ts","../src/realtime-sync/service.ts","../src/utils/wait.ts","../src/utils/poll.ts","../src/utils/range.ts","../src/realtime-sync/bloom.ts","../src/realtime-sync/filter.ts","../src/realtime-sync/format.ts","../src/server/service.ts","../src/ui/app.tsx","../src/ui/HandlersBar.tsx","../src/ui/ProgressBar.tsx","../src/ui/HistoricalBar.tsx","../src/ui/service.ts","../src/user-handlers/service.ts","../src/user-handlers/contract.ts","../src/user-handlers/model.ts","../src/user-handlers/trace.ts","../src/user-store/postgres/store.ts","../src/user-store/utils.ts","../src/user-store/sqlite/store.ts"],"sourcesContent":["export { PonderApp } from \"@/build/handlers\";\nexport type { Config, ResolvedConfig } from \"@/config/config\";\nexport type { Options } from \"@/config/options\";\nexport { Ponder } from \"@/Ponder\";\nexport type { Block } from \"@/types/block\";\nexport type { ReadOnlyContract } from \"@/types/contract\";\nexport type { Log } from \"@/types/log\";\nexport type { Model } from \"@/types/model\";\nexport type { Transaction } from \"@/types/transaction\";\n","import { build, formatMessagesSync, Message } from \"esbuild\";\nimport glob from \"glob\";\nimport { existsSync, rmSync } from \"node:fs\";\nimport path from \"node:path\";\nimport { replaceTscAliasPaths } from \"tsc-alias\";\n\nimport { Options } from \"@/config/options\";\nimport { Block } from \"@/types/block\";\nimport { Log } from \"@/types/log\";\nimport { Transaction } from \"@/types/transaction\";\n\nexport interface LogEvent {\n  name: string;\n  params: Record<string, any>;\n  log: Log;\n  block: Block;\n  transaction: Transaction;\n}\n\ntype SetupEventHandler = ({\n  context,\n}: {\n  context: unknown;\n}) => Promise<void> | void;\n\ntype LogEventHandler = ({\n  event,\n  context,\n}: {\n  event: LogEvent;\n  context: unknown;\n}) => Promise<void> | void;\n\ntype LogEventHandlers = Record<string, LogEventHandler | undefined>;\n\nexport type Handlers = Record<string, LogEventHandlers | undefined> & {\n  setup?: SetupEventHandler;\n};\n\n// @ponder/core creates an instance of this class called `ponder`\nexport class PonderApp<EventHandlers = Record<string, LogEventHandler>> {\n  private handlers: Handlers = {};\n  private errors: Error[] = [];\n\n  on<EventName extends Extract<keyof EventHandlers, string>>(\n    name: EventName,\n    handler: EventHandlers[EventName]\n  ) {\n    if (name === \"setup\") {\n      this.handlers.setup = handler as SetupEventHandler;\n      return;\n    }\n\n    const [contractName, eventName] = name.split(\":\");\n    if (!contractName || !eventName) {\n      this.errors.push(new Error(`Invalid event name: ${name}`));\n      return;\n    }\n\n    this.handlers[contractName] ||= {};\n    if (this.handlers[contractName]![eventName]) {\n      this.errors.push(\n        new Error(`Cannot add multiple handlers for event: ${name}`)\n      );\n      return;\n    }\n    this.handlers[contractName]![eventName] = handler as LogEventHandler;\n  }\n}\n\nexport const readHandlers = async ({ options }: { options: Options }) => {\n  const entryAppFilename = path.join(options.generatedDir, \"index.ts\");\n  if (!existsSync(entryAppFilename)) {\n    throw new Error(\n      `generated/index.ts file not found, expected: ${entryAppFilename}`\n    );\n  }\n\n  const entryGlob = options.srcDir + \"/**/*.ts\";\n  const entryFilenames = [...glob.sync(entryGlob), entryAppFilename];\n\n  const buildDir = path.join(options.ponderDir, \"out\");\n  rmSync(buildDir, { recursive: true, force: true });\n\n  try {\n    await build({\n      entryPoints: entryFilenames,\n      outdir: buildDir,\n      platform: \"node\",\n      bundle: false,\n      format: \"cjs\",\n      logLevel: \"silent\",\n      sourcemap: \"inline\",\n    });\n  } catch (err) {\n    const error = err as Error & { errors: Message[]; warnings: Message[] };\n    // Hack to use esbuilds very pretty stack traces when rendering errors to the user.\n    const stackTraces = formatMessagesSync(error.errors, {\n      kind: \"error\",\n      color: true,\n    });\n    error.stack = stackTraces.join(\"\\n\");\n\n    throw error;\n  }\n\n  const tsconfigPath = path.join(options.rootDir, \"tsconfig.json\");\n  if (existsSync(tsconfigPath)) {\n    await replaceTscAliasPaths({\n      configFile: tsconfigPath,\n      outDir: buildDir,\n    });\n  } else {\n    throw new Error(\n      `tsconfig.json not found, unable to resolve \"@/*\" path aliases. Expected at: ${tsconfigPath}`\n    );\n  }\n\n  const outGlob = buildDir + \"/**/*.js\";\n  const outFilenames = glob.sync(outGlob);\n\n  // Remove all out modules from the require cache, because we are loading\n  // them several times in the same process and need the latest version each time.\n  // https://ar.al/2021/02/22/cache-busting-in-node.js-dynamic-esm-imports/\n  outFilenames.forEach((file) => delete require.cache[require.resolve(file)]);\n\n  const outAppFilename = path.join(buildDir, \"generated/index.js\");\n\n  // Require all the user-defined files first.\n  const outUserFilenames = outFilenames.filter(\n    (name) => name !== outAppFilename\n  );\n\n  const requireErrors = outUserFilenames\n    .map((file) => {\n      try {\n        require(file);\n      } catch (err) {\n        return err as Error;\n      }\n    })\n    .filter((err): err is Error => err !== undefined);\n\n  if (requireErrors.length > 0) {\n    throw requireErrors[0];\n  }\n\n  // Then require the `_app.ts` file to grab the `app` instance.\n  const result = require(outAppFilename);\n\n  const app = result.ponder;\n\n  if (!app) {\n    throw new Error(`ponder not exported from generated/index.ts`);\n  }\n  if (!(app.constructor.name === \"PonderApp\")) {\n    throw new Error(`exported ponder not instanceof PonderApp`);\n  }\n  if (app[\"errors\"].length > 0) {\n    const error = app[\"errors\"][0];\n    throw error;\n  }\n\n  const handlers = app[\"handlers\"] as Handlers;\n\n  return handlers;\n};\n","import path from \"node:path\";\n\nimport { BuildService } from \"@/build/service\";\nimport { CodegenService } from \"@/codegen/service\";\nimport { type ResolvedConfig } from \"@/config/config\";\nimport { buildContracts } from \"@/config/contracts\";\nimport { buildDatabase } from \"@/config/database\";\nimport { type LogFilter, buildLogFilters } from \"@/config/logFilters\";\nimport { type Network, buildNetwork } from \"@/config/networks\";\nimport { type Options } from \"@/config/options\";\nimport { UserErrorService } from \"@/errors/service\";\nimport { EventAggregatorService } from \"@/event-aggregator/service\";\nimport { PostgresEventStore } from \"@/event-store/postgres/store\";\nimport { SqliteEventStore } from \"@/event-store/sqlite/store\";\nimport { type EventStore } from \"@/event-store/store\";\nimport { HistoricalSyncService } from \"@/historical-sync/service\";\nimport { LoggerService } from \"@/logs/service\";\nimport { MetricsService } from \"@/metrics/service\";\nimport { RealtimeSyncService } from \"@/realtime-sync/service\";\nimport { ServerService } from \"@/server/service\";\nimport { UiService } from \"@/ui/service\";\nimport { EventHandlerService } from \"@/user-handlers/service\";\nimport { PostgresUserStore } from \"@/user-store/postgres/store\";\nimport { SqliteUserStore } from \"@/user-store/sqlite/store\";\nimport { type UserStore } from \"@/user-store/store\";\n\nexport type Resources = {\n  options: Options;\n  logger: LoggerService;\n  errors: UserErrorService;\n  metrics: MetricsService;\n};\n\nexport class Ponder {\n  resources: Resources;\n  logFilters: LogFilter[];\n\n  eventStore: EventStore;\n  userStore: UserStore;\n\n  // List of indexing-related services. One per configured network.\n  networkSyncServices: {\n    network: Network;\n    logFilters: LogFilter[];\n    historicalSyncService: HistoricalSyncService;\n    realtimeSyncService: RealtimeSyncService;\n  }[] = [];\n\n  eventAggregatorService: EventAggregatorService;\n  eventHandlerService: EventHandlerService;\n\n  serverService: ServerService;\n  buildService: BuildService;\n  codegenService: CodegenService;\n  uiService: UiService;\n\n  constructor({\n    options,\n    config,\n    eventStore,\n    userStore,\n  }: {\n    options: Options;\n    config: ResolvedConfig;\n    // These options are only used for testing.\n    eventStore?: EventStore;\n    userStore?: UserStore;\n  }) {\n    const logger = new LoggerService({\n      level: options.logLevel,\n      dir: options.logDir,\n    });\n    const errors = new UserErrorService();\n    const metrics = new MetricsService();\n\n    const resources = { options, logger, errors, metrics };\n    this.resources = resources;\n\n    const logFilters = buildLogFilters({ options, config });\n    this.logFilters = logFilters;\n    const contracts = buildContracts({ options, config });\n    const networks = config.networks.map((network) =>\n      buildNetwork({ network })\n    );\n\n    const database = buildDatabase({ options, config });\n    this.eventStore =\n      eventStore ??\n      (database.kind === \"sqlite\"\n        ? new SqliteEventStore({ db: database.db })\n        : new PostgresEventStore({ pool: database.pool }));\n\n    this.userStore =\n      userStore ??\n      (database.kind === \"sqlite\"\n        ? new SqliteUserStore({ db: database.db })\n        : new PostgresUserStore({ pool: database.pool }));\n\n    networks.forEach((network) => {\n      const logFiltersForNetwork = logFilters.filter(\n        (logFilter) => logFilter.network === network.name\n      );\n      this.networkSyncServices.push({\n        network,\n        logFilters: logFiltersForNetwork,\n        historicalSyncService: new HistoricalSyncService({\n          resources,\n          eventStore: this.eventStore,\n          network,\n          logFilters: logFiltersForNetwork,\n        }),\n        realtimeSyncService: new RealtimeSyncService({\n          resources,\n          eventStore: this.eventStore,\n          network,\n          logFilters: logFiltersForNetwork,\n        }),\n      });\n    });\n\n    this.eventAggregatorService = new EventAggregatorService({\n      eventStore: this.eventStore,\n      networks,\n      logFilters,\n    });\n\n    this.eventHandlerService = new EventHandlerService({\n      resources,\n      eventStore: this.eventStore,\n      userStore: this.userStore,\n      eventAggregatorService: this.eventAggregatorService,\n      contracts,\n      logFilters: this.logFilters,\n    });\n\n    this.serverService = new ServerService({\n      resources,\n      userStore: this.userStore,\n    });\n    this.buildService = new BuildService({ resources });\n    this.codegenService = new CodegenService({\n      resources,\n      contracts,\n      logFilters,\n    });\n    this.uiService = new UiService({ resources, logFilters });\n  }\n\n  async setup() {\n    this.resources.logger.debug({\n      service: \"app\",\n      msg: `Started using config file: ${path.relative(\n        this.resources.options.rootDir,\n        this.resources.options.configFile\n      )}`,\n    });\n\n    this.registerServiceDependencies();\n\n    // If any of the provided networks do not have a valid RPC url,\n    // kill the app here. This happens here rather than in the constructor because\n    // `ponder codegen` should still be able to if an RPC url is missing. In fact,\n    // that is part of the happy path for `create-ponder`.\n    const networksMissingRpcUrl: Network[] = [];\n    this.networkSyncServices.forEach(({ network }) => {\n      if (!network.rpcUrl) {\n        networksMissingRpcUrl.push(network);\n      }\n    });\n    if (networksMissingRpcUrl.length > 0) {\n      return new Error(\n        `missing RPC URL for networks (${networksMissingRpcUrl.map(\n          (n) => `\"${n.name}\"`\n        )}). Did you forget to add an RPC URL in .env.local?`\n      );\n    }\n\n    // Start the HTTP server.\n    await this.serverService.start();\n\n    // These files depend only on ponder.config.ts, so can generate once on setup.\n    // Note that loadHandlers depends on the index.ts file being present.\n    this.codegenService.generateAppFile();\n\n    // Note that this must occur before loadSchema and loadHandlers.\n    await this.eventStore.migrateUp();\n\n    // Manually trigger loading schema and handlers. Subsequent loads\n    // are triggered by changes to project files (handled in BuildService).\n    this.buildService.buildSchema();\n    await this.buildService.buildHandlers();\n  }\n\n  async dev() {\n    const setupError = await this.setup();\n    if (setupError) {\n      this.resources.logger.error({\n        service: \"app\",\n        msg: setupError.message,\n        error: setupError,\n      });\n      return await this.kill();\n    }\n\n    await Promise.all(\n      this.networkSyncServices.map(\n        async ({ historicalSyncService, realtimeSyncService }) => {\n          const { finalizedBlockNumber } = await realtimeSyncService.setup();\n          await historicalSyncService.setup({ finalizedBlockNumber });\n\n          historicalSyncService.start();\n          realtimeSyncService.start();\n        }\n      )\n    );\n\n    this.buildService.watch();\n  }\n\n  async start() {\n    const setupError = await this.setup();\n    if (setupError) {\n      // this.resources.logger.error(\"error\", setupError.message);\n      return await this.kill();\n    }\n\n    await Promise.all(\n      this.networkSyncServices.map(\n        async ({ historicalSyncService, realtimeSyncService }) => {\n          const { finalizedBlockNumber } = await realtimeSyncService.setup();\n          await historicalSyncService.setup({ finalizedBlockNumber });\n\n          historicalSyncService.start();\n          realtimeSyncService.start();\n        }\n      )\n    );\n  }\n\n  async codegen() {\n    this.codegenService.generateAppFile();\n\n    const result = this.buildService.buildSchema();\n    if (result) {\n      const { schema, graphqlSchema } = result;\n      this.codegenService.generateAppFile({ schema });\n      this.codegenService.generateSchemaFile({ graphqlSchema });\n    }\n\n    await this.kill();\n  }\n\n  async kill() {\n    this.eventAggregatorService.clearListeners();\n\n    await Promise.all(\n      this.networkSyncServices.map(\n        async ({ realtimeSyncService, historicalSyncService }) => {\n          await realtimeSyncService.kill();\n          await historicalSyncService.kill();\n        }\n      )\n    );\n\n    await this.buildService.kill?.();\n    this.uiService.kill();\n    this.eventHandlerService.kill();\n    await this.serverService.kill();\n    await this.userStore.teardown();\n\n    this.resources.logger.debug({\n      service: \"app\",\n      msg: `Finished shutdown sequence`,\n    });\n  }\n\n  private registerServiceDependencies() {\n    this.buildService.on(\"newConfig\", async () => {\n      this.resources.logger.fatal({\n        service: \"build\",\n        msg: \"Detected change in ponder.config.ts\",\n      });\n      await this.kill();\n    });\n\n    this.buildService.on(\"newSchema\", async ({ schema, graphqlSchema }) => {\n      this.codegenService.generateAppFile({ schema });\n      this.codegenService.generateSchemaFile({ graphqlSchema });\n\n      this.serverService.reload({ graphqlSchema });\n\n      await this.eventHandlerService.reset({ schema });\n      await this.eventHandlerService.processEvents();\n    });\n\n    this.buildService.on(\"newHandlers\", async ({ handlers }) => {\n      await this.eventHandlerService.reset({ handlers });\n      await this.eventHandlerService.processEvents();\n    });\n\n    this.networkSyncServices.forEach((networkSyncService) => {\n      const { chainId } = networkSyncService.network;\n      const { historicalSyncService, realtimeSyncService } = networkSyncService;\n\n      historicalSyncService.on(\"historicalCheckpoint\", ({ timestamp }) => {\n        this.eventAggregatorService.handleNewHistoricalCheckpoint({\n          chainId,\n          timestamp,\n        });\n      });\n\n      historicalSyncService.on(\"syncComplete\", () => {\n        this.eventAggregatorService.handleHistoricalSyncComplete({\n          chainId,\n        });\n      });\n\n      realtimeSyncService.on(\"realtimeCheckpoint\", ({ timestamp }) => {\n        this.eventAggregatorService.handleNewRealtimeCheckpoint({\n          chainId,\n          timestamp,\n        });\n      });\n\n      realtimeSyncService.on(\"finalityCheckpoint\", ({ timestamp }) => {\n        this.eventAggregatorService.handleNewFinalityCheckpoint({\n          chainId,\n          timestamp,\n        });\n      });\n\n      realtimeSyncService.on(\"shallowReorg\", ({ commonAncestorTimestamp }) => {\n        this.eventAggregatorService.handleReorg({ commonAncestorTimestamp });\n      });\n    });\n\n    this.eventAggregatorService.on(\"newCheckpoint\", async () => {\n      await this.eventHandlerService.processEvents();\n    });\n\n    this.eventAggregatorService.on(\n      \"reorg\",\n      async ({ commonAncestorTimestamp }) => {\n        await this.eventHandlerService.handleReorg({ commonAncestorTimestamp });\n        await this.eventHandlerService.processEvents();\n      }\n    );\n\n    this.eventHandlerService.on(\"eventsProcessed\", ({ toTimestamp }) => {\n      if (this.serverService.isHistoricalEventProcessingComplete) return;\n\n      // If a batch of events are processed AND the historical sync is complete AND\n      // the new toTimestamp is greater than the historical sync completion timestamp,\n      // historical event processing is complete, and the server should begin responding as healthy.\n      if (\n        this.eventAggregatorService.historicalSyncCompletedAt &&\n        toTimestamp >= this.eventAggregatorService.historicalSyncCompletedAt\n      ) {\n        this.serverService.setIsHistoricalEventProcessingComplete();\n      }\n    });\n  }\n}\n","import chokidar from \"chokidar\";\nimport Emittery from \"emittery\";\nimport { GraphQLSchema } from \"graphql\";\nimport { createHash } from \"node:crypto\";\nimport { readFileSync } from \"node:fs\";\nimport path from \"node:path\";\n\nimport { UserError } from \"@/errors/user\";\nimport { Resources } from \"@/Ponder\";\nimport { buildSchema } from \"@/schema/schema\";\nimport { Schema } from \"@/schema/types\";\nimport { buildGqlSchema } from \"@/server/graphql/schema\";\n\nimport { Handlers, readHandlers } from \"./handlers\";\nimport { readGraphqlSchema } from \"./schema\";\n\ntype BuildServiceEvents = {\n  newConfig: undefined;\n  newHandlers: { handlers: Handlers };\n  newSchema: { schema: Schema; graphqlSchema: GraphQLSchema };\n};\n\nexport class BuildService extends Emittery<BuildServiceEvents> {\n  private resources: Resources;\n\n  private closeWatcher?: () => Promise<void>;\n  private latestFileHashes: Record<string, string | undefined> = {};\n\n  constructor({ resources }: { resources: Resources }) {\n    super();\n    this.resources = resources;\n  }\n\n  async kill() {\n    this.closeWatcher?.();\n    this.resources.logger.debug({\n      service: \"build\",\n      msg: `Killed build service`,\n    });\n  }\n\n  watch() {\n    const watchFiles = [\n      this.resources.options.configFile,\n      this.resources.options.schemaFile,\n      this.resources.options.srcDir,\n    ];\n\n    const watcher = chokidar.watch(watchFiles);\n    this.closeWatcher = async () => {\n      await watcher.close();\n    };\n\n    watcher.on(\"change\", async (filePath) => {\n      if (filePath === this.resources.options.configFile) {\n        this.emit(\"newConfig\");\n        return;\n      }\n\n      if (this.isFileChanged(filePath)) {\n        const fileName = path.basename(filePath);\n\n        this.resources.logger.info({\n          service: \"build\",\n          msg: `Detected change in ${fileName}`,\n        });\n\n        this.resources.errors.hasUserError = false;\n\n        if (filePath === this.resources.options.schemaFile) {\n          this.buildSchema();\n        } else {\n          await this.buildHandlers();\n        }\n      }\n    });\n  }\n\n  async buildHandlers() {\n    try {\n      const handlers = await readHandlers({ options: this.resources.options });\n      this.emit(\"newHandlers\", { handlers });\n    } catch (error_) {\n      const error = error_ as Error;\n\n      // TODO: Build the UserError object within readHandlers, check instanceof,\n      // then log/submit as-is if it's already a UserError.\n      const message = `Error while building handlers: ${error.message}`;\n      const userError = new UserError(message, {\n        stack: error.stack,\n      });\n\n      this.resources.logger.error({\n        service: \"build\",\n        error: userError,\n      });\n      this.resources.errors.submitUserError({ error: userError });\n    }\n  }\n\n  buildSchema() {\n    try {\n      const userGraphqlSchema = readGraphqlSchema({\n        options: this.resources.options,\n      });\n      const schema = buildSchema(userGraphqlSchema);\n      const graphqlSchema = buildGqlSchema(schema);\n      this.emit(\"newSchema\", { schema, graphqlSchema });\n      return { schema, graphqlSchema };\n    } catch (error_) {\n      const error = error_ as Error;\n\n      // TODO: Parse GraphQLError instances better here.\n      // We can use the `.locations` property to build a pretty codeframe.\n\n      // TODO: Build the UserError object within readHandlers, check instanceof,\n      // then log/submit as-is if it's already a UserError.\n      const message = `Error while building schema.graphql: ${error.message}`;\n      const userError = new UserError(message, {\n        stack: error.stack,\n      });\n\n      this.resources.logger.error({\n        service: \"build\",\n        error: userError,\n      });\n      this.resources.errors.submitUserError({ error: userError });\n    }\n  }\n\n  private isFileChanged(filePath: string) {\n    // TODO: I think this throws if the file being watched gets deleted while\n    // the development server is running. Should handle this case gracefully.\n    try {\n      const content = readFileSync(filePath, \"utf-8\");\n      const hash = createHash(\"md5\").update(content).digest(\"hex\");\n\n      const prevHash = this.latestFileHashes[filePath];\n      this.latestFileHashes[filePath] = hash;\n      if (!prevHash) {\n        // If there is no previous hash, this file is being changed for the first time.\n        return true;\n      } else {\n        // If there is a previous hash, check if the content hash has changed.\n        return prevHash !== hash;\n      }\n    } catch (e) {\n      return true;\n    }\n  }\n}\n","export class UserError extends Error {\n  name = \"UserError\";\n\n  meta?: string;\n\n  constructor(\n    message: string,\n    options: { stack?: string; meta?: string; cause?: unknown } = {}\n  ) {\n    super(message, options.cause ? { cause: options.cause } : undefined);\n\n    this.stack = options.stack;\n    this.meta = options.meta;\n  }\n}\n","import {\n  FieldDefinitionNode,\n  GraphQLBoolean,\n  GraphQLEnumType,\n  GraphQLFloat,\n  GraphQLID,\n  GraphQLInputObjectType,\n  GraphQLInt,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLString,\n  Kind,\n  StringValueNode,\n} from \"graphql\";\n\nimport {\n  DerivedField,\n  Entity,\n  EnumField,\n  Field,\n  ListField,\n  RelationshipField,\n  ScalarField,\n  Schema,\n} from \"./types\";\n\nconst GraphQLBigInt = new GraphQLScalarType({\n  name: \"BigInt\",\n  serialize: (value) => String(value),\n  parseValue: (value) => BigInt(value),\n  parseLiteral: (value) => {\n    if (value.kind === \"StringValue\") {\n      return BigInt(value.value);\n    } else {\n      throw new Error(\n        `Invalid value kind provided for field of type BigInt: ${value.kind}. Expected: StringValue`\n      );\n    }\n  },\n});\n\nconst gqlScalarTypeByName: Record<string, GraphQLScalarType | undefined> = {\n  ID: GraphQLID,\n  Int: GraphQLInt,\n  Float: GraphQLFloat,\n  String: GraphQLString,\n  Boolean: GraphQLBoolean,\n  BigInt: GraphQLBigInt,\n  Bytes: GraphQLString,\n};\n\nexport const buildSchema = (graphqlSchema: GraphQLSchema): Schema => {\n  const gqlEntityTypes = getEntityTypes(graphqlSchema);\n  const gqlEnumTypes = getEnumTypes(graphqlSchema);\n\n  const userDefinedScalars = getUserDefinedScalarTypes(graphqlSchema);\n  if (userDefinedScalars.length > 0) {\n    throw new Error(\n      `Custom scalars are not supported: ${userDefinedScalars[0]}`\n    );\n  }\n\n  const entities = gqlEntityTypes.map((entity) => {\n    const entityName = entity.name;\n    const entityIsImmutable = !!entity.astNode?.directives\n      ?.find((directive) => directive.name.value === \"entity\")\n      ?.arguments?.find(\n        (arg) =>\n          arg.name.value === \"immutable\" &&\n          arg.value.kind === \"BooleanValue\" &&\n          arg.value.value\n      );\n\n    const gqlFields = entity.astNode?.fields || [];\n\n    const fields = gqlFields.map((field) => {\n      const originalFieldType = field.type;\n\n      const {\n        fieldName,\n        fieldTypeName,\n        isNotNull,\n        isList,\n        isListElementNotNull,\n      } = unwrapFieldDefinition(field);\n\n      // Try to find a type that matches the base type of this field.\n      const scalarBaseType = gqlScalarTypeByName[fieldTypeName];\n      const enumBaseType = gqlEnumTypes.find((t) => t.name === fieldTypeName);\n      const entityBaseType = gqlEntityTypes.find(\n        (t) => t.name === fieldTypeName\n      );\n\n      const derivedFromDirective = field.directives?.find(\n        (directive) => directive.name.value === \"derivedFrom\"\n      );\n\n      // Handle derived fields.\n      if (derivedFromDirective) {\n        if (!entityBaseType || !isList) {\n          throw new Error(\n            `Resolved type of a @derivedFrom field must be a list of entities`\n          );\n        }\n\n        const derivedFromFieldArgument = derivedFromDirective.arguments?.find(\n          (arg) =>\n            arg.name.value === \"field\" && arg.value.kind === \"StringValue\"\n        );\n        if (!derivedFromFieldArgument) {\n          throw new Error(\n            `The @derivedFrom directive requires an argument: field`\n          );\n        }\n\n        const derivedFromFieldName = (\n          derivedFromFieldArgument.value as StringValueNode\n        ).value;\n\n        const baseTypeAsInputType =\n          entityBaseType as unknown as GraphQLInputObjectType;\n\n        return <DerivedField>{\n          name: fieldName,\n          kind: \"DERIVED\",\n          baseGqlType: baseTypeAsInputType,\n          originalFieldType,\n          notNull: isNotNull,\n          derivedFromEntityName: entityBaseType.name,\n          derivedFromFieldName: derivedFromFieldName,\n        };\n      }\n\n      // Handle relationship types.\n      if (entityBaseType) {\n        if (isList) {\n          throw new Error(\n            `Invalid field: ${entityName}.${fieldName}. Lists of entities must use the @derivedFrom directive.`\n          );\n        }\n\n        const relatedEntityIdField = entityBaseType.getFields()[\"id\"]?.astNode;\n        if (!relatedEntityIdField) {\n          throw new Error(\n            `Related entity is missing an id field: ${entityBaseType.name}`\n          );\n        }\n\n        const { fieldTypeName } = unwrapFieldDefinition(relatedEntityIdField);\n        const relatedEntityIdType = gqlScalarTypeByName[fieldTypeName];\n        if (!relatedEntityIdType) {\n          throw new Error(\n            `Related entity id field is not a scalar: ${entityBaseType.name}`\n          );\n        }\n\n        // Everything downstream requires the base type as a GraphQLInputObject type, but idk how to safely convert it.\n        // AFAICT, the GraphQLObjectType is a strict superset of GraphQLInputObject, so this should be fine.\n        const entityBaseTypeAsInputType =\n          entityBaseType as unknown as GraphQLInputObjectType;\n\n        return <RelationshipField>{\n          name: fieldName,\n          kind: \"RELATIONSHIP\",\n          baseGqlType: entityBaseTypeAsInputType,\n          originalFieldType,\n          notNull: isNotNull,\n          relatedEntityName: entityBaseType.name,\n          relatedEntityIdType: relatedEntityIdType,\n        };\n      }\n\n      // Handle list types.\n      if (isList) {\n        if (scalarBaseType) {\n          return <ListField>{\n            name: fieldName,\n            kind: \"LIST\",\n            baseGqlType: scalarBaseType,\n            originalFieldType,\n            notNull: isNotNull,\n            isListElementNotNull,\n          };\n        }\n\n        if (enumBaseType) {\n          return <ListField>{\n            name: fieldName,\n            kind: \"LIST\",\n            baseGqlType: enumBaseType,\n            originalFieldType,\n            notNull: isNotNull,\n            isListElementNotNull,\n          };\n        }\n      }\n\n      // Handle scalar types.\n      if (scalarBaseType) {\n        const baseType = scalarBaseType;\n\n        // Validate the id field.\n        if (fieldName === \"id\") {\n          if (!isNotNull) {\n            throw new Error(`${entityName}.id field must be non-null`);\n          }\n          if (isList) {\n            throw new Error(`${entityName}.id field must not be a list`);\n          }\n          if (![\"BigInt\", \"String\", \"Int\", \"Bytes\"].includes(baseType.name)) {\n            throw new Error(\n              `${entityName}.id field must be a String, BigInt, Int, or Bytes.`\n            );\n          }\n        }\n\n        return <ScalarField>{\n          name: fieldName,\n          kind: \"SCALAR\",\n          notNull: isNotNull,\n          originalFieldType,\n          scalarTypeName: fieldTypeName,\n          scalarGqlType: baseType,\n        };\n      }\n\n      // Handle enum types.\n      if (enumBaseType) {\n        const enumValues = (enumBaseType.astNode?.values || []).map(\n          (v) => v.name.value\n        );\n        return <EnumField>{\n          name: fieldName,\n          kind: \"ENUM\",\n          enumGqlType: enumBaseType,\n          originalFieldType,\n          notNull: isNotNull,\n          enumValues,\n        };\n      }\n\n      throw new Error(`Unhandled field type: ${fieldTypeName}`);\n    });\n\n    const fieldByName: Record<string, Field> = {};\n    fields.forEach((field) => {\n      fieldByName[field.name] = field;\n    });\n\n    return <Entity>{\n      name: entityName,\n      gqlType: entity,\n      isImmutable: entityIsImmutable,\n      fields,\n      fieldByName,\n    };\n  });\n\n  const schema: Schema = {\n    entities,\n  };\n\n  return schema;\n};\n\n// ------------------------------- UTILITIES -------------------------------- //\n\n// Find the name and base type of a field definition,\n// handling any wrapper types (NON_NULL_TYPE and LIST_TYPE).\nconst unwrapFieldDefinition = (field: FieldDefinitionNode) => {\n  const fieldName = field.name.value;\n  let fieldType = field.type;\n  let isNotNull = false;\n  let isList = false;\n  let isListElementNotNull = false;\n\n  // First check if the field is non-null and unwrap it.\n  if (fieldType.kind === Kind.NON_NULL_TYPE) {\n    isNotNull = true;\n    fieldType = fieldType.type;\n  }\n\n  // Then check if the field is a list and unwrap it.\n  if (fieldType.kind === Kind.LIST_TYPE) {\n    isList = true;\n    fieldType = fieldType.type;\n\n    // Now check if the list element type is non-null\n    if (fieldType.kind === Kind.NON_NULL_TYPE) {\n      isListElementNotNull = true;\n      fieldType = fieldType.type;\n    }\n  }\n\n  if (fieldType.kind === Kind.LIST_TYPE) {\n    throw new Error(\n      `Invalid field \"${fieldName}\": nested lists are not supported`\n    );\n  }\n\n  return {\n    fieldName,\n    fieldTypeName: fieldType.name.value,\n    isNotNull,\n    isList,\n    isListElementNotNull,\n  };\n};\n\n// Find all types in the schema that are marked with the @entity directive.\nconst getEntityTypes = (schema: GraphQLSchema) => {\n  const entities = Object.values(schema.getTypeMap())\n    .filter((type): type is GraphQLObjectType => {\n      return type.astNode?.kind === Kind.OBJECT_TYPE_DEFINITION;\n    })\n    .filter((type) => {\n      return !!type.astNode?.directives?.find(\n        (directive) => directive.name.value === \"entity\"\n      );\n    });\n\n  return entities;\n};\n\n// Find all scalar types in the schema that were created by the user.\nconst getUserDefinedScalarTypes = (schema: GraphQLSchema) => {\n  return Object.values(schema.getTypeMap()).filter(\n    (type) =>\n      !!type.astNode &&\n      type.astNode.kind === Kind.SCALAR_TYPE_DEFINITION &&\n      ![\"BigInt\", \"Bytes\"].includes(type.name)\n  ) as GraphQLScalarType[];\n};\n\n// Find all types in the schema that were created by the user.\nconst getEnumTypes = (schema: GraphQLSchema) => {\n  return Object.values(schema.getTypeMap()).filter(\n    (type) => !!type.astNode && type.astNode.kind === Kind.ENUM_TYPE_DEFINITION\n  ) as GraphQLEnumType[];\n};\n","import { GraphQLFieldConfig, GraphQLObjectType, GraphQLSchema } from \"graphql\";\n\nimport { Schema } from \"@/schema/types\";\nimport { UserStore } from \"@/user-store/store\";\n\nimport { buildEntityType } from \"./entity\";\nimport { buildPluralField } from \"./plural\";\nimport { buildSingularField } from \"./singular\";\n\nexport type Source = { request: unknown };\nexport type Context = { store: UserStore };\n\nconst buildGqlSchema = (schema: Schema): GraphQLSchema => {\n  const queryFields: Record<string, GraphQLFieldConfig<Source, Context>> = {};\n\n  const entityGqlTypes: Record<string, GraphQLObjectType<Source, Context>> = {};\n\n  // First build the entity types. These have resolvers defined for any\n  // relationship or derived fields. This is also important for the thunk nonsense.\n  for (const entity of schema.entities) {\n    entityGqlTypes[entity.name] = buildEntityType({ entity, entityGqlTypes });\n  }\n\n  for (const entity of schema.entities) {\n    const entityGqlType = entityGqlTypes[entity.name];\n\n    const singularFieldName =\n      entity.name.charAt(0).toLowerCase() + entity.name.slice(1);\n    queryFields[singularFieldName] = buildSingularField({\n      entity,\n      entityGqlType,\n    });\n\n    const pluralFieldName = singularFieldName + \"s\";\n    queryFields[pluralFieldName] = buildPluralField({ entity, entityGqlType });\n  }\n\n  const queryType = new GraphQLObjectType({\n    name: \"Query\",\n    fields: queryFields,\n  });\n\n  const gqlSchema = new GraphQLSchema({\n    query: queryType,\n  });\n\n  return gqlSchema;\n};\n\nexport { buildGqlSchema };\n","import {\n  GraphQLFieldConfigMap,\n  GraphQLFieldResolver,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLOutputType,\n} from \"graphql\";\n\nimport type { Entity } from \"@/schema/types\";\n\nimport type { Context, Source } from \"./schema\";\n\nexport const buildEntityType = ({\n  entity,\n  entityGqlTypes,\n}: {\n  entity: Entity;\n  entityGqlTypes: Record<string, GraphQLObjectType<Source, Context>>;\n}): GraphQLObjectType<Source, Context> => {\n  return new GraphQLObjectType({\n    name: entity.name,\n    fields: () => {\n      const fieldConfigMap: GraphQLFieldConfigMap<Source, Context> = {};\n\n      entity.fields.forEach((field) => {\n        switch (field.kind) {\n          case \"SCALAR\": {\n            fieldConfigMap[field.name] = {\n              type: field.notNull\n                ? new GraphQLNonNull(field.scalarGqlType)\n                : field.scalarGqlType,\n              // Convert bigints to strings for GraphQL responses.\n              resolve:\n                field.scalarTypeName === \"BigInt\"\n                  ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                    // @ts-ignore\n                    (parent) => (parent[field.name] as bigint).toString()\n                  : undefined,\n            };\n            break;\n          }\n          case \"ENUM\": {\n            fieldConfigMap[field.name] = {\n              type: field.notNull\n                ? new GraphQLNonNull(field.enumGqlType)\n                : field.enumGqlType,\n            };\n            break;\n          }\n          case \"RELATIONSHIP\": {\n            const resolver: GraphQLFieldResolver<Source, Context> = async (\n              parent,\n              args,\n              context\n            ) => {\n              const { store } = context;\n\n              // The parent object gets passed in here with relationship fields defined as the\n              // string ID of the related entity. Here, we get the ID and query for that entity.\n              // Then, the GraphQL server serves the resolved object here instead of the ID.\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              const relatedInstanceId = parent[field.name];\n\n              return await store.findUnique({\n                modelName: field.relatedEntityName,\n                id: relatedInstanceId,\n              });\n            };\n\n            fieldConfigMap[field.name] = {\n              type: entityGqlTypes[field.baseGqlType.name],\n              resolve: resolver,\n            };\n\n            break;\n          }\n          case \"DERIVED\": {\n            const resolver: GraphQLFieldResolver<Source, Context> = async (\n              parent,\n              args,\n              context\n            ) => {\n              const { store } = context;\n\n              // The parent object gets passed in here with relationship fields defined as the\n              // string ID of the related entity. Here, we get the ID and query for that entity.\n              // Then, the GraphQL server serves the resolved object here instead of the ID.\n              // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n              // @ts-ignore\n              const entityId = parent.id;\n\n              return await store.findMany({\n                modelName: field.derivedFromEntityName,\n                filter: {\n                  where: {\n                    [field.derivedFromFieldName]: entityId,\n                  },\n                },\n              });\n            };\n\n            fieldConfigMap[field.name] = {\n              type: new GraphQLNonNull(\n                new GraphQLList(\n                  new GraphQLNonNull(entityGqlTypes[field.baseGqlType.name])\n                )\n              ),\n              resolve: resolver,\n            };\n\n            break;\n          }\n          case \"LIST\": {\n            const listType = new GraphQLList(\n              field.isListElementNotNull\n                ? new GraphQLNonNull(field.baseGqlType as GraphQLOutputType)\n                : field.baseGqlType\n            );\n            fieldConfigMap[field.name] = {\n              type: field.notNull ? new GraphQLNonNull(listType) : listType,\n            };\n            break;\n          }\n        }\n      });\n\n      return fieldConfigMap;\n    },\n  });\n};\n","import {\n  GraphQLFieldConfig,\n  GraphQLFieldResolver,\n  GraphQLInputObjectType,\n  GraphQLInputType,\n  GraphQLInt,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLString,\n} from \"graphql\";\n\nimport type { Entity } from \"@/schema/types\";\n\nimport type { Context, Source } from \"./schema\";\n\ntype WhereInputArg = {\n  [key: string]: number | string;\n};\ntype PluralArgs = {\n  where?: WhereInputArg;\n  first?: number;\n  skip?: number;\n  orderBy?: string;\n  orderDirection?: \"asc\" | \"desc\";\n};\ntype PluralResolver = GraphQLFieldResolver<Source, Context, PluralArgs>;\n\nconst operators = {\n  universal: [\"\", \"_not\"],\n  singular: [\"_in\", \"_not_in\"],\n  plural: [\"_contains\", \"_not_contains\"],\n  numeric: [\"_gt\", \"_lt\", \"_gte\", \"_lte\"],\n  string: [\n    \"_contains\",\n    \"_not_contains\",\n    \"_starts_with\",\n    \"_ends_with\",\n    \"_not_starts_with\",\n    \"_not_ends_with\",\n  ],\n};\n\nconst buildPluralField = ({\n  entity,\n  entityGqlType,\n}: {\n  entity: Entity;\n  entityGqlType: GraphQLObjectType<Source, Context>;\n}): GraphQLFieldConfig<Source, Context> => {\n  const filterFields: Record<string, { type: GraphQLInputType }> = {};\n\n  entity.fields.forEach((field) => {\n    switch (field.kind) {\n      case \"SCALAR\": {\n        // Scalar fields => universal, singular, numeric OR string depending on base type\n        // Note: Booleans => universal and singular only.\n        operators.universal.forEach((suffix) => {\n          filterFields[`${field.name}${suffix}`] = {\n            type: field.scalarGqlType,\n          };\n        });\n\n        operators.singular.forEach((suffix) => {\n          filterFields[`${field.name}${suffix}`] = {\n            type: new GraphQLList(field.scalarGqlType),\n          };\n        });\n\n        if ([\"Int\", \"BigInt\", \"Float\"].includes(field.scalarTypeName)) {\n          operators.numeric.forEach((suffix) => {\n            filterFields[`${field.name}${suffix}`] = {\n              type: field.scalarGqlType,\n            };\n          });\n        }\n\n        if ([\"String\", \"Bytes\"].includes(field.scalarTypeName)) {\n          operators.string.forEach((suffix) => {\n            filterFields[`${field.name}${suffix}`] = {\n              type: field.scalarGqlType,\n            };\n          });\n        }\n\n        break;\n      }\n      case \"ENUM\": {\n        // Enum fields => universal, singular\n        operators.universal.forEach((suffix) => {\n          filterFields[`${field.name}${suffix}`] = { type: field.enumGqlType };\n        });\n\n        operators.singular.forEach((suffix) => {\n          filterFields[`${field.name}${suffix}`] = {\n            type: new GraphQLList(field.enumGqlType),\n          };\n        });\n        break;\n      }\n      case \"LIST\": {\n        // List fields => universal, plural\n        operators.universal.forEach((suffix) => {\n          filterFields[`${field.name}${suffix}`] = {\n            type: new GraphQLList(field.baseGqlType),\n          };\n        });\n\n        operators.plural.forEach((suffix) => {\n          filterFields[`${field.name}${suffix}`] = { type: field.baseGqlType };\n        });\n        break;\n      }\n      case \"RELATIONSHIP\": {\n        // Relationship fields => universal, singular, numeric OR string depending on base type\n        operators.universal.forEach((suffix) => {\n          filterFields[`${field.name}${suffix}`] = {\n            type: field.relatedEntityIdType,\n          };\n        });\n\n        operators.singular.forEach((suffix) => {\n          filterFields[`${field.name}${suffix}`] = {\n            type: new GraphQLList(field.relatedEntityIdType),\n          };\n        });\n\n        if (\n          [\"Int\", \"BigInt\", \"Float\"].includes(field.relatedEntityIdType.name)\n        ) {\n          operators.numeric.forEach((suffix) => {\n            filterFields[`${field.name}${suffix}`] = {\n              type: field.relatedEntityIdType,\n            };\n          });\n        }\n\n        if ([\"String\", \"Bytes\"].includes(field.relatedEntityIdType.name)) {\n          operators.string.forEach((suffix) => {\n            filterFields[`${field.name}${suffix}`] = {\n              type: field.relatedEntityIdType,\n            };\n          });\n        }\n\n        // TODO: Add complex \"{fieldName}_\" filter field.\n        break;\n      }\n      case \"DERIVED\": {\n        // TODO: Add derived filter fields.\n        break;\n      }\n    }\n  });\n\n  const filterType = new GraphQLInputObjectType({\n    name: `${entity.name}Filter`,\n    fields: filterFields,\n  });\n\n  const resolver: PluralResolver = async (_, args, context) => {\n    const { store } = context;\n\n    const filter = args;\n\n    return await store.findMany({ modelName: entity.name, filter });\n  };\n\n  return {\n    type: new GraphQLNonNull(\n      new GraphQLList(new GraphQLNonNull(entityGqlType))\n    ),\n    args: {\n      where: { type: filterType },\n      first: { type: GraphQLInt },\n      skip: { type: GraphQLInt },\n      orderBy: { type: GraphQLString },\n      orderDirection: { type: GraphQLString },\n    },\n    resolve: resolver,\n  };\n};\n\nexport { buildPluralField };\n","import {\n  GraphQLFieldConfig,\n  GraphQLFieldResolver,\n  GraphQLNonNull,\n  GraphQLObjectType,\n} from \"graphql\";\n\nimport type { Entity } from \"@/schema/types\";\n\nimport type { Context, Source } from \"./schema\";\n\ntype SingularArgs = {\n  id?: string;\n};\ntype SingularResolver = GraphQLFieldResolver<Source, Context, SingularArgs>;\n\nconst buildSingularField = ({\n  entity,\n  entityGqlType,\n}: {\n  entity: Entity;\n  entityGqlType: GraphQLObjectType<Source, Context>;\n}): GraphQLFieldConfig<Source, Context> => {\n  const resolver: SingularResolver = async (_, args, context) => {\n    const { store } = context;\n    const { id } = args;\n\n    if (!id) return null;\n\n    const entityInstance = await store.findUnique({\n      modelName: entity.name,\n      id: id,\n    });\n\n    return entityInstance;\n  };\n\n  return {\n    type: entityGqlType,\n    args: {\n      id: { type: new GraphQLNonNull(entity.fieldByName.id.scalarGqlType) },\n    },\n    resolve: resolver,\n  };\n};\n\nexport { buildSingularField };\n","import { buildSchema } from \"graphql\";\nimport { readFileSync } from \"node:fs\";\n\nimport { Options } from \"@/config/options\";\n\nexport const schemaHeader = `\n\"Directs the executor to process this type as a Ponder entity.\"\ndirective @entity(immutable: Boolean = false) on OBJECT\n\n\"Creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.\"\ndirective @derivedFrom(field: String!) on FIELD_DEFINITION\n\nscalar Bytes\nscalar BigInt\n`;\n\nexport const readGraphqlSchema = ({ options }: { options: Options }) => {\n  const schemaBody = readFileSync(options.schemaFile);\n  const schemaSource = schemaHeader + schemaBody.toString();\n\n  const schema = buildSchema(schemaSource);\n  return schema;\n};\n","import Emittery from \"emittery\";\nimport { GraphQLSchema, printSchema } from \"graphql\";\nimport { writeFileSync } from \"node:fs\";\nimport path from \"node:path\";\n\nimport { Contract } from \"@/config/contracts\";\nimport { LogFilter } from \"@/config/logFilters\";\nimport { Resources } from \"@/Ponder\";\nimport { Schema } from \"@/schema/types\";\nimport { ensureDirExists } from \"@/utils/exists\";\n\nimport { buildContractTypes } from \"./contract\";\nimport { buildEntityTypes } from \"./entity\";\nimport { buildEventTypes } from \"./event\";\nimport { formatPrettier } from \"./prettier\";\n\nexport class CodegenService extends Emittery {\n  private resources: Resources;\n  private contracts: Contract[];\n  private logFilters: LogFilter[];\n\n  constructor({\n    resources,\n    contracts,\n    logFilters,\n  }: {\n    resources: Resources;\n    contracts: Contract[];\n    logFilters: LogFilter[];\n  }) {\n    super();\n    this.resources = resources;\n    this.contracts = contracts;\n    this.logFilters = logFilters;\n  }\n\n  generateAppFile({ schema }: { schema?: Schema } = {}) {\n    const entities = schema?.entities || [];\n\n    const raw = `\n      /* Autogenerated file. Do not edit manually. */\n  \n      import { PonderApp } from \"@ponder/core\";\n      import type { Block, Log, Transaction, Model, ReadOnlyContract } from \"@ponder/core\";\n      import type { AbiParameterToPrimitiveType } from \"abitype\";\n      import type { BlockTag, Hash } from \"viem\";\n\n      /* ENTITY TYPES */\n\n      ${buildEntityTypes(entities)}\n  \n      /* CONTRACT TYPES */\n\n      ${buildContractTypes(this.contracts)}\n\n      /* CONTEXT TYPES */\n\n      export type Context = {\n        contracts: {\n          ${this.contracts\n            .map((contract) => `${contract.name}: ${contract.name};`)\n            .join(\"\")}\n        },\n        entities: {\n          ${entities\n            .map((entity) => `${entity.name}: Model<${entity.name}>;`)\n            .join(\"\")}\n        },\n      }\n\n  \n      /* HANDLER TYPES */\n    \n      ${buildEventTypes(this.logFilters)}\n\n      export const ponder = new PonderApp<AppType>();\n    `;\n\n    const final = formatPrettier(raw);\n\n    const filePath = path.join(this.resources.options.generatedDir, \"index.ts\");\n    ensureDirExists(filePath);\n    writeFileSync(filePath, final, \"utf8\");\n\n    this.resources.logger.debug({\n      service: \"codegen\",\n      msg: `Wrote new file at generated/index.ts`,\n    });\n  }\n\n  generateSchemaFile({ graphqlSchema }: { graphqlSchema: GraphQLSchema }) {\n    const header = `\n      \"\"\" Autogenerated file. Do not edit manually. \"\"\"\n    `;\n\n    const body = printSchema(graphqlSchema);\n    const final = header + body;\n\n    const filePath = path.join(\n      this.resources.options.generatedDir,\n      \"schema.graphql\"\n    );\n    ensureDirExists(filePath);\n    writeFileSync(filePath, final, \"utf8\");\n\n    this.resources.logger.debug({\n      service: \"codegen\",\n      msg: `Wrote new file at generated/schema.graphql`,\n    });\n  }\n}\n","import { existsSync, mkdirSync } from \"node:fs\";\nimport path from \"node:path\";\n\nexport const ensureDirExists = (filePath: string) => {\n  const dirname = path.dirname(filePath);\n  if (existsSync(dirname)) {\n    return;\n  }\n  mkdirSync(dirname, { recursive: true });\n};\n","import { AbiParameter } from \"abitype\";\n\nimport type { Contract } from \"@/config/contracts\";\n\ntype AbiReadOrViewFunction = {\n  type: \"function\";\n  stateMutability: \"pure\" | \"view\";\n  inputs: readonly AbiParameter[];\n  name: string;\n  outputs: readonly AbiParameter[];\n};\n\nexport const buildContractTypes = (contracts: Contract[]) => {\n  return contracts\n    .map((contract) => {\n      const abiReadOrViewFunctions = contract.abi.filter(\n        (item): item is AbiReadOrViewFunction =>\n          item.type === \"function\" &&\n          (item.stateMutability === \"pure\" || item.stateMutability === \"view\")\n      );\n\n      return `\n      const ${contract.name}Abi = ${JSON.stringify(\n        abiReadOrViewFunctions\n      )} as const;\n\n      export type ${contract.name} = ReadOnlyContract<typeof ${\n        contract.name\n      }Abi>;\n      `;\n    })\n    .join(\"\\n\");\n};\n","import { Kind } from \"graphql\";\n\nimport type { Entity } from \"@/schema/types\";\n\nconst gqlScalarToTsType: Record<string, string | undefined> = {\n  String: \"string\",\n  Boolean: \"boolean\",\n  Int: \"number\",\n  Float: \"number\",\n  BigInt: \"bigint\",\n  Bytes: \"string\",\n};\n\nexport const buildEntityTypes = (entities: Entity[]) => {\n  const entityModelTypes = entities\n    .map((entity) => {\n      return `export type ${entity.name} = {\n        ${entity.fields\n          .map((field) => {\n            switch (field.kind) {\n              case \"SCALAR\": {\n                const scalarTsType = gqlScalarToTsType[field.scalarTypeName];\n                if (!scalarTsType) {\n                  throw new Error(\n                    `TypeScript type not found for scalar: ${field.scalarTypeName}`\n                  );\n                }\n                return `${field.name}${\n                  field.notNull ? \"\" : \"?\"\n                }: ${scalarTsType};`;\n              }\n              case \"ENUM\": {\n                return `${field.name}${\n                  field.notNull ? \"\" : \"?\"\n                }: ${field.enumValues.map((val) => `\"${val}\"`).join(\" | \")};`;\n              }\n              case \"LIST\": {\n                // This is trash\n                let tsBaseType: string;\n                if (\n                  Object.keys(gqlScalarToTsType).includes(\n                    field.baseGqlType.toString()\n                  )\n                ) {\n                  const scalarTypeName = field.baseGqlType.toString();\n                  const scalarTsType = gqlScalarToTsType[scalarTypeName];\n                  if (!scalarTsType) {\n                    throw new Error(\n                      `TypeScript type not found for scalar: ${scalarTypeName}`\n                    );\n                  }\n                  tsBaseType = scalarTsType;\n                } else if (\n                  field.baseGqlType.astNode?.kind === Kind.ENUM_TYPE_DEFINITION\n                ) {\n                  const enumValues = (\n                    field.baseGqlType.astNode?.values || []\n                  ).map((v) => v.name.value);\n                  tsBaseType = `(${enumValues\n                    .map((v) => `\"${v}\"`)\n                    .join(\" | \")})`;\n                } else {\n                  throw new Error(\n                    `Unable to generate type for field: ${field.name}`\n                  );\n                }\n\n                if (!field.isListElementNotNull) {\n                  tsBaseType = `(${tsBaseType} | null)`;\n                }\n\n                return `${field.name}${\n                  field.notNull ? \"\" : \"?\"\n                }: ${tsBaseType}[];`;\n              }\n              case \"RELATIONSHIP\": {\n                return `${field.name}${field.notNull ? \"\" : \"?\"}: string;`;\n              }\n            }\n          })\n          .join(\"\")}\n        };`;\n    })\n    .join(\"\");\n\n  return entityModelTypes;\n};\n","import { AbiEvent } from \"abitype\";\n\nimport { LogFilter } from \"@/config/logFilters\";\n\nexport const buildEventTypes = (logFilters: LogFilter[]) => {\n  const allHandlers = logFilters.map((logFilter) => {\n    const abiEvents = logFilter.abi.filter(\n      (item): item is AbiEvent => item.type === \"event\"\n    );\n\n    return abiEvents\n      .map(({ name, inputs }) => {\n        const paramsType = `{${inputs\n          .map((input, index) => {\n            const inputName = input.name ? input.name : `param_${index}`;\n            return `${inputName}:\n              AbiParameterToPrimitiveType<${JSON.stringify(input)}>`;\n          })\n          .join(\";\")}}`;\n\n        return `[\"${logFilter.name}:${name}\"]: ({\n            event, context\n            }: {\n              event: {\n                name: \"${name}\";\n                params: ${paramsType};\n                log: Log;\n                block: Block;\n                transaction: Transaction;\n              };\n              context: Context;\n            }) => Promise<any> | any;`;\n      })\n      .join(\"\");\n  });\n\n  allHandlers.unshift(\n    `[\"setup\"]: ({ context }: { context: Context; }) => Promise<any> | any;`\n  );\n\n  const final = `\n    export type AppType = {\n      ${allHandlers.join(\"\")}\n    }\n  `;\n\n  return final;\n};\n","import prettier from \"prettier\";\n\nlet prettierConfig: prettier.Options = { parser: \"typescript\" };\n\nconst loadPrettierConfig = async () => {\n  if (prettierConfig) return prettierConfig;\n\n  const configFile = await prettier.resolveConfigFile();\n  if (configFile) {\n    const foundConfig = await prettier.resolveConfig(configFile);\n    if (foundConfig) {\n      prettierConfig = foundConfig;\n    }\n  }\n};\n\n// Just call this once on process start\nloadPrettierConfig();\n\nexport const formatPrettier = (\n  source: string,\n  configOverrides?: Partial<prettier.Options>\n) => {\n  return prettier.format(source, { ...prettierConfig, ...configOverrides });\n};\n","import { Abi } from \"abitype\";\nimport { readFileSync } from \"node:fs\";\nimport path from \"node:path\";\n\nexport const buildAbi = ({\n  abiConfig,\n  configFilePath,\n}: {\n  abiConfig: string | any[] | object | (string | any[] | object)[];\n  configFilePath: string;\n}) => {\n  let resolvedAbi: Abi;\n  const filePaths: string[] = [];\n\n  if (\n    typeof abiConfig === \"string\" ||\n    (Array.isArray(abiConfig) &&\n      (abiConfig.length === 0 || typeof abiConfig[0] === \"object\"))\n  ) {\n    // If abiConfig is a string or an ABI itself, treat it as a single ABI.\n    const { abi, filePath } = buildSingleAbi({ abiConfig, configFilePath });\n    resolvedAbi = abi;\n    if (filePath) filePaths.push(filePath);\n  } else {\n    // Otherwise, handle as an array of of ABIs.\n    const results = (abiConfig as (object | any[])[]).map((a) =>\n      buildSingleAbi({ abiConfig: a, configFilePath })\n    );\n\n    const mergedAbi = results\n      .map(({ abi }) => abi.filter((item) => item.type !== \"constructor\"))\n      .flat()\n      .flat();\n    const mergedUniqueAbi = [\n      ...new Map(\n        mergedAbi.map((item) => [JSON.stringify(item), item])\n      ).values(),\n    ];\n\n    filePaths.push(\n      ...results.map((r) => r.filePath).filter((f): f is string => !!f)\n    );\n\n    resolvedAbi = mergedUniqueAbi;\n  }\n\n  return {\n    abi: resolvedAbi,\n    filePaths,\n  };\n};\n\nconst buildSingleAbi = ({\n  abiConfig,\n  configFilePath,\n}: {\n  abiConfig: string | any[] | object;\n  configFilePath: string;\n}) => {\n  let filePath: string | undefined = undefined;\n  let abi: Abi;\n\n  if (typeof abiConfig === \"string\") {\n    // If a string, treat it as a file path.\n    filePath = path.isAbsolute(abiConfig)\n      ? abiConfig\n      : path.join(path.dirname(configFilePath), abiConfig);\n\n    const abiString = readFileSync(filePath, \"utf-8\");\n    abi = JSON.parse(abiString);\n  } else {\n    // Otherwise, treat as the ABI itself\n    abi = abiConfig as unknown as Abi;\n  }\n\n  // NOTE: Not currently using the filePath arg here, but eventually\n  // could use it to watch for changes and reload.\n  return { abi, filePath };\n};\n","import { createPublicClient, http, PublicClient } from \"viem\";\nimport { mainnet } from \"viem/chains\";\n\nimport { ResolvedConfig } from \"@/config/config\";\n\nexport type Network = {\n  name: string;\n  chainId: number;\n  client: PublicClient;\n  rpcUrl?: string;\n  pollingInterval: number;\n  defaultMaxBlockRange: number;\n  maxRpcRequestConcurrency: number;\n  finalityBlockCount: number;\n};\n\nconst clients: Record<number, PublicClient | undefined> = {};\n\nexport function buildNetwork({\n  network,\n}: {\n  network: ResolvedConfig[\"networks\"][0];\n}) {\n  let client = clients[network.chainId];\n\n  if (!client) {\n    client = createPublicClient({\n      transport: http(network.rpcUrl),\n      chain: {\n        ...mainnet,\n        name: network.name,\n        id: network.chainId,\n        network: network.name,\n      },\n    });\n    clients[network.chainId] = client;\n  }\n\n  const resolvedNetwork: Network = {\n    name: network.name,\n    chainId: network.chainId,\n    client,\n    rpcUrl: network.rpcUrl,\n    pollingInterval: network.pollingInterval ?? 1_000,\n    defaultMaxBlockRange: getDefaultMaxBlockRange(network),\n    maxRpcRequestConcurrency: network.maxRpcRequestConcurrency ?? 10,\n    finalityBlockCount: getFinalityBlockCount(network),\n  };\n\n  return resolvedNetwork;\n}\n\nfunction getDefaultMaxBlockRange(network: {\n  rpcUrl?: string;\n  chainId: number;\n}) {\n  // Quicknode enforces a hard limit of 10_000.\n  if (network.rpcUrl !== undefined && network.rpcUrl.includes(\"quiknode.pro\")) {\n    return 10_000;\n  }\n\n  // Otherwise (e.g. Alchemy) use an optimistically high block limit and lean\n  // on the error handler to resolve failures.\n\n  let maxBlockRange: number;\n  switch (network.chainId) {\n    // Mainnet and mainnet testnets.\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n    case 42:\n    case 11155111:\n      maxBlockRange = 2_000;\n      break;\n    // Optimism.\n    case 10:\n    case 420:\n      maxBlockRange = 50_000;\n      break;\n    // Polygon.\n    case 137:\n    case 80001:\n      maxBlockRange = 50_000;\n      break;\n    // Arbitrum.\n    case 42161:\n    case 421613:\n      maxBlockRange = 50_000;\n      break;\n    default:\n      maxBlockRange = 50_000;\n  }\n\n  return maxBlockRange;\n}\n\n/**\n * Returns the number of blocks that must pass before a block is considered final.\n * Note that a value of `0` indicates that blocks are considered final immediately.\n *\n * @param network The network to get the finality block count for.\n * @returns The finality block count.\n */\nfunction getFinalityBlockCount(network: { chainId: number }) {\n  let finalityBlockCount: number;\n  switch (network.chainId) {\n    // Mainnet and mainnet testnets.\n    case 1:\n    case 3:\n    case 4:\n    case 5:\n    case 42:\n    case 11155111:\n      finalityBlockCount = 32;\n      break;\n    // Optimism.\n    case 10:\n    case 420:\n      finalityBlockCount = 5;\n      break;\n    // Polygon.\n    case 137:\n    case 80001:\n      finalityBlockCount = 100;\n      break;\n    // Arbitrum.\n    case 42161:\n    case 421613:\n      finalityBlockCount = 40;\n      break;\n    // Zora.\n    case 7777777:\n      finalityBlockCount = 5;\n      break;\n    default:\n      finalityBlockCount = 5;\n  }\n\n  return finalityBlockCount;\n}\n","import { Abi, Address } from \"abitype\";\n\nimport { ResolvedConfig } from \"@/config/config\";\nimport { Options } from \"@/config/options\";\n\nimport { buildAbi } from \"./abi\";\nimport { buildNetwork, Network } from \"./networks\";\n\nexport type Contract = {\n  name: string;\n  address: Address;\n  network: Network;\n  abi: Abi;\n};\n\nexport function buildContracts({\n  config,\n  options,\n}: {\n  config: ResolvedConfig;\n  options: Options;\n}): Contract[] {\n  return (config.contracts ?? []).map((contract) => {\n    const address = contract.address.toLowerCase() as Address;\n\n    const { abi } = buildAbi({\n      abiConfig: contract.abi,\n      configFilePath: options.configFile,\n    });\n\n    // Get the contract network/provider.\n    const rawNetwork = config.networks.find((n) => n.name === contract.network);\n    if (!rawNetwork) {\n      throw new Error(\n        `Network [${contract.network}] not found for contract: ${contract.name}`\n      );\n    }\n\n    const network = buildNetwork({ network: rawNetwork });\n\n    return {\n      name: contract.name,\n      address,\n      network: network,\n      abi,\n    };\n  });\n}\n","import Sqlite from \"better-sqlite3\";\nimport path from \"node:path\";\nimport pg, { Client, DatabaseError, Pool } from \"pg\";\n\nimport { ResolvedConfig } from \"@/config/config\";\nimport { Options } from \"@/config/options\";\nimport { PostgresError } from \"@/errors/postgres\";\nimport { SqliteError } from \"@/errors/sqlite\";\nimport { ensureDirExists } from \"@/utils/exists\";\n\nexport interface SqliteDb {\n  kind: \"sqlite\";\n  db: Sqlite.Database;\n}\n\nexport interface PostgresDb {\n  kind: \"postgres\";\n  pool: Pool;\n}\n\nexport type Database = SqliteDb | PostgresDb;\n\n// Set pg protocol to use BigInt.\npg.types.setTypeParser(20, BigInt);\n\n// Monkeypatch Pool.query to get more informative stack traces. I have no idea why this works.\n// https://stackoverflow.com/a/70601114\nconst originalClientQuery = Client.prototype.query;\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nClient.prototype.query = async function query(\n  ...args: [queryText: string, values: any[], callback: () => void]\n) {\n  try {\n    return await originalClientQuery.apply(this, args);\n  } catch (error) {\n    const [statement, parameters] = args;\n\n    if (error instanceof DatabaseError) {\n      const parameters_ = parameters ?? [];\n      throw new PostgresError({\n        statement,\n        parameters:\n          parameters_.length <= 25\n            ? parameters_\n            : parameters_.slice(0, 26).concat([\"...\"]),\n        pgError: error,\n      });\n    }\n\n    throw error;\n  }\n};\n\nexport const patchSqliteDatabase = ({ db }: { db: any }) => {\n  const oldPrepare = db.prepare;\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  db.prepare = (source: string) => {\n    const statement = oldPrepare.apply(db, [source]);\n\n    const wrapper =\n      (fn: (...args: any) => void) =>\n      (...args: any) => {\n        try {\n          return fn.apply(statement, args);\n        } catch (error) {\n          throw new SqliteError({\n            statement: source,\n            parameters: args[0],\n            sqliteError: error as Error,\n          });\n        }\n      };\n\n    for (const method of [\"run\", \"get\", \"all\"]) {\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      statement[method] = wrapper(statement[method]);\n    }\n\n    return statement;\n  };\n\n  return db;\n};\n\nexport const buildDatabase = ({\n  options,\n  config,\n}: {\n  options: Options;\n  config: ResolvedConfig;\n}): Database => {\n  let resolvedDatabaseConfig: NonNullable<ResolvedConfig[\"database\"]>;\n\n  const defaultSqliteFilename = path.join(options.ponderDir, \"cache.db\");\n\n  if (config.database) {\n    if (config.database.kind === \"postgres\") {\n      resolvedDatabaseConfig = {\n        kind: \"postgres\",\n        connectionString: config.database.connectionString,\n      };\n    } else {\n      resolvedDatabaseConfig = {\n        kind: \"sqlite\",\n        filename: config.database.filename ?? defaultSqliteFilename,\n      };\n    }\n  } else {\n    if (process.env.DATABASE_URL) {\n      resolvedDatabaseConfig = {\n        kind: \"postgres\",\n        connectionString: process.env.DATABASE_URL,\n      };\n    } else {\n      resolvedDatabaseConfig = {\n        kind: \"sqlite\",\n        filename: defaultSqliteFilename,\n      };\n    }\n  }\n\n  if (resolvedDatabaseConfig.kind === \"sqlite\") {\n    ensureDirExists(resolvedDatabaseConfig.filename!);\n    const rawDb = Sqlite(resolvedDatabaseConfig.filename!);\n    rawDb.pragma(\"journal_mode = WAL\");\n\n    const db = patchSqliteDatabase({ db: rawDb });\n\n    return { kind: \"sqlite\", db };\n  } else {\n    const pool = new Pool({\n      connectionString: resolvedDatabaseConfig.connectionString,\n    });\n\n    return { kind: \"postgres\", pool };\n  }\n};\n","// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/021ce8e5a3fb02db6139564345a91fc77cba08a6/src/errors/transaction.ts#L6-L19\nexport function prettyPrint(\n  args: Record<string, bigint | number | string | undefined | false | unknown>\n) {\n  const entries = Object.entries(args)\n    .map(([key, value]) => {\n      if (value === undefined || value === false) return null;\n\n      const trimmedValue =\n        typeof value === \"string\" && value.length > 80\n          ? value.slice(0, 80).concat(\"...\")\n          : value;\n\n      return [key, trimmedValue];\n    })\n    .filter(Boolean) as [string, string][];\n  const maxLength = entries.reduce(\n    (acc, [key]) => Math.max(acc, key.length),\n    0\n  );\n  return entries\n    .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n    .join(\"\\n\");\n}\n","type BaseErrorParameters = {\n  metaMessages?: string[];\n} & (\n  | {\n      cause?: never;\n      details?: string;\n    }\n  | {\n      cause: BaseError | Error;\n      details?: never;\n    }\n);\n\n// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/021ce8e5a3fb02db6139564345a91fc77cba08a6/src/errors/base.ts#L17\nexport class BaseError extends Error {\n  details?: string;\n  metaMessages?: string[];\n  shortMessage: string;\n\n  name = \"PonderError\";\n\n  constructor(shortMessage: string, args: BaseErrorParameters = {}) {\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n        ? args.cause.message\n        : args.details;\n\n    const message = [\n      shortMessage || \"An error occurred.\",\n      // \"\",\n      ...(args.metaMessages ? [...args.metaMessages, \"\"] : []),\n      ...(details ? [`Details: ${details}`] : []),\n    ].join(\"\\n\");\n\n    super(message);\n\n    if (args.cause) this.cause = args.cause;\n    if (!details) this.details = message;\n    this.metaMessages = args.metaMessages;\n    this.shortMessage = shortMessage;\n  }\n}\n","import { DatabaseError } from \"pg\";\n\nimport { prettyPrint } from \"@/utils/print\";\n\nimport { BaseError } from \"./base\";\n\nexport class PostgresError extends BaseError {\n  name = \"PostgresError\";\n\n  constructor({\n    statement,\n    parameters,\n    pgError,\n  }: {\n    statement: string;\n    parameters: (string | number | bigint)[];\n    pgError: DatabaseError;\n  }) {\n    const params = parameters.reduce<Record<number, any>>(\n      (acc, parameter, idx) => {\n        acc[idx + 1] = parameter;\n        return acc;\n      },\n      {}\n    );\n\n    const metaMessages = [];\n    if (pgError.detail) metaMessages.push(`Detail:\\n  ${pgError.detail}`);\n    metaMessages.push(`Statement:\\n  ${statement}`);\n    metaMessages.push(`Parameters:\\n${prettyPrint(params)}`);\n\n    const shortMessage = `PostgreSQL error: ${pgError.message}`;\n\n    super(shortMessage, {\n      metaMessages,\n    });\n  }\n}\n","import { prettyPrint } from \"@/utils/print\";\n\nimport { BaseError } from \"./base\";\n\nexport class SqliteError extends BaseError {\n  name = \"SqliteError\";\n\n  constructor({\n    statement,\n    parameters,\n    sqliteError,\n  }: {\n    statement: string;\n    parameters: (string | number | bigint)[];\n    sqliteError: Error;\n  }) {\n    const params = parameters.reduce<Record<number, any>>(\n      (acc, parameter, idx) => {\n        acc[idx + 1] = parameter;\n        return acc;\n      },\n      {}\n    );\n\n    const metaMessages = [];\n    metaMessages.push(`Statement:\\n  ${statement}`);\n    metaMessages.push(`Parameters:\\n${prettyPrint(params)}`);\n\n    const shortMessage = `SQLite error: ${sqliteError.message}`;\n\n    super(shortMessage, {\n      metaMessages,\n    });\n  }\n}\n","import { Abi, Address } from \"abitype\";\nimport { encodeEventTopics } from \"viem\";\n\nimport { ResolvedConfig } from \"@/config/config\";\nimport { Options } from \"@/config/options\";\n\nimport { buildAbi } from \"./abi\";\nimport { encodeLogFilterKey } from \"./logFilterKey\";\n\nexport type LogFilter = {\n  name: string;\n  abi: Abi;\n  network: string;\n  filter: {\n    key: string; // `${chainId}-${address}-${topics}`\n    chainId: number;\n    address?: `0x${string}` | `0x${string}`[];\n    topics?: (`0x${string}` | `0x${string}`[] | null)[];\n    startBlock: number;\n    endBlock?: number;\n  };\n  maxBlockRange?: number;\n};\n\nexport function buildLogFilters({\n  config,\n  options,\n}: {\n  config: ResolvedConfig;\n  options: Options;\n}) {\n  const contractLogFilters = (config.contracts ?? [])\n    .filter((contract) => contract.isLogEventSource ?? true)\n    .map((contract) => {\n      const { abi } = buildAbi({\n        abiConfig: contract.abi,\n        configFilePath: options.configFile,\n      });\n\n      // Get the contract network/provider.\n      const network = config.networks.find((n) => n.name === contract.network);\n      if (!network) {\n        throw new Error(\n          `Network [${contract.network}] not found for contract: ${contract.name}`\n        );\n      }\n\n      const address = contract.address.toLowerCase() as Address;\n      const topics = undefined;\n      const key = encodeLogFilterKey({\n        chainId: network.chainId,\n        address,\n        topics,\n      });\n\n      const logFilter: LogFilter = {\n        name: contract.name,\n        abi,\n        network: network.name,\n        filter: {\n          key,\n          chainId: network.chainId,\n          address,\n          topics,\n          startBlock: contract.startBlock ?? 0,\n          endBlock: contract.endBlock,\n        },\n        maxBlockRange: contract.maxBlockRange,\n      };\n\n      return logFilter;\n    });\n\n  const filterLogFilters = (config.filters ?? []).map((filter) => {\n    const { abi } = buildAbi({\n      abiConfig: filter.abi,\n      configFilePath: options.configFile,\n    });\n\n    // Get the contract network/provider.\n    const network = config.networks.find((n) => n.name === filter.network);\n    if (!network) {\n      throw new Error(\n        `Network [${filter.network}] not found for filter: ${filter.name}`\n      );\n    }\n\n    const address = Array.isArray(filter.filter.address)\n      ? filter.filter.address.map((a) => a.toLowerCase() as Address)\n      : typeof filter.filter.address === \"string\"\n      ? (filter.filter.address.toLowerCase() as Address)\n      : undefined;\n\n    const topics = filter.filter.event\n      ? encodeEventTopics({\n          abi: [filter.filter.event],\n          eventName: filter.filter.event.name,\n          args: filter.filter.args as any,\n        })\n      : undefined;\n\n    const key = encodeLogFilterKey({\n      chainId: network.chainId,\n      address,\n      topics,\n    });\n\n    const logFilter: LogFilter = {\n      name: filter.name,\n      abi,\n      network: network.name,\n      filter: {\n        key,\n        chainId: network.chainId,\n        address,\n        topics,\n        startBlock: filter.startBlock ?? 0,\n        endBlock: filter.endBlock,\n      },\n      maxBlockRange: filter.maxBlockRange,\n    };\n\n    return logFilter;\n  });\n\n  const logFilters = contractLogFilters.concat(filterLogFilters);\n\n  return logFilters;\n}\n","import { Address, Hex } from \"viem\";\n\nexport function encodeLogFilterKey({\n  chainId,\n  address,\n  topics,\n}: {\n  chainId: number;\n  address?: Address | Address[];\n  topics?: (Hex | Hex[] | null)[];\n}) {\n  return `${chainId}-${JSON.stringify(address ?? null)}-${JSON.stringify(\n    topics ?? null\n  )}`;\n}\n\nexport function decodeLogFilterKey({ key }: { key: string }) {\n  const [chainId, addressString, topicsString] = key.split(\"-\");\n\n  return {\n    chainId: Number(chainId),\n    address:\n      (JSON.parse(addressString) as Address | Address[] | null) ?? undefined,\n    topics:\n      (JSON.parse(topicsString) as (Hex | Hex[] | null)[] | null) ?? undefined,\n  };\n}\n","import Emittery from \"emittery\";\n\nimport { UserError } from \"./user\";\n\ntype UserErrorEvents = {\n  error: { error: UserError };\n};\n\nexport class UserErrorService extends Emittery<UserErrorEvents> {\n  hasUserError = false;\n\n  submitUserError({ error }: { error: UserError }) {\n    this.hasUserError = true;\n    this.emit(\"error\", { error });\n  }\n}\n","import { AbiEvent } from \"abitype\";\nimport Emittery from \"emittery\";\nimport { decodeEventLog, Hex } from \"viem\";\n\nimport { LogFilter } from \"@/config/logFilters\";\nimport type { Network } from \"@/config/networks\";\nimport type { EventStore } from \"@/event-store/store\";\nimport { Block } from \"@/types/block\";\nimport { Log } from \"@/types/log\";\nimport { Transaction } from \"@/types/transaction\";\n\nexport type LogEvent = {\n  logFilterName: string;\n  eventName: string;\n  params: Record<string, unknown>;\n  log: Log;\n  block: Block;\n  transaction: Transaction;\n};\n\ntype EventAggregatorEvents = {\n  /**\n   * Emitted when a new event checkpoint is reached. This is the minimum timestamp\n   * at which events are available across all registered networks.\n   */\n  newCheckpoint: { timestamp: number };\n  /**\n   * Emitted when a new finality checkpoint is reached. This is the minimum timestamp\n   * at which events are finalized across all registered networks.\n   */\n  newFinalityCheckpoint: { timestamp: number };\n  /**\n   * Emitted when a reorg has been detected on any registered network.\n   */\n  reorg: { commonAncestorTimestamp: number };\n};\n\ntype EventAggregatorMetrics = {};\n\nexport class EventAggregatorService extends Emittery<EventAggregatorEvents> {\n  private eventStore: EventStore;\n  private logFilters: LogFilter[];\n  private networks: Network[];\n\n  // Minimum timestamp at which events are available (across all networks).\n  checkpoint: number;\n  // Minimum finalized timestamp (across all networks).\n  finalityCheckpoint: number;\n\n  // Timestamp at which the historical sync was completed (across all networks).\n  historicalSyncCompletedAt?: number;\n\n  // Per-network event timestamp checkpoints.\n  private networkCheckpoints: Record<\n    number,\n    {\n      isHistoricalSyncComplete: boolean;\n      historicalCheckpoint: number;\n      realtimeCheckpoint: number;\n      finalityCheckpoint: number;\n    }\n  >;\n\n  metrics: EventAggregatorMetrics;\n\n  constructor({\n    eventStore,\n    networks,\n    logFilters,\n  }: {\n    eventStore: EventStore;\n    networks: Network[];\n    logFilters: LogFilter[];\n  }) {\n    super();\n\n    this.eventStore = eventStore;\n    this.logFilters = logFilters;\n    this.networks = networks;\n    this.metrics = {};\n\n    this.checkpoint = 0;\n    this.finalityCheckpoint = 0;\n\n    this.networkCheckpoints = {};\n    this.networks.forEach((network) => {\n      this.networkCheckpoints[network.chainId] = {\n        isHistoricalSyncComplete: false,\n        historicalCheckpoint: 0,\n        realtimeCheckpoint: 0,\n        finalityCheckpoint: 0,\n      };\n    });\n  }\n\n  /** Fetches events for all registered log filters between the specified timestamps.\n   *\n   * @param options.fromTimestamp Timestamp to start including events (inclusive).\n   * @param options.toTimestamp Timestamp to stop including events (inclusive).\n   * @param options.handledLogFilters Subset of log filters that the user has provided a handler for.\n   * @returns A promise resolving to an array of log events.\n   */\n  getEvents = async ({\n    fromTimestamp,\n    toTimestamp,\n    handledLogFilters,\n  }: {\n    fromTimestamp: number;\n    toTimestamp: number;\n    handledLogFilters: Record<\n      string,\n      {\n        eventName: string;\n        topic0: Hex;\n        abiItem: AbiEvent;\n      }[]\n    >;\n  }) => {\n    const { events, totalEventCount } = await this.eventStore.getLogEvents({\n      fromTimestamp,\n      toTimestamp,\n      filters: this.logFilters.map((logFilter) => ({\n        name: logFilter.name,\n        chainId: logFilter.filter.chainId,\n        address: logFilter.filter.address,\n        topics: logFilter.filter.topics,\n        fromBlock: logFilter.filter.startBlock,\n        toBlock: logFilter.filter.endBlock,\n        handledTopic0: handledLogFilters[logFilter.name].map((i) => i.topic0),\n      })),\n    });\n\n    const decodedEvents = events.reduce<LogEvent[]>((acc, event) => {\n      // TODO: Improve decode performance by having the specific ABI event item ready.\n      const logFilterData = handledLogFilters[event.filterName].find(\n        (i) => i.topic0 === event.log.topics[0]\n      );\n\n      try {\n        const decodedLog = decodeEventLog({\n          abi: [logFilterData?.abiItem],\n          data: event.log.data,\n          topics: event.log.topics,\n        });\n\n        acc.push({\n          logFilterName: event.filterName,\n          eventName: decodedLog.eventName,\n          params: decodedLog.args || {},\n          log: event.log,\n          block: event.block,\n          transaction: event.transaction,\n        });\n      } catch (err) {\n        // TODO: emit a warning here that an event was not decoded.\n        // See https://github.com/0xOlias/ponder/issues/187\n      }\n\n      return acc;\n    }, []);\n\n    return {\n      totalEventCount,\n      events: decodedEvents,\n    };\n  };\n\n  handleNewHistoricalCheckpoint = ({\n    chainId,\n    timestamp,\n  }: {\n    chainId: number;\n    timestamp: number;\n  }) => {\n    this.networkCheckpoints[chainId].historicalCheckpoint = timestamp;\n    this.recalculateCheckpoint();\n  };\n\n  handleHistoricalSyncComplete = ({ chainId }: { chainId: number }) => {\n    this.networkCheckpoints[chainId].isHistoricalSyncComplete = true;\n    this.recalculateCheckpoint();\n\n    // If every network has completed the historical sync, set the metric.\n    const networkCheckpoints = Object.values(this.networkCheckpoints);\n    if (networkCheckpoints.every((n) => n.isHistoricalSyncComplete)) {\n      const maxHistoricalCheckpoint = Math.max(\n        ...networkCheckpoints.map((n) => n.historicalCheckpoint)\n      );\n      this.historicalSyncCompletedAt = maxHistoricalCheckpoint;\n    }\n  };\n\n  handleNewRealtimeCheckpoint = ({\n    chainId,\n    timestamp,\n  }: {\n    chainId: number;\n    timestamp: number;\n  }) => {\n    this.networkCheckpoints[chainId].realtimeCheckpoint = timestamp;\n    this.recalculateCheckpoint();\n  };\n\n  handleNewFinalityCheckpoint = ({\n    chainId,\n    timestamp,\n  }: {\n    chainId: number;\n    timestamp: number;\n  }) => {\n    this.networkCheckpoints[chainId].finalityCheckpoint = timestamp;\n    this.recalculateFinalityCheckpoint();\n  };\n\n  handleReorg = ({\n    commonAncestorTimestamp,\n  }: {\n    commonAncestorTimestamp: number;\n  }) => {\n    this.emit(\"reorg\", { commonAncestorTimestamp });\n  };\n\n  private recalculateCheckpoint = () => {\n    const checkpoints = Object.values(this.networkCheckpoints).map((n) =>\n      n.isHistoricalSyncComplete\n        ? Math.max(n.historicalCheckpoint, n.realtimeCheckpoint)\n        : n.historicalCheckpoint\n    );\n    const newCheckpoint = Math.min(...checkpoints);\n\n    if (newCheckpoint > this.checkpoint) {\n      this.checkpoint = newCheckpoint;\n      this.emit(\"newCheckpoint\", { timestamp: this.checkpoint });\n    }\n  };\n\n  private recalculateFinalityCheckpoint = () => {\n    const newFinalityCheckpoint = Math.min(\n      ...Object.values(this.networkCheckpoints).map((n) => n.finalityCheckpoint)\n    );\n\n    if (newFinalityCheckpoint > this.finalityCheckpoint) {\n      this.finalityCheckpoint = newFinalityCheckpoint;\n      this.emit(\"newFinalityCheckpoint\", {\n        timestamp: this.finalityCheckpoint,\n      });\n    }\n  };\n}\n","import {\n  CompiledQuery,\n  Kysely,\n  Migrator,\n  NO_MIGRATIONS,\n  PostgresDialect,\n  sql,\n} from \"kysely\";\nimport type { Pool } from \"pg\";\nimport type { Address, Hex, RpcBlock, RpcLog, RpcTransaction } from \"viem\";\n\nimport type { Block } from \"@/types/block\";\nimport type { Log } from \"@/types/log\";\nimport type { Transaction } from \"@/types/transaction\";\nimport type { NonNull } from \"@/types/utils\";\nimport { blobToBigInt } from \"@/utils/decode\";\nimport { intToBlob } from \"@/utils/encode\";\nimport { mergeIntervals } from \"@/utils/intervals\";\n\nimport type { EventStore } from \"../store\";\nimport {\n  type EventStoreTables,\n  type InsertableBlock,\n  type InsertableLog,\n  type InsertableTransaction,\n  rpcToPostgresBlock,\n  rpcToPostgresLog,\n  rpcToPostgresTransaction,\n} from \"./format\";\nimport { migrationProvider } from \"./migrations\";\n\nexport class PostgresEventStore implements EventStore {\n  db: Kysely<EventStoreTables>;\n  migrator: Migrator;\n\n  constructor({\n    pool,\n    databaseSchema,\n  }: {\n    pool: Pool;\n    databaseSchema?: string;\n  }) {\n    this.db = new Kysely<EventStoreTables>({\n      dialect: new PostgresDialect({\n        pool,\n        onCreateConnection: databaseSchema\n          ? async (connection) => {\n              await connection.executeQuery(\n                CompiledQuery.raw(\n                  `CREATE SCHEMA IF NOT EXISTS ${databaseSchema}`\n                )\n              );\n              await connection.executeQuery(\n                CompiledQuery.raw(`SET search_path = ${databaseSchema}`)\n              );\n            }\n          : undefined,\n      }),\n    });\n\n    this.migrator = new Migrator({\n      db: this.db,\n      provider: migrationProvider,\n      migrationTableSchema: databaseSchema ?? \"public\",\n    });\n  }\n\n  migrateUp = async () => {\n    const { error } = await this.migrator.migrateToLatest();\n    if (error) throw error;\n  };\n\n  migrateDown = async () => {\n    const { error } = await this.migrator.migrateTo(NO_MIGRATIONS);\n    if (error) throw error;\n  };\n\n  insertUnfinalizedBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logs: RpcLog[];\n  }) => {\n    const block: InsertableBlock = {\n      ...rpcToPostgresBlock(rpcBlock),\n      chainId,\n      finalized: 0,\n    };\n\n    const transactions: InsertableTransaction[] = rpcTransactions.map(\n      (transaction) => ({\n        ...rpcToPostgresTransaction(transaction),\n        chainId,\n        finalized: 0,\n      })\n    );\n\n    const logs: InsertableLog[] = rpcLogs.map((log) => ({\n      ...rpcToPostgresLog({ log }),\n      chainId,\n      finalized: 0,\n    }));\n\n    await this.db.transaction().execute(async (tx) => {\n      await tx\n        .insertInto(\"blocks\")\n        .values(block)\n        .onConflict((oc) => oc.column(\"hash\").doNothing())\n        .execute();\n      if (transactions.length > 0) {\n        await tx\n          .insertInto(\"transactions\")\n          .values(transactions)\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n      if (logs.length > 0) {\n        await tx\n          .insertInto(\"logs\")\n          .values(logs)\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      }\n    });\n  };\n\n  deleteUnfinalizedData = async ({\n    chainId,\n    fromBlockNumber,\n  }: {\n    chainId: number;\n    fromBlockNumber: number;\n  }) => {\n    await this.db.transaction().execute(async (tx) => {\n      await tx\n        .deleteFrom(\"blocks\")\n        .where(\"number\", \">=\", intToBlob(fromBlockNumber))\n        .where(\"finalized\", \"=\", 0)\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .deleteFrom(\"transactions\")\n        .where(\"blockNumber\", \">=\", intToBlob(fromBlockNumber))\n        .where(\"finalized\", \"=\", 0)\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .deleteFrom(\"logs\")\n        .where(\"blockNumber\", \">=\", intToBlob(fromBlockNumber))\n        .where(\"finalized\", \"=\", 0)\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .deleteFrom(\"contractReadResults\")\n        .where(\"blockNumber\", \">=\", intToBlob(fromBlockNumber))\n        .where(\"finalized\", \"=\", 0)\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n    });\n  };\n\n  finalizeData = async ({\n    chainId,\n    toBlockNumber,\n  }: {\n    chainId: number;\n    toBlockNumber: number;\n  }) => {\n    await this.db.transaction().execute(async (tx) => {\n      await tx\n        .updateTable(\"blocks\")\n        .set({ finalized: 1 })\n        .where(\"number\", \"<=\", intToBlob(toBlockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .updateTable(\"transactions\")\n        .set({ finalized: 1 })\n        .where(\"blockNumber\", \"<=\", intToBlob(toBlockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .updateTable(\"logs\")\n        .set({ finalized: 1 })\n        .where(\"blockNumber\", \"<=\", intToBlob(toBlockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .updateTable(\"contractReadResults\")\n        .set({ finalized: 1 })\n        .where(\"blockNumber\", \"<=\", intToBlob(toBlockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n    });\n  };\n\n  insertFinalizedLogs = async ({\n    chainId,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    logs: RpcLog[];\n  }) => {\n    const logBatches = rpcLogs.reduce<InsertableLog[][]>((acc, log, index) => {\n      const batchIndex = Math.floor(index / 1000);\n      acc[batchIndex] = acc[batchIndex] ?? [];\n      acc[batchIndex].push({\n        ...rpcToPostgresLog({ log }),\n        chainId,\n        finalized: 1,\n      });\n      return acc;\n    }, []);\n\n    await Promise.all(\n      logBatches.map(async (batch) => {\n        await this.db\n          .insertInto(\"logs\")\n          .values(batch)\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute();\n      })\n    );\n  };\n\n  insertFinalizedBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logFilterRange: { logFilterKey, blockNumberToCacheFrom },\n  }: {\n    chainId: number;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logFilterRange: {\n      logFilterKey: string;\n      blockNumberToCacheFrom: number;\n    };\n  }) => {\n    const block: InsertableBlock = {\n      ...rpcToPostgresBlock(rpcBlock),\n      chainId,\n      finalized: 1,\n    };\n\n    const transactions: InsertableTransaction[] = rpcTransactions.map(\n      (transaction) => ({\n        ...rpcToPostgresTransaction(transaction),\n        chainId,\n        finalized: 1,\n      })\n    );\n\n    const logFilterCachedRange = {\n      filterKey: logFilterKey,\n      startBlock: intToBlob(blockNumberToCacheFrom),\n      endBlock: block.number,\n      endBlockTimestamp: block.timestamp,\n    };\n\n    await this.db.transaction().execute(async (tx) => {\n      await tx\n        .insertInto(\"blocks\")\n        .values(block)\n        .onConflict((oc) => oc.column(\"hash\").doNothing())\n        .execute();\n      if (transactions.length > 0) {\n        await tx\n          .insertInto(\"transactions\")\n          .values(transactions)\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute();\n      }\n      await tx\n        .insertInto(\"logFilterCachedRanges\")\n        .values(logFilterCachedRange)\n        .execute();\n    });\n  };\n\n  mergeLogFilterCachedRanges = async ({\n    logFilterKey,\n    logFilterStartBlockNumber,\n  }: {\n    logFilterKey: string;\n    logFilterStartBlockNumber: number;\n  }) => {\n    const startingRangeEndTimestamp = await this.db\n      .transaction()\n      .execute(async (tx) => {\n        const existingRanges = await tx\n          .deleteFrom(\"logFilterCachedRanges\")\n          .where(\"filterKey\", \"=\", logFilterKey)\n          .returningAll()\n          .execute();\n\n        const mergedIntervals = mergeIntervals(\n          existingRanges.map((r) => [\n            Number(blobToBigInt(r.startBlock)),\n            Number(blobToBigInt(r.endBlock)),\n          ])\n        );\n\n        const mergedRanges = mergedIntervals.map((interval) => {\n          const [startBlock, endBlock] = interval;\n          // For each new merged range, its endBlock will be found EITHER in the newly\n          // added range OR among the endBlocks of the removed ranges.\n          // Find it so we can propogate the endBlockTimestamp correctly.\n          const endBlockTimestamp = existingRanges.find(\n            (r) => Number(blobToBigInt(r.endBlock)) === endBlock\n          )!.endBlockTimestamp;\n\n          return {\n            filterKey: logFilterKey,\n            startBlock: intToBlob(startBlock),\n            endBlock: intToBlob(endBlock),\n            endBlockTimestamp: endBlockTimestamp,\n          };\n        });\n\n        if (mergedRanges.length > 0) {\n          await tx\n            .insertInto(\"logFilterCachedRanges\")\n            .values(mergedRanges)\n            .execute();\n        }\n\n        // After we've inserted the new ranges, find the range that contains the log filter start block number.\n        // We need this to determine the new latest available event timestamp for the log filter.\n        const startingRange = mergedRanges.find(\n          (range) =>\n            Number(blobToBigInt(range.startBlock)) <=\n              logFilterStartBlockNumber &&\n            Number(blobToBigInt(range.endBlock)) >= logFilterStartBlockNumber\n        );\n\n        if (!startingRange) {\n          // If there is no range containing the log filter start block number, return 0. This could happen if\n          // many block tasks run concurrently and the one containing the log filter start block number is late.\n          return 0;\n        } else {\n          return Number(blobToBigInt(startingRange.endBlockTimestamp));\n        }\n      });\n\n    return { startingRangeEndTimestamp };\n  };\n\n  getLogFilterCachedRanges = async ({ filterKey }: { filterKey: string }) => {\n    const results = await this.db\n      .selectFrom(\"logFilterCachedRanges\")\n      .select([\"filterKey\", \"startBlock\", \"endBlock\", \"endBlockTimestamp\"])\n      .where(\"filterKey\", \"=\", filterKey)\n      .execute();\n\n    return results.map((range) => ({\n      ...range,\n      startBlock: blobToBigInt(range.startBlock),\n      endBlock: blobToBigInt(range.endBlock),\n      endBlockTimestamp: blobToBigInt(range.endBlockTimestamp),\n    }));\n  };\n\n  insertContractReadResult = async ({\n    address,\n    blockNumber,\n    chainId,\n    data,\n    finalized,\n    result,\n  }: {\n    address: string;\n    blockNumber: bigint;\n    chainId: number;\n    data: Hex;\n    finalized: boolean;\n    result: Hex;\n  }) => {\n    await this.db\n      .insertInto(\"contractReadResults\")\n      .values({\n        address,\n        blockNumber: intToBlob(blockNumber),\n        chainId,\n        data,\n        finalized: finalized ? 1 : 0,\n        result,\n      })\n      .onConflict((oc) =>\n        oc.constraint(\"contractReadResultPrimaryKey\").doUpdateSet({ result })\n      )\n      .execute();\n  };\n\n  getContractReadResult = async ({\n    address,\n    blockNumber,\n    chainId,\n    data,\n  }: {\n    address: string;\n    blockNumber: bigint;\n    chainId: number;\n    data: Hex;\n  }) => {\n    const contractReadResult = await this.db\n      .selectFrom(\"contractReadResults\")\n      .selectAll()\n      .where(\"address\", \"=\", address)\n      .where(\"blockNumber\", \"=\", intToBlob(blockNumber))\n      .where(\"chainId\", \"=\", chainId)\n      .where(\"data\", \"=\", data)\n      .executeTakeFirst();\n\n    return contractReadResult\n      ? {\n          ...contractReadResult,\n          blockNumber: blobToBigInt(contractReadResult.blockNumber),\n          finalized: contractReadResult.finalized === 1,\n        }\n      : null;\n  };\n\n  getLogEvents = async ({\n    fromTimestamp,\n    toTimestamp,\n    filters = [],\n  }: {\n    fromTimestamp: number;\n    toTimestamp: number;\n    filters?: {\n      name: string;\n      chainId: number;\n      address?: Address | Address[];\n      topics?: (Hex | Hex[] | null)[];\n      fromBlock?: number;\n      toBlock?: number;\n      handledTopic0?: Hex[];\n    }[];\n  }) => {\n    const handledLogQuery = this.db\n      .with(\n        \"logFilters(logFilter_name, logFilter_chainId, logFilter_address, logFilter_topic0, logFilter_topic1, logFilter_topic2, logFilter_topic3, logFilter_fromBlock, logFilter_toBlock, logFilter_handledTopic0)\",\n        () => sql`( values ${sql.join(filters.map(buildLogFilterValues))} )`\n      )\n      .selectFrom(\"logs\")\n      .leftJoin(\"blocks\", \"blocks.hash\", \"logs.blockHash\")\n      .leftJoin(\"transactions\", \"transactions.hash\", \"logs.transactionHash\")\n      .innerJoin(\"logFilters\", (join) => join.onTrue())\n      .select([\n        \"logFilter_name\",\n\n        \"logs.address as log_address\",\n        \"logs.blockHash as log_blockHash\",\n        \"logs.blockNumber as log_blockNumber\",\n        // \"logs.chainId as log_chainId\",\n        \"logs.data as log_data\",\n        // \"logs.finalized as log_finalized\",\n        \"logs.id as log_id\",\n        \"logs.logIndex as log_logIndex\",\n        \"logs.topic0 as log_topic0\",\n        \"logs.topic1 as log_topic1\",\n        \"logs.topic2 as log_topic2\",\n        \"logs.topic3 as log_topic3\",\n        \"logs.transactionHash as log_transactionHash\",\n        \"logs.transactionIndex as log_transactionIndex\",\n\n        \"blocks.baseFeePerGas as block_baseFeePerGas\",\n        // \"blocks.chainId as block_chainId\",\n        \"blocks.difficulty as block_difficulty\",\n        \"blocks.extraData as block_extraData\",\n        // \"blocks.finalized as block_finalized\",\n        \"blocks.gasLimit as block_gasLimit\",\n        \"blocks.gasUsed as block_gasUsed\",\n        \"blocks.hash as block_hash\",\n        \"blocks.logsBloom as block_logsBloom\",\n        \"blocks.miner as block_miner\",\n        \"blocks.mixHash as block_mixHash\",\n        \"blocks.nonce as block_nonce\",\n        \"blocks.number as block_number\",\n        \"blocks.parentHash as block_parentHash\",\n        \"blocks.receiptsRoot as block_receiptsRoot\",\n        \"blocks.sha3Uncles as block_sha3Uncles\",\n        \"blocks.size as block_size\",\n        \"blocks.stateRoot as block_stateRoot\",\n        \"blocks.timestamp as block_timestamp\",\n        \"blocks.totalDifficulty as block_totalDifficulty\",\n        \"blocks.transactionsRoot as block_transactionsRoot\",\n\n        \"transactions.accessList as tx_accessList\",\n        \"transactions.blockHash as tx_blockHash\",\n        \"transactions.blockNumber as tx_blockNumber\",\n        // \"transactions.chainId as tx_chainId\",\n        // \"transactions.finalized as tx_finalized\",\n        \"transactions.from as tx_from\",\n        \"transactions.gas as tx_gas\",\n        \"transactions.gasPrice as tx_gasPrice\",\n        \"transactions.hash as tx_hash\",\n        \"transactions.input as tx_input\",\n        \"transactions.maxFeePerGas as tx_maxFeePerGas\",\n        \"transactions.maxPriorityFeePerGas as tx_maxPriorityFeePerGas\",\n        \"transactions.nonce as tx_nonce\",\n        \"transactions.r as tx_r\",\n        \"transactions.s as tx_s\",\n        \"transactions.to as tx_to\",\n        \"transactions.transactionIndex as tx_transactionIndex\",\n        \"transactions.type as tx_type\",\n        \"transactions.value as tx_value\",\n        \"transactions.v as tx_v\",\n      ])\n      .where(({ and, or, cmpr, ref }) =>\n        and([\n          cmpr(\"logs.chainId\", \"=\", ref(\"logFilter_chainId\")),\n          or([\n            cmpr(\"logFilter_address\", \"is\", null),\n            cmpr(\"logFilter_address\", \"like\", sql`'%' || logs.address || '%'`),\n          ]),\n          and([\n            or([\n              cmpr(\"logFilter_topic0\", \"is\", null),\n              cmpr(\"logFilter_topic0\", \"like\", sql`'%' || logs.topic0 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic1\", \"is\", null),\n              cmpr(\"logFilter_topic1\", \"like\", sql`'%' || logs.topic1 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic2\", \"is\", null),\n              cmpr(\"logFilter_topic2\", \"like\", sql`'%' || logs.topic2 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic3\", \"is\", null),\n              cmpr(\"logFilter_topic3\", \"like\", sql`'%' || logs.topic3 || '%'`),\n            ]),\n          ]),\n          or([\n            cmpr(\"logFilter_fromBlock\", \"is\", null),\n            cmpr(\"blocks.number\", \">=\", ref(\"logFilter_fromBlock\")),\n          ]),\n          or([\n            cmpr(\"logFilter_toBlock\", \"is\", null),\n            cmpr(\"blocks.number\", \"<=\", ref(\"logFilter_toBlock\")),\n          ]),\n          or([\n            cmpr(\"logFilter_handledTopic0\", \"is\", null),\n            cmpr(\n              \"logFilter_handledTopic0\",\n              \"like\",\n              sql`'%' || logs.topic0 || '%'`\n            ),\n          ]),\n        ])\n      )\n      .where(\"blocks.timestamp\", \">=\", intToBlob(fromTimestamp))\n      .where(\"blocks.timestamp\", \"<=\", intToBlob(toTimestamp))\n      .orderBy(\"blocks.timestamp\", \"asc\")\n      .orderBy(\"logs.chainId\", \"asc\")\n      .orderBy(\"logs.logIndex\", \"asc\")\n      .orderBy(\"logFilter_name\", \"asc\");\n\n    // Get total count of matching logs.\n    const totalLogCountQuery = this.db\n      .with(\n        \"logFilters(logFilter_name, logFilter_chainId, logFilter_address, logFilter_topic0, logFilter_topic1, logFilter_topic2, logFilter_topic3, logFilter_fromBlock, logFilter_toBlock, logFilter_handledTopic0)\",\n        () => sql`( values ${sql.join(filters.map(buildLogFilterValues))} )`\n      )\n      .selectFrom(\"logs\")\n      .leftJoin(\"blocks\", \"blocks.hash\", \"logs.blockHash\")\n      .innerJoin(\"logFilters\", (join) => join.onTrue())\n      .select(this.db.fn.count(\"logs.id\").as(\"log_count\"))\n      .where(({ and, or, cmpr, ref }) =>\n        and([\n          cmpr(\"logs.chainId\", \"=\", ref(\"logFilter_chainId\")),\n          or([\n            cmpr(\"logFilter_address\", \"is\", null),\n            cmpr(\"logFilter_address\", \"like\", sql`'%' || logs.address || '%'`),\n          ]),\n          and([\n            or([\n              cmpr(\"logFilter_topic0\", \"is\", null),\n              cmpr(\"logFilter_topic0\", \"like\", sql`'%' || logs.topic0 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic1\", \"is\", null),\n              cmpr(\"logFilter_topic1\", \"like\", sql`'%' || logs.topic1 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic2\", \"is\", null),\n              cmpr(\"logFilter_topic2\", \"like\", sql`'%' || logs.topic2 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic3\", \"is\", null),\n              cmpr(\"logFilter_topic3\", \"like\", sql`'%' || logs.topic3 || '%'`),\n            ]),\n          ]),\n          or([\n            cmpr(\"logFilter_fromBlock\", \"is\", null),\n            cmpr(\"blocks.number\", \">=\", ref(\"logFilter_fromBlock\")),\n          ]),\n          or([\n            cmpr(\"logFilter_toBlock\", \"is\", null),\n            cmpr(\"blocks.number\", \"<=\", ref(\"logFilter_toBlock\")),\n          ]),\n        ])\n      )\n      .where(\"blocks.timestamp\", \">=\", intToBlob(fromTimestamp))\n      .where(\"blocks.timestamp\", \"<=\", intToBlob(toTimestamp));\n\n    // Get handled logs.\n    const handledLogs = await handledLogQuery.execute();\n\n    const totalLogCount = await totalLogCountQuery.execute();\n    const totalEventCount = Number(totalLogCount[0].log_count);\n\n    const events = handledLogs.map((result_) => {\n      // Without this cast, the block_ and tx_ fields are all nullable\n      // which makes this very annoying. Should probably add a runtime check\n      // that those fields are indeed present before continuing here.\n      const result = result_ as NonNull<(typeof handledLogs)[number]>;\n\n      const event: {\n        filterName: string;\n        log: Log;\n        block: Block;\n        transaction: Transaction;\n      } = {\n        filterName: result.logFilter_name,\n        log: {\n          address: result.log_address,\n          blockHash: result.log_blockHash,\n          blockNumber: blobToBigInt(result.log_blockNumber),\n          data: result.log_data,\n          id: result.log_id,\n          logIndex: Number(result.log_logIndex),\n          removed: false,\n          topics: [\n            result.log_topic0,\n            result.log_topic1,\n            result.log_topic2,\n            result.log_topic3,\n          ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n          transactionHash: result.log_transactionHash,\n          transactionIndex: Number(result.log_transactionIndex),\n        },\n        block: {\n          baseFeePerGas: result.block_baseFeePerGas\n            ? blobToBigInt(result.block_baseFeePerGas)\n            : null,\n          difficulty: blobToBigInt(result.block_difficulty),\n          extraData: result.block_extraData,\n          gasLimit: blobToBigInt(result.block_gasLimit),\n          gasUsed: blobToBigInt(result.block_gasUsed),\n          hash: result.block_hash,\n          logsBloom: result.block_logsBloom,\n          miner: result.block_miner,\n          mixHash: result.block_mixHash,\n          nonce: result.block_nonce,\n          number: blobToBigInt(result.block_number),\n          parentHash: result.block_parentHash,\n          receiptsRoot: result.block_receiptsRoot,\n          sha3Uncles: result.block_sha3Uncles,\n          size: blobToBigInt(result.block_size),\n          stateRoot: result.block_stateRoot,\n          timestamp: blobToBigInt(result.block_timestamp),\n          totalDifficulty: blobToBigInt(result.block_totalDifficulty),\n          transactionsRoot: result.block_transactionsRoot,\n        },\n        transaction: {\n          blockHash: result.tx_blockHash,\n          blockNumber: blobToBigInt(result.tx_blockNumber),\n          from: result.tx_from,\n          gas: blobToBigInt(result.tx_gas),\n          hash: result.tx_hash,\n          input: result.tx_input,\n          nonce: Number(result.tx_nonce),\n          r: result.tx_r,\n          s: result.tx_s,\n          to: result.tx_to,\n          transactionIndex: Number(result.tx_transactionIndex),\n          value: blobToBigInt(result.tx_value),\n          v: blobToBigInt(result.tx_v),\n          ...(result.tx_type === \"0x0\"\n            ? {\n                type: \"legacy\",\n                gasPrice: blobToBigInt(result.tx_gasPrice),\n              }\n            : result.tx_type === \"0x1\"\n            ? {\n                type: \"eip2930\",\n                gasPrice: blobToBigInt(result.tx_gasPrice),\n                accessList: JSON.parse(result.tx_accessList),\n              }\n            : result.tx_type === \"0x2\"\n            ? {\n                type: \"eip1559\",\n                maxFeePerGas: blobToBigInt(result.tx_maxFeePerGas),\n                maxPriorityFeePerGas: blobToBigInt(\n                  result.tx_maxPriorityFeePerGas\n                ),\n              }\n            : result.tx_type === \"0x7e\"\n            ? {\n                type: \"deposit\",\n                maxFeePerGas: blobToBigInt(result.tx_maxFeePerGas),\n                maxPriorityFeePerGas: blobToBigInt(\n                  result.tx_maxPriorityFeePerGas\n                ),\n              }\n            : {\n                type: result.tx_type,\n              }),\n        },\n      };\n\n      return event;\n    });\n\n    return {\n      events,\n      totalEventCount,\n    };\n  };\n}\n\nfunction getLogFilterAddressOrTopic(value: Hex | Hex[] | undefined | null) {\n  if (value === undefined || value === null) return null;\n  if (typeof value === \"string\") return value;\n  return value.join(\",\");\n}\n\nfunction getLogFilterTopics(topics: (Hex | Hex[] | null)[] | undefined) {\n  if (!topics) return [null, null, null, null];\n  const topic0 = getLogFilterAddressOrTopic(topics[0]);\n  const topic1 = getLogFilterAddressOrTopic(topics[1]);\n  const topic2 = getLogFilterAddressOrTopic(topics[2]);\n  const topic3 = getLogFilterAddressOrTopic(topics[3]);\n  return [topic0, topic1, topic2, topic3];\n}\n\nexport function buildLogFilterValues(filter: {\n  name: string;\n  chainId: number;\n  address?: Address | Address[];\n  topics?: (Hex | Hex[] | null)[];\n  fromBlock?: number;\n  toBlock?: number;\n  handledTopic0?: Hex[];\n}) {\n  const { name, chainId, address, topics, fromBlock, toBlock, handledTopic0 } =\n    filter;\n\n  const address_ = getLogFilterAddressOrTopic(address);\n  const [topic0, topic1, topic2, topic3] = getLogFilterTopics(topics);\n  const handledTopic0_ = getLogFilterAddressOrTopic(handledTopic0);\n\n  return sql`(${sql.join([\n    sql.val(name),\n    sql`${sql.val(chainId)}::integer`,\n    sql.val(address_),\n    sql.val(topic0),\n    sql.val(topic1),\n    sql.val(topic2),\n    sql.val(topic3),\n    sql`${sql.val(fromBlock ? intToBlob(fromBlock) : null)}::bytea`,\n    sql`${sql.val(toBlock ? intToBlob(toBlock) : null)}::bytea`,\n    sql.val(handledTopic0_),\n  ])})`;\n}\n","const EVM_MAX_UINT =\n  115792089237316195423570985008687907853269984665640564039457584007913129639935n;\n\n/**\n * Converts an encoded 33-byte Buffer (sign byte followed by 32-byte value) into a BigInt.\n * Used as the storage encoding for EVM uint256 and int256 types to enable ordering\n * using SQLite's default BLOB collation (memcmp).\n *\n * @param value Integer to be encoded.\n * @returns 33-byte Buffer representing the encoded integer.\n */\nexport function blobToBigInt(buffer: Buffer) {\n  const signByte = buffer.at(0);\n  const hexString = buffer.subarray(1).toString(\"hex\").replace(/^0+/, \"\");\n  if (hexString.length === 0) return 0n;\n\n  let value = BigInt(\"0x\" + hexString);\n\n  // If the sign byte is negative, invert the value\n  if (signByte === 0) {\n    value = value - EVM_MAX_UINT;\n  }\n\n  return value;\n}\n","import type { Hex } from \"viem\";\n\nconst EVM_MAX_UINT =\n  115792089237316195423570985008687907853269984665640564039457584007913129639935n;\n/**\n * Converts a integer into a 33-byte Buffer (sign byte followed by 32-byte value).\n * Used as the storage encoding for EVM uint256 and int256 types to enable ordering\n * using SQLite's default BLOB collation (memcmp).\n *\n * @param value Integer to be encoded.\n * @returns 33-byte Buffer representing the encoded integer.\n */\nexport function intToBlob(value: bigint | number | Hex) {\n  if (typeof value === \"string\" || typeof value === \"number\")\n    value = BigInt(value);\n\n  // If the value is negative, invert it.\n  const signByte = value >= 0n ? \"ff\" : \"00\";\n  if (value < 0n) value = EVM_MAX_UINT + value;\n\n  let hexString = value.toString(16);\n  if (hexString.length > 64) {\n    throw new Error(\n      `Value exceeds the EVM_MAX_UINT size (32 byte unsigned integer): ${value}`\n    );\n  }\n\n  // Pad the hex string with leading zeros and add the sign byte.\n  hexString = signByte + hexString.padStart(64, \"0\");\n\n  // Return a Buffer from the padded hex string.\n  return Buffer.from(hexString, \"hex\");\n}\n","/* This function merges intervals (inclusive on both ends).\n * I modified the SO impl to handle [inclusive, inclusive] intervals.\n * From: https://stackoverflow.com/a/26391774/12841788\n */\nexport function mergeIntervals(intervals: number[][]) {\n  intervals.sort((a, b) => a[0] - b[0]);\n  const result: number[][] = [];\n  let last: number[];\n  intervals.forEach((interval) => {\n    if (interval[1] < interval[0])\n      throw new Error(`Cannot merge invalid interval: ${interval}`);\n    interval = [interval[0], interval[1] + 1];\n    if (!last || interval[0] > last[1]) {\n      result.push((last = interval));\n    } else if (interval[1] > last[1]) {\n      last[1] = interval[1];\n    }\n  });\n  return result.map((r) => [r[0], r[1] - 1]);\n}\n","import { Generated, Insertable, Selectable } from \"kysely\";\nimport {\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  hexToNumber,\n} from \"viem\";\nimport { Address, Hash, Hex } from \"viem\";\n\nimport { intToBlob } from \"@/utils/encode\";\n\ntype BlocksTable = {\n  baseFeePerGas: Buffer | null; // BigInt\n  difficulty: Buffer; // BigInt\n  extraData: Hex;\n  gasLimit: Buffer; // BigInt\n  gasUsed: Buffer; // BigInt\n  hash: Hash;\n  logsBloom: Hex;\n  miner: Address;\n  mixHash: Hash;\n  nonce: Hex;\n  number: Buffer; // BigInt\n  parentHash: Hash;\n  receiptsRoot: Hex;\n  sha3Uncles: Hash;\n  size: Buffer; // BigInt\n  stateRoot: Hash;\n  timestamp: Buffer; // BigInt\n  totalDifficulty: Buffer; // BigInt\n  transactionsRoot: Hash;\n\n  chainId: number;\n  finalized: number;\n};\n\nexport type InsertableBlock = Insertable<BlocksTable>;\n\nexport function rpcToPostgresBlock(\n  block: RpcBlock\n): Omit<InsertableBlock, \"chainId\" | \"finalized\"> {\n  return {\n    baseFeePerGas: block.baseFeePerGas ? intToBlob(block.baseFeePerGas) : null,\n    difficulty: intToBlob(block.difficulty),\n    extraData: block.extraData,\n    gasLimit: intToBlob(block.gasLimit),\n    gasUsed: intToBlob(block.gasUsed),\n    hash: block.hash!,\n    logsBloom: block.logsBloom!,\n    miner: block.miner,\n    mixHash: block.mixHash,\n    nonce: block.nonce!,\n    number: intToBlob(block.number!),\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sha3Uncles: block.sha3Uncles,\n    size: intToBlob(block.size),\n    stateRoot: block.stateRoot,\n    timestamp: intToBlob(block.timestamp),\n    totalDifficulty: intToBlob(block.totalDifficulty!),\n    transactionsRoot: block.transactionsRoot,\n  };\n}\n\ntype TransactionsTable = {\n  blockHash: Hash;\n  blockNumber: Buffer; // BigInt\n  from: Address;\n  gas: Buffer; // BigInt\n  hash: Hash;\n  input: Hex;\n  nonce: number;\n  r: Hex;\n  s: Hex;\n  to: Address | null;\n  transactionIndex: number;\n  v: Buffer; // BigInt\n  value: Buffer; // BigInt\n\n  type: Hex;\n  gasPrice: Buffer | null; // BigInt\n  maxFeePerGas: Buffer | null; // BigInt\n  maxPriorityFeePerGas: Buffer | null; // BigInt\n  accessList: string | null;\n\n  chainId: number;\n  finalized: number;\n};\n\nexport type InsertableTransaction = Insertable<TransactionsTable>;\n\nexport function rpcToPostgresTransaction(\n  transaction: RpcTransaction\n): Omit<InsertableTransaction, \"chainId\" | \"finalized\"> {\n  return {\n    accessList: transaction.accessList\n      ? JSON.stringify(transaction.accessList)\n      : undefined,\n    blockHash: transaction.blockHash!,\n    blockNumber: intToBlob(transaction.blockNumber!),\n    from: transaction.from,\n    gas: intToBlob(transaction.gas),\n    gasPrice: transaction.gasPrice ? intToBlob(transaction.gasPrice) : null,\n    hash: transaction.hash,\n    input: transaction.input,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? intToBlob(transaction.maxFeePerGas)\n      : null,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? intToBlob(transaction.maxPriorityFeePerGas)\n      : null,\n    nonce: hexToNumber(transaction.nonce),\n    r: transaction.r,\n    s: transaction.s,\n    to: transaction.to ? transaction.to : null,\n    transactionIndex: Number(transaction.transactionIndex),\n    type: transaction.type ?? \"0x0\",\n    value: intToBlob(transaction.value),\n    v: intToBlob(transaction.v),\n  };\n}\n\ntype LogsTable = {\n  id: string;\n  address: Address;\n  blockHash: Hash;\n  blockNumber: Buffer; // BigInt\n  data: Hex;\n  logIndex: number;\n  transactionHash: Hash;\n  transactionIndex: number;\n\n  topic0: string | null;\n  topic1: string | null;\n  topic2: string | null;\n  topic3: string | null;\n\n  chainId: number;\n  finalized: number;\n};\n\nexport type InsertableLog = Insertable<LogsTable>;\n\nexport function rpcToPostgresLog({\n  log,\n}: {\n  log: RpcLog;\n}): Omit<InsertableLog, \"chainId\" | \"finalized\"> {\n  return {\n    address: log.address,\n    blockHash: log.blockHash!,\n    blockNumber: intToBlob(log.blockNumber!),\n    data: log.data,\n    id: `${log.blockHash}-${log.logIndex}`,\n    logIndex: Number(log.logIndex!),\n    topic0: log.topics[0] ? log.topics[0] : null,\n    topic1: log.topics[1] ? log.topics[1] : null,\n    topic2: log.topics[2] ? log.topics[2] : null,\n    topic3: log.topics[3] ? log.topics[3] : null,\n    transactionHash: log.transactionHash!,\n    transactionIndex: Number(log.transactionIndex!),\n  };\n}\n\ntype ContractReadResultsTable = {\n  address: string;\n  blockNumber: Buffer; // BigInt\n  chainId: number;\n  data: Hex;\n  finalized: number; // Boolean (0 or 1).\n  result: Hex;\n};\n\ntype LogFilterCachedRangesTable = {\n  id: Generated<number>;\n  filterKey: string;\n  startBlock: Buffer; // BigInt\n  endBlock: Buffer; // BigInt\n  endBlockTimestamp: Buffer; // BigInt\n};\n\nexport type LogFilterCachedRange = Omit<\n  Selectable<LogFilterCachedRangesTable>,\n  \"id\"\n>;\n\nexport type EventStoreTables = {\n  blocks: BlocksTable;\n  transactions: TransactionsTable;\n  logs: LogsTable;\n  contractReadResults: ContractReadResultsTable;\n  logFilterCachedRanges: LogFilterCachedRangesTable;\n};\n","import { Kysely, Migration, MigrationProvider, sql } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  [\"2023_05_15_0_initial\"]: {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"gasLimit\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasUsed\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"text\", (col) => col.notNull())\n        .addColumn(\"miner\", \"text\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"text\", (col) => col.notNull())\n        .addColumn(\"number\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"parentHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"text\", (col) => col.notNull())\n        .addColumn(\"size\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"stateRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"timestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"totalDifficulty\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"transactionsRoot\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"from\", \"text\", (col) => col.notNull())\n        .addColumn(\"gas\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"gasPrice\", sql`bytea`) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"maxPriorityFeePerGas\", sql`bytea`) // BigInt\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"text\", (col) => col.notNull())\n        .addColumn(\"s\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"text\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"v\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"text\")\n        .addColumn(\"topic1\", \"text\")\n        .addColumn(\"topic2\", \"text\")\n        .addColumn(\"topic3\", \"text\")\n        .addColumn(\"transactionHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilterCachedRanges\")\n        .addColumn(\"endBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"endBlockTimestamp\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .addColumn(\"filterKey\", \"text\", (col) => col.notNull())\n        // The `id` column should not be included in INSERT statements.\n        // This column uses Postgres SERIAL type which autoincrements.\n        .addColumn(\"id\", \"serial\", (col) => col.notNull().primaryKey())\n        .addColumn(\"startBlock\", sql`bytea`, (col) => col.notNull()) // BigInt\n        .execute();\n    },\n    async down(db: Kysely<any>) {\n      await db.schema.dropTable(\"blocks\").execute();\n      await db.schema.dropTable(\"logs\").execute();\n      await db.schema.dropTable(\"transactions\").execute();\n      await db.schema.dropTable(\"contractReadResults\").execute();\n      await db.schema.dropTable(\"logFilterCachedRanges\").execute();\n    },\n  },\n  [\"2023_06_20_0_indices\"]: {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_events_index\")\n        .on(\"logs\")\n        .columns([\"address\", \"chainId\", \"blockHash\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"blocks_index\")\n        .on(\"blocks\")\n        .columns([\"timestamp\", \"number\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"logFilterCachedRanges_index\")\n        .on(\"logFilterCachedRanges\")\n        .columns([\"filterKey\"])\n        .execute();\n    },\n\n    async down(db: Kysely<any>) {\n      await db.schema.dropIndex(\"log_events_index\").execute();\n      await db.schema.dropIndex(\"logFilterCachedRanges_index\").execute();\n      await db.schema.dropIndex(\"blocks_index\").execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n","import type Sqlite from \"better-sqlite3\";\nimport { Kysely, Migrator, NO_MIGRATIONS, sql, SqliteDialect } from \"kysely\";\nimport type { Address, Hex, RpcBlock, RpcLog, RpcTransaction } from \"viem\";\n\nimport type { Block } from \"@/types/block\";\nimport type { Log } from \"@/types/log\";\nimport type { Transaction } from \"@/types/transaction\";\nimport type { NonNull } from \"@/types/utils\";\nimport { blobToBigInt } from \"@/utils/decode\";\nimport { intToBlob } from \"@/utils/encode\";\nimport { mergeIntervals } from \"@/utils/intervals\";\n\nimport type { EventStore } from \"../store\";\nimport {\n  type EventStoreTables,\n  type InsertableBlock,\n  type InsertableLog,\n  type InsertableTransaction,\n  rpcToSqliteBlock,\n  rpcToSqliteLog,\n  rpcToSqliteTransaction,\n} from \"./format\";\nimport { migrationProvider } from \"./migrations\";\n\nexport class SqliteEventStore implements EventStore {\n  db: Kysely<EventStoreTables>;\n  migrator: Migrator;\n\n  constructor({ db }: { db: Sqlite.Database }) {\n    this.db = new Kysely<EventStoreTables>({\n      dialect: new SqliteDialect({ database: db }),\n    });\n\n    this.migrator = new Migrator({\n      db: this.db,\n      provider: migrationProvider,\n    });\n  }\n\n  migrateUp = async () => {\n    const { error } = await this.migrator.migrateToLatest();\n    if (error) throw error;\n  };\n\n  migrateDown = async () => {\n    const { error } = await this.migrator.migrateTo(NO_MIGRATIONS);\n    if (error) throw error;\n  };\n\n  insertUnfinalizedBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logs: RpcLog[];\n  }) => {\n    const block: InsertableBlock = {\n      ...rpcToSqliteBlock(rpcBlock),\n      chainId,\n      finalized: 0,\n    };\n\n    const transactions: InsertableTransaction[] = rpcTransactions.map(\n      (transaction) => ({\n        ...rpcToSqliteTransaction(transaction),\n        chainId,\n        finalized: 0,\n      })\n    );\n\n    const logs: InsertableLog[] = rpcLogs.map((log) => ({\n      ...rpcToSqliteLog({ log }),\n      chainId,\n      finalized: 0,\n    }));\n\n    await this.db.transaction().execute(async (tx) => {\n      await Promise.all([\n        tx\n          .insertInto(\"blocks\")\n          .values(block)\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute(),\n        ...transactions.map((transaction) =>\n          tx\n            .insertInto(\"transactions\")\n            .values(transaction)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute()\n        ),\n        ...logs.map((log) =>\n          tx\n            .insertInto(\"logs\")\n            .values(log)\n            .onConflict((oc) => oc.column(\"id\").doNothing())\n            .execute()\n        ),\n      ]);\n    });\n  };\n\n  deleteUnfinalizedData = async ({\n    chainId,\n    fromBlockNumber,\n  }: {\n    chainId: number;\n    fromBlockNumber: number;\n  }) => {\n    await this.db.transaction().execute(async (tx) => {\n      await tx\n        .deleteFrom(\"blocks\")\n        .where(\"number\", \">=\", intToBlob(fromBlockNumber))\n        .where(\"finalized\", \"=\", 0)\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .deleteFrom(\"transactions\")\n        .where(\"blockNumber\", \">=\", intToBlob(fromBlockNumber))\n        .where(\"finalized\", \"=\", 0)\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .deleteFrom(\"logs\")\n        .where(\"blockNumber\", \">=\", intToBlob(fromBlockNumber))\n        .where(\"finalized\", \"=\", 0)\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .deleteFrom(\"contractReadResults\")\n        .where(\"blockNumber\", \">=\", intToBlob(fromBlockNumber))\n        .where(\"finalized\", \"=\", 0)\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n    });\n  };\n\n  finalizeData = async ({\n    chainId,\n    toBlockNumber,\n  }: {\n    chainId: number;\n    toBlockNumber: number;\n  }) => {\n    await this.db.transaction().execute(async (tx) => {\n      await tx\n        .updateTable(\"blocks\")\n        .set({ finalized: 1 })\n        .where(\"number\", \"<=\", intToBlob(toBlockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .updateTable(\"transactions\")\n        .set({ finalized: 1 })\n        .where(\"blockNumber\", \"<=\", intToBlob(toBlockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .updateTable(\"logs\")\n        .set({ finalized: 1 })\n        .where(\"blockNumber\", \"<=\", intToBlob(toBlockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n      await tx\n        .updateTable(\"contractReadResults\")\n        .set({ finalized: 1 })\n        .where(\"blockNumber\", \"<=\", intToBlob(toBlockNumber))\n        .where(\"chainId\", \"=\", chainId)\n        .execute();\n    });\n  };\n\n  insertFinalizedLogs = async ({\n    chainId,\n    logs: rpcLogs,\n  }: {\n    chainId: number;\n    logs: RpcLog[];\n  }) => {\n    const logs: InsertableLog[] = rpcLogs.map((log) => ({\n      ...rpcToSqliteLog({ log }),\n      chainId,\n      finalized: 1,\n    }));\n\n    await Promise.all(\n      logs.map((log) =>\n        this.db\n          .insertInto(\"logs\")\n          .values(log)\n          .onConflict((oc) => oc.column(\"id\").doNothing())\n          .execute()\n      )\n    );\n  };\n\n  insertFinalizedBlock = async ({\n    chainId,\n    block: rpcBlock,\n    transactions: rpcTransactions,\n    logFilterRange: { logFilterKey, blockNumberToCacheFrom },\n  }: {\n    chainId: number;\n    block: RpcBlock;\n    transactions: RpcTransaction[];\n    logFilterRange: { logFilterKey: string; blockNumberToCacheFrom: number };\n  }) => {\n    const block: InsertableBlock = {\n      ...rpcToSqliteBlock(rpcBlock),\n      chainId,\n      finalized: 1,\n    };\n\n    const transactions: InsertableTransaction[] = rpcTransactions.map(\n      (transaction) => ({\n        ...rpcToSqliteTransaction(transaction),\n        chainId,\n        finalized: 1,\n      })\n    );\n\n    const logFilterCachedRange = {\n      filterKey: logFilterKey,\n      startBlock: intToBlob(blockNumberToCacheFrom),\n      endBlock: block.number,\n      endBlockTimestamp: block.timestamp,\n    };\n\n    await this.db.transaction().execute(async (tx) => {\n      await Promise.all([\n        tx\n          .insertInto(\"blocks\")\n          .values(block)\n          .onConflict((oc) => oc.column(\"hash\").doNothing())\n          .execute(),\n        ...transactions.map((transaction) =>\n          tx\n            .insertInto(\"transactions\")\n            .values(transaction)\n            .onConflict((oc) => oc.column(\"hash\").doNothing())\n            .execute()\n        ),\n        tx\n          .insertInto(\"logFilterCachedRanges\")\n          .values(logFilterCachedRange)\n          .execute(),\n      ]);\n    });\n  };\n\n  mergeLogFilterCachedRanges = async ({\n    logFilterKey,\n    logFilterStartBlockNumber,\n  }: {\n    logFilterKey: string;\n    logFilterStartBlockNumber: number;\n  }) => {\n    const startingRangeEndTimestamp = await this.db\n      .transaction()\n      .execute(async (tx) => {\n        const existingRanges = await tx\n          .deleteFrom(\"logFilterCachedRanges\")\n          .where(\"filterKey\", \"=\", logFilterKey)\n          .returningAll()\n          .execute();\n\n        const mergedIntervals = mergeIntervals(\n          existingRanges.map((r) => [\n            Number(blobToBigInt(r.startBlock)),\n            Number(blobToBigInt(r.endBlock)),\n          ])\n        );\n\n        const mergedRanges = mergedIntervals.map((interval) => {\n          const [startBlock, endBlock] = interval;\n          // For each new merged range, its endBlock will be found EITHER in the newly\n          // added range OR among the endBlocks of the removed ranges.\n          // Find it so we can propogate the endBlockTimestamp correctly.\n          const endBlockTimestamp = existingRanges.find(\n            (r) => Number(blobToBigInt(r.endBlock)) === endBlock\n          )!.endBlockTimestamp;\n\n          return {\n            filterKey: logFilterKey,\n            startBlock: intToBlob(startBlock),\n            endBlock: intToBlob(endBlock),\n            endBlockTimestamp: endBlockTimestamp,\n          };\n        });\n\n        await Promise.all(\n          mergedRanges.map((range) =>\n            tx.insertInto(\"logFilterCachedRanges\").values(range).execute()\n          )\n        );\n\n        // After we've inserted the new ranges, find the range that contains the log filter start block number.\n        // We need this to determine the new latest available event timestamp for the log filter.\n        const startingRange = mergedRanges.find(\n          (range) =>\n            Number(blobToBigInt(range.startBlock)) <=\n              logFilterStartBlockNumber &&\n            Number(blobToBigInt(range.endBlock)) >= logFilterStartBlockNumber\n        );\n\n        if (!startingRange) {\n          // If there is no range containing the log filter start block number, return 0. This could happen if\n          // many block tasks run concurrently and the one containing the log filter start block number is late.\n          return 0;\n        } else {\n          return Number(blobToBigInt(startingRange.endBlockTimestamp));\n        }\n      });\n\n    return { startingRangeEndTimestamp };\n  };\n\n  getLogFilterCachedRanges = async ({ filterKey }: { filterKey: string }) => {\n    const results = await this.db\n      .selectFrom(\"logFilterCachedRanges\")\n      .select([\"filterKey\", \"startBlock\", \"endBlock\", \"endBlockTimestamp\"])\n      .where(\"filterKey\", \"=\", filterKey)\n      .execute();\n\n    return results.map((range) => ({\n      ...range,\n      startBlock: blobToBigInt(range.startBlock),\n      endBlock: blobToBigInt(range.endBlock),\n      endBlockTimestamp: blobToBigInt(range.endBlockTimestamp),\n    }));\n  };\n\n  insertContractReadResult = async ({\n    address,\n    blockNumber,\n    chainId,\n    data,\n    finalized,\n    result,\n  }: {\n    address: string;\n    blockNumber: bigint;\n    chainId: number;\n    data: Hex;\n    finalized: boolean;\n    result: Hex;\n  }) => {\n    await this.db\n      .insertInto(\"contractReadResults\")\n      .values({\n        address,\n        blockNumber: intToBlob(blockNumber),\n        chainId,\n        data,\n        finalized: finalized ? 1 : 0,\n        result,\n      })\n      .onConflict((oc) => oc.doUpdateSet({ result }))\n      .execute();\n  };\n\n  getContractReadResult = async ({\n    address,\n    blockNumber,\n    chainId,\n    data,\n  }: {\n    address: string;\n    blockNumber: bigint;\n    chainId: number;\n    data: Hex;\n  }) => {\n    const contractReadResult = await this.db\n      .selectFrom(\"contractReadResults\")\n      .selectAll()\n      .where(\"address\", \"=\", address)\n      .where(\"blockNumber\", \"=\", intToBlob(blockNumber))\n      .where(\"chainId\", \"=\", chainId)\n      .where(\"data\", \"=\", data)\n      .executeTakeFirst();\n\n    return contractReadResult\n      ? {\n          ...contractReadResult,\n          blockNumber: blobToBigInt(contractReadResult.blockNumber),\n          finalized: contractReadResult.finalized === 1,\n        }\n      : null;\n  };\n\n  getLogEvents = async ({\n    fromTimestamp,\n    toTimestamp,\n    filters = [],\n  }: {\n    fromTimestamp: number;\n    toTimestamp: number;\n    filters?: {\n      name: string;\n      chainId: number;\n      address?: Address | Address[];\n      topics?: (Hex | Hex[] | null)[];\n      fromBlock?: number;\n      toBlock?: number;\n      handledTopic0?: Hex[];\n    }[];\n  }) => {\n    const handledLogQuery = this.db\n      .with(\n        \"logFilters(logFilter_name, logFilter_chainId, logFilter_address, logFilter_topic0, logFilter_topic1, logFilter_topic2, logFilter_topic3, logFilter_fromBlock, logFilter_toBlock, logFilter_handledTopic0)\",\n        () => sql`( values ${sql.join(filters.map(buildLogFilterValues))} )`\n      )\n      .selectFrom(\"logs\")\n      .leftJoin(\"blocks\", \"blocks.hash\", \"logs.blockHash\")\n      .leftJoin(\"transactions\", \"transactions.hash\", \"logs.transactionHash\")\n      .innerJoin(\"logFilters\", (join) => join.onTrue())\n      .select([\n        \"logFilter_name\",\n\n        \"logs.address as log_address\",\n        \"logs.blockHash as log_blockHash\",\n        \"logs.blockNumber as log_blockNumber\",\n        // \"logs.chainId as log_chainId\",\n        \"logs.data as log_data\",\n        // \"logs.finalized as log_finalized\",\n        \"logs.id as log_id\",\n        \"logs.logIndex as log_logIndex\",\n        \"logs.topic0 as log_topic0\",\n        \"logs.topic1 as log_topic1\",\n        \"logs.topic2 as log_topic2\",\n        \"logs.topic3 as log_topic3\",\n        \"logs.transactionHash as log_transactionHash\",\n        \"logs.transactionIndex as log_transactionIndex\",\n\n        \"blocks.baseFeePerGas as block_baseFeePerGas\",\n        // \"blocks.chainId as block_chainId\",\n        \"blocks.difficulty as block_difficulty\",\n        \"blocks.extraData as block_extraData\",\n        // \"blocks.finalized as block_finalized\",\n        \"blocks.gasLimit as block_gasLimit\",\n        \"blocks.gasUsed as block_gasUsed\",\n        \"blocks.hash as block_hash\",\n        \"blocks.logsBloom as block_logsBloom\",\n        \"blocks.miner as block_miner\",\n        \"blocks.mixHash as block_mixHash\",\n        \"blocks.nonce as block_nonce\",\n        \"blocks.number as block_number\",\n        \"blocks.parentHash as block_parentHash\",\n        \"blocks.receiptsRoot as block_receiptsRoot\",\n        \"blocks.sha3Uncles as block_sha3Uncles\",\n        \"blocks.size as block_size\",\n        \"blocks.stateRoot as block_stateRoot\",\n        \"blocks.timestamp as block_timestamp\",\n        \"blocks.totalDifficulty as block_totalDifficulty\",\n        \"blocks.transactionsRoot as block_transactionsRoot\",\n\n        \"transactions.accessList as tx_accessList\",\n        \"transactions.blockHash as tx_blockHash\",\n        \"transactions.blockNumber as tx_blockNumber\",\n        // \"transactions.chainId as tx_chainId\",\n        // \"transactions.finalized as tx_finalized\",\n        \"transactions.from as tx_from\",\n        \"transactions.gas as tx_gas\",\n        \"transactions.gasPrice as tx_gasPrice\",\n        \"transactions.hash as tx_hash\",\n        \"transactions.input as tx_input\",\n        \"transactions.maxFeePerGas as tx_maxFeePerGas\",\n        \"transactions.maxPriorityFeePerGas as tx_maxPriorityFeePerGas\",\n        \"transactions.nonce as tx_nonce\",\n        \"transactions.r as tx_r\",\n        \"transactions.s as tx_s\",\n        \"transactions.to as tx_to\",\n        \"transactions.transactionIndex as tx_transactionIndex\",\n        \"transactions.type as tx_type\",\n        \"transactions.value as tx_value\",\n        \"transactions.v as tx_v\",\n      ])\n      .where(({ and, or, cmpr, ref }) =>\n        and([\n          cmpr(\"logs.chainId\", \"=\", ref(\"logFilter_chainId\")),\n          or([\n            cmpr(\"logFilter_address\", \"is\", null),\n            cmpr(\"logFilter_address\", \"like\", sql`'%' || logs.address || '%'`),\n          ]),\n          and([\n            or([\n              cmpr(\"logFilter_topic0\", \"is\", null),\n              cmpr(\"logFilter_topic0\", \"like\", sql`'%' || logs.topic0 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic1\", \"is\", null),\n              cmpr(\"logFilter_topic1\", \"like\", sql`'%' || logs.topic1 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic2\", \"is\", null),\n              cmpr(\"logFilter_topic2\", \"like\", sql`'%' || logs.topic2 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic3\", \"is\", null),\n              cmpr(\"logFilter_topic3\", \"like\", sql`'%' || logs.topic3 || '%'`),\n            ]),\n          ]),\n          or([\n            cmpr(\"logFilter_fromBlock\", \"is\", null),\n            cmpr(\"blocks.number\", \">=\", ref(\"logFilter_fromBlock\")),\n          ]),\n          or([\n            cmpr(\"logFilter_toBlock\", \"is\", null),\n            cmpr(\"blocks.number\", \"<=\", ref(\"logFilter_toBlock\")),\n          ]),\n          or([\n            cmpr(\"logFilter_handledTopic0\", \"is\", null),\n            cmpr(\n              \"logFilter_handledTopic0\",\n              \"like\",\n              sql`'%' || logs.topic0 || '%'`\n            ),\n          ]),\n        ])\n      )\n      .where(\"blocks.timestamp\", \">=\", intToBlob(fromTimestamp))\n      .where(\"blocks.timestamp\", \"<=\", intToBlob(toTimestamp))\n      .orderBy(\"blocks.timestamp\", \"asc\")\n      .orderBy(\"logs.chainId\", \"asc\")\n      .orderBy(\"logs.logIndex\", \"asc\")\n      .orderBy(\"logFilter_name\", \"asc\");\n\n    // Get total count of matching logs.\n    const totalLogCountQuery = this.db\n      .with(\n        \"logFilters(logFilter_name, logFilter_chainId, logFilter_address, logFilter_topic0, logFilter_topic1, logFilter_topic2, logFilter_topic3, logFilter_fromBlock, logFilter_toBlock, logFilter_handledTopic0)\",\n        () => sql`( values ${sql.join(filters.map(buildLogFilterValues))} )`\n      )\n      .selectFrom(\"logs\")\n      .leftJoin(\"blocks\", \"blocks.hash\", \"logs.blockHash\")\n      .innerJoin(\"logFilters\", (join) => join.onTrue())\n      .select(this.db.fn.count(\"logs.id\").as(\"log_count\"))\n      .where(({ and, or, cmpr, ref }) =>\n        and([\n          cmpr(\"logs.chainId\", \"=\", ref(\"logFilter_chainId\")),\n          or([\n            cmpr(\"logFilter_address\", \"is\", null),\n            cmpr(\"logFilter_address\", \"like\", sql`'%' || logs.address || '%'`),\n          ]),\n          and([\n            or([\n              cmpr(\"logFilter_topic0\", \"is\", null),\n              cmpr(\"logFilter_topic0\", \"like\", sql`'%' || logs.topic0 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic1\", \"is\", null),\n              cmpr(\"logFilter_topic1\", \"like\", sql`'%' || logs.topic1 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic2\", \"is\", null),\n              cmpr(\"logFilter_topic2\", \"like\", sql`'%' || logs.topic2 || '%'`),\n            ]),\n            or([\n              cmpr(\"logFilter_topic3\", \"is\", null),\n              cmpr(\"logFilter_topic3\", \"like\", sql`'%' || logs.topic3 || '%'`),\n            ]),\n          ]),\n          or([\n            cmpr(\"logFilter_fromBlock\", \"is\", null),\n            cmpr(\"blocks.number\", \">=\", ref(\"logFilter_fromBlock\")),\n          ]),\n          or([\n            cmpr(\"logFilter_toBlock\", \"is\", null),\n            cmpr(\"blocks.number\", \"<=\", ref(\"logFilter_toBlock\")),\n          ]),\n        ])\n      )\n      .where(\"blocks.timestamp\", \">=\", intToBlob(fromTimestamp))\n      .where(\"blocks.timestamp\", \"<=\", intToBlob(toTimestamp));\n\n    // Get handled logs.\n    const handledLogs = await handledLogQuery.execute();\n\n    const totalLogCount = await totalLogCountQuery.execute();\n    const totalEventCount = Number(totalLogCount[0].log_count);\n\n    const events = handledLogs.map((result_) => {\n      // Without this cast, the block_ and tx_ fields are all nullable\n      // which makes this very annoying. Should probably add a runtime check\n      // that those fields are indeed present before continuing here.\n      const result = result_ as NonNull<(typeof handledLogs)[number]>;\n\n      const event: {\n        filterName: string;\n        log: Log;\n        block: Block;\n        transaction: Transaction;\n      } = {\n        filterName: result.logFilter_name,\n        log: {\n          address: result.log_address,\n          blockHash: result.log_blockHash,\n          blockNumber: blobToBigInt(result.log_blockNumber),\n          data: result.log_data,\n          id: result.log_id,\n          logIndex: Number(result.log_logIndex),\n          removed: false,\n          topics: [\n            result.log_topic0,\n            result.log_topic1,\n            result.log_topic2,\n            result.log_topic3,\n          ].filter((t): t is Hex => t !== null) as [Hex, ...Hex[]] | [],\n          transactionHash: result.log_transactionHash,\n          transactionIndex: Number(result.log_transactionIndex),\n        },\n        block: {\n          baseFeePerGas: result.block_baseFeePerGas\n            ? blobToBigInt(result.block_baseFeePerGas)\n            : null,\n          difficulty: blobToBigInt(result.block_difficulty),\n          extraData: result.block_extraData,\n          gasLimit: blobToBigInt(result.block_gasLimit),\n          gasUsed: blobToBigInt(result.block_gasUsed),\n          hash: result.block_hash,\n          logsBloom: result.block_logsBloom,\n          miner: result.block_miner,\n          mixHash: result.block_mixHash,\n          nonce: result.block_nonce,\n          number: blobToBigInt(result.block_number),\n          parentHash: result.block_parentHash,\n          receiptsRoot: result.block_receiptsRoot,\n          sha3Uncles: result.block_sha3Uncles,\n          size: blobToBigInt(result.block_size),\n          stateRoot: result.block_stateRoot,\n          timestamp: blobToBigInt(result.block_timestamp),\n          totalDifficulty: blobToBigInt(result.block_totalDifficulty),\n          transactionsRoot: result.block_transactionsRoot,\n        },\n        transaction: {\n          blockHash: result.tx_blockHash,\n          blockNumber: blobToBigInt(result.tx_blockNumber),\n          from: result.tx_from,\n          gas: blobToBigInt(result.tx_gas),\n          hash: result.tx_hash,\n          input: result.tx_input,\n          nonce: Number(result.tx_nonce),\n          r: result.tx_r,\n          s: result.tx_s,\n          to: result.tx_to,\n          transactionIndex: Number(result.tx_transactionIndex),\n          value: blobToBigInt(result.tx_value),\n          v: blobToBigInt(result.tx_v),\n          ...(result.tx_type === \"0x0\"\n            ? {\n                type: \"legacy\",\n                gasPrice: blobToBigInt(result.tx_gasPrice),\n              }\n            : result.tx_type === \"0x1\"\n            ? {\n                type: \"eip2930\",\n                gasPrice: blobToBigInt(result.tx_gasPrice),\n                accessList: JSON.parse(result.tx_accessList),\n              }\n            : result.tx_type === \"0x2\"\n            ? {\n                type: \"eip1559\",\n                maxFeePerGas: blobToBigInt(result.tx_maxFeePerGas),\n                maxPriorityFeePerGas: blobToBigInt(\n                  result.tx_maxPriorityFeePerGas\n                ),\n              }\n            : result.tx_type === \"0x7e\"\n            ? {\n                type: \"deposit\",\n                maxFeePerGas: blobToBigInt(result.tx_maxFeePerGas),\n                maxPriorityFeePerGas: blobToBigInt(\n                  result.tx_maxPriorityFeePerGas\n                ),\n              }\n            : {\n                type: result.tx_type,\n              }),\n        },\n      };\n\n      return event;\n    });\n\n    return {\n      events,\n      totalEventCount,\n    };\n  };\n}\n\nfunction getLogFilterAddressOrTopic(value: Hex | Hex[] | undefined | null) {\n  if (value === undefined || value === null) return null;\n  if (typeof value === \"string\") return value;\n  return value.join(\",\");\n}\n\nfunction getLogFilterTopics(topics: (Hex | Hex[] | null)[] | undefined) {\n  if (!topics) return [null, null, null, null];\n  const topic0 = getLogFilterAddressOrTopic(topics[0]);\n  const topic1 = getLogFilterAddressOrTopic(topics[1]);\n  const topic2 = getLogFilterAddressOrTopic(topics[2]);\n  const topic3 = getLogFilterAddressOrTopic(topics[3]);\n  return [topic0, topic1, topic2, topic3];\n}\n\nfunction buildLogFilterValues(filter: {\n  name: string;\n  chainId: number;\n  address?: Address | Address[];\n  topics?: (Hex | Hex[] | null)[];\n  fromBlock?: number;\n  toBlock?: number;\n  handledTopic0?: Hex[];\n}) {\n  const { name, chainId, address, topics, fromBlock, toBlock, handledTopic0 } =\n    filter;\n\n  const address_ = getLogFilterAddressOrTopic(address);\n  const [topic0, topic1, topic2, topic3] = getLogFilterTopics(topics);\n  const handledTopic0_ = getLogFilterAddressOrTopic(handledTopic0);\n\n  return sql`(${sql.join([\n    sql.val(name),\n    sql`cast (${sql.val(chainId)} as integer)`,\n    sql.val(address_),\n    sql.val(topic0),\n    sql.val(topic1),\n    sql.val(topic2),\n    sql.val(topic3),\n    sql`cast (${sql.val(fromBlock ? intToBlob(fromBlock) : null)} as blob)`,\n    sql`cast (${sql.val(toBlock ? intToBlob(toBlock) : null)} as blob)`,\n    sql.val(handledTopic0_),\n  ])})`;\n}\n","import { Generated, Insertable, Selectable } from \"kysely\";\nimport {\n  type RpcBlock,\n  type RpcLog,\n  type RpcTransaction,\n  hexToNumber,\n} from \"viem\";\nimport { Address, Hash, Hex } from \"viem\";\n\nimport { intToBlob } from \"@/utils/encode\";\n\ntype BlocksTable = {\n  baseFeePerGas: Buffer | null; // BigInt\n  difficulty: Buffer; // BigInt\n  extraData: Hex;\n  gasLimit: Buffer; // BigInt\n  gasUsed: Buffer; // BigInt\n  hash: Hash;\n  logsBloom: Hex;\n  miner: Address;\n  mixHash: Hash;\n  nonce: Hex;\n  number: Buffer; // BigInt\n  parentHash: Hash;\n  receiptsRoot: Hex;\n  sha3Uncles: Hash;\n  size: Buffer; // BigInt\n  stateRoot: Hash;\n  timestamp: Buffer; // BigInt\n  totalDifficulty: Buffer; // BigInt\n  transactionsRoot: Hash;\n\n  chainId: number;\n  finalized: number;\n};\n\nexport type InsertableBlock = Insertable<BlocksTable>;\n\nexport function rpcToSqliteBlock(\n  block: RpcBlock\n): Omit<InsertableBlock, \"chainId\" | \"finalized\"> {\n  return {\n    baseFeePerGas: block.baseFeePerGas ? intToBlob(block.baseFeePerGas) : null,\n    difficulty: intToBlob(block.difficulty),\n    extraData: block.extraData,\n    gasLimit: intToBlob(block.gasLimit),\n    gasUsed: intToBlob(block.gasUsed),\n    hash: block.hash!,\n    logsBloom: block.logsBloom!,\n    miner: block.miner,\n    mixHash: block.mixHash,\n    nonce: block.nonce!,\n    number: intToBlob(block.number!),\n    parentHash: block.parentHash,\n    receiptsRoot: block.receiptsRoot,\n    sha3Uncles: block.sha3Uncles,\n    size: intToBlob(block.size),\n    stateRoot: block.stateRoot,\n    timestamp: intToBlob(block.timestamp),\n    totalDifficulty: intToBlob(block.totalDifficulty!),\n    transactionsRoot: block.transactionsRoot,\n  };\n}\n\ntype TransactionsTable = {\n  blockHash: Hash;\n  blockNumber: Buffer; // BigInt\n  from: Address;\n  gas: Buffer; // BigInt\n  hash: Hash;\n  input: Hex;\n  nonce: number;\n  r: Hex;\n  s: Hex;\n  to: Address | null;\n  transactionIndex: number;\n  v: Buffer; // BigInt\n  value: Buffer; // BigInt\n\n  type: Hex;\n  gasPrice: Buffer | null; // BigInt\n  maxFeePerGas: Buffer | null; // BigInt\n  maxPriorityFeePerGas: Buffer | null; // BigInt\n  accessList: string | null;\n\n  chainId: number;\n  finalized: number;\n};\n\nexport type InsertableTransaction = Insertable<TransactionsTable>;\n\nexport function rpcToSqliteTransaction(\n  transaction: RpcTransaction\n): Omit<InsertableTransaction, \"chainId\" | \"finalized\"> {\n  return {\n    accessList: transaction.accessList\n      ? JSON.stringify(transaction.accessList)\n      : undefined,\n    blockHash: transaction.blockHash!,\n    blockNumber: intToBlob(transaction.blockNumber!),\n    from: transaction.from,\n    gas: intToBlob(transaction.gas),\n    gasPrice: transaction.gasPrice ? intToBlob(transaction.gasPrice) : null,\n    hash: transaction.hash,\n    input: transaction.input,\n    maxFeePerGas: transaction.maxFeePerGas\n      ? intToBlob(transaction.maxFeePerGas)\n      : null,\n    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas\n      ? intToBlob(transaction.maxPriorityFeePerGas)\n      : null,\n    nonce: hexToNumber(transaction.nonce),\n    r: transaction.r,\n    s: transaction.s,\n    to: transaction.to ? transaction.to : null,\n    transactionIndex: Number(transaction.transactionIndex),\n    type: transaction.type ?? \"0x0\",\n    value: intToBlob(transaction.value),\n    v: intToBlob(transaction.v),\n  };\n}\n\ntype LogsTable = {\n  id: string;\n  address: Address;\n  blockHash: Hash;\n  blockNumber: Buffer; // BigInt\n  data: Hex;\n  logIndex: number;\n  transactionHash: Hash;\n  transactionIndex: number;\n\n  topic0: string | null;\n  topic1: string | null;\n  topic2: string | null;\n  topic3: string | null;\n\n  chainId: number;\n  finalized: number;\n};\n\nexport type InsertableLog = Insertable<LogsTable>;\n\nexport function rpcToSqliteLog({\n  log,\n}: {\n  log: RpcLog;\n}): Omit<InsertableLog, \"chainId\" | \"finalized\"> {\n  return {\n    address: log.address,\n    blockHash: log.blockHash!,\n    blockNumber: intToBlob(log.blockNumber!),\n    data: log.data,\n    id: `${log.blockHash}-${log.logIndex}`,\n    logIndex: Number(log.logIndex!),\n    topic0: log.topics[0] ? log.topics[0] : null,\n    topic1: log.topics[1] ? log.topics[1] : null,\n    topic2: log.topics[2] ? log.topics[2] : null,\n    topic3: log.topics[3] ? log.topics[3] : null,\n    transactionHash: log.transactionHash!,\n    transactionIndex: Number(log.transactionIndex!),\n  };\n}\n\ntype ContractReadResultsTable = {\n  address: string;\n  blockNumber: Buffer; // BigInt\n  chainId: number;\n  data: Hex;\n  finalized: number; // Boolean (0 or 1).\n  result: Hex;\n};\n\ntype LogFilterCachedRangesTable = {\n  id: Generated<number>;\n  filterKey: string;\n  startBlock: Buffer; // BigInt\n  endBlock: Buffer; // BigInt\n  endBlockTimestamp: Buffer; // BigInt\n};\n\nexport type LogFilterCachedRange = Omit<\n  Selectable<LogFilterCachedRangesTable>,\n  \"id\"\n>;\n\nexport type EventStoreTables = {\n  blocks: BlocksTable;\n  transactions: TransactionsTable;\n  logs: LogsTable;\n  contractReadResults: ContractReadResultsTable;\n  logFilterCachedRanges: LogFilterCachedRangesTable;\n};\n","import { Kysely, Migration, MigrationProvider } from \"kysely\";\n\nconst migrations: Record<string, Migration> = {\n  [\"2023_05_15_0_initial\"]: {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createTable(\"blocks\")\n        .addColumn(\"baseFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"difficulty\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"extraData\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"gasLimit\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"gasUsed\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logsBloom\", \"text\", (col) => col.notNull())\n        .addColumn(\"miner\", \"text\", (col) => col.notNull())\n        .addColumn(\"mixHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"nonce\", \"text\", (col) => col.notNull())\n        .addColumn(\"number\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"parentHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"receiptsRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"sha3Uncles\", \"text\", (col) => col.notNull())\n        .addColumn(\"size\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"stateRoot\", \"text\", (col) => col.notNull())\n        .addColumn(\"timestamp\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"totalDifficulty\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"transactionsRoot\", \"text\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"transactions\")\n        .addColumn(\"accessList\", \"text\")\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"from\", \"text\", (col) => col.notNull())\n        .addColumn(\"gas\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"gasPrice\", \"blob\") // BigInt\n        .addColumn(\"hash\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"input\", \"text\", (col) => col.notNull())\n        .addColumn(\"maxFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"maxPriorityFeePerGas\", \"blob\") // BigInt\n        .addColumn(\"nonce\", \"integer\", (col) => col.notNull())\n        .addColumn(\"r\", \"text\", (col) => col.notNull())\n        .addColumn(\"s\", \"text\", (col) => col.notNull())\n        .addColumn(\"to\", \"text\")\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"type\", \"text\", (col) => col.notNull())\n        .addColumn(\"value\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"v\", \"blob\", (col) => col.notNull()) // BigInt\n        .execute();\n\n      await db.schema\n        .createTable(\"logs\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"id\", \"text\", (col) => col.notNull().primaryKey())\n        .addColumn(\"logIndex\", \"integer\", (col) => col.notNull())\n        .addColumn(\"topic0\", \"text\")\n        .addColumn(\"topic1\", \"text\")\n        .addColumn(\"topic2\", \"text\")\n        .addColumn(\"topic3\", \"text\")\n        .addColumn(\"transactionHash\", \"text\", (col) => col.notNull())\n        .addColumn(\"transactionIndex\", \"integer\", (col) => col.notNull())\n        .execute();\n\n      await db.schema\n        .createTable(\"contractReadResults\")\n        .addColumn(\"address\", \"text\", (col) => col.notNull())\n        .addColumn(\"blockNumber\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"chainId\", \"integer\", (col) => col.notNull())\n        .addColumn(\"data\", \"text\", (col) => col.notNull())\n        .addColumn(\"finalized\", \"integer\", (col) => col.notNull()) // Boolean (0 or 1).\n        .addColumn(\"result\", \"text\", (col) => col.notNull())\n        .addPrimaryKeyConstraint(\"contractReadResultPrimaryKey\", [\n          \"chainId\",\n          \"blockNumber\",\n          \"address\",\n          \"data\",\n        ])\n        .execute();\n\n      await db.schema\n        .createTable(\"logFilterCachedRanges\")\n        .addColumn(\"endBlock\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"endBlockTimestamp\", \"blob\", (col) => col.notNull()) // BigInt\n        .addColumn(\"filterKey\", \"text\", (col) => col.notNull())\n        // The `id` column should not be included in INSERT statements.\n        // This column uses SQLite's ROWID() function (simple autoincrement).\n        .addColumn(\"id\", \"integer\", (col) => col.notNull().primaryKey())\n        .addColumn(\"startBlock\", \"blob\", (col) => col.notNull()) // BigInt\n        .execute();\n    },\n    async down(db: Kysely<any>) {\n      await db.schema.dropTable(\"blocks\").execute();\n      await db.schema.dropTable(\"logs\").execute();\n      await db.schema.dropTable(\"transactions\").execute();\n      await db.schema.dropTable(\"contractReadResults\").execute();\n      await db.schema.dropTable(\"logFilterCachedRanges\").execute();\n    },\n  },\n  [\"2023_06_20_0_indices\"]: {\n    async up(db: Kysely<any>) {\n      await db.schema\n        .createIndex(\"log_events_index\")\n        .on(\"logs\")\n        .columns([\"address\", \"chainId\", \"blockHash\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"blocks_index\")\n        .on(\"blocks\")\n        .columns([\"timestamp\", \"number\"])\n        .execute();\n\n      await db.schema\n        .createIndex(\"logFilterCachedRanges_index\")\n        .on(\"logFilterCachedRanges\")\n        .columns([\"filterKey\"])\n        .execute();\n    },\n\n    async down(db: Kysely<any>) {\n      await db.schema.dropIndex(\"log_events_index\").execute();\n      await db.schema.dropIndex(\"logFilterCachedRanges_index\").execute();\n      await db.schema.dropIndex(\"blocks_index\").execute();\n    },\n  },\n};\n\nclass StaticMigrationProvider implements MigrationProvider {\n  async getMigrations() {\n    return migrations;\n  }\n}\n\nexport const migrationProvider = new StaticMigrationProvider();\n","import Emittery from \"emittery\";\nimport {\n  type Hash,\n  type RpcTransaction,\n  HttpRequestError,\n  InvalidParamsRpcError,\n  toHex,\n} from \"viem\";\n\nimport type { LogFilter } from \"@/config/logFilters\";\nimport type { Network } from \"@/config/networks\";\nimport { QueueError } from \"@/errors/queue\";\nimport type { EventStore } from \"@/event-store/store\";\nimport { Resources } from \"@/Ponder\";\nimport { formatEta, formatPercentage } from \"@/utils/format\";\nimport { type Queue, type Worker, createQueue } from \"@/utils/queue\";\nimport { hrTimeToMs, startClock } from \"@/utils/timer\";\n\nimport { findMissingIntervals } from \"./intervals\";\n\ntype HistoricalSyncEvents = {\n  /**\n   * Emitted when the service has finished processing all historical sync tasks.\n   */\n  syncComplete: undefined;\n  /**\n   * Emitted when the minimum cached timestamp among all registered log filters moves forward.\n   * This indicates to consumers that the connected event store now contains a complete history\n   * of events for all registered log filters between their start block and this timestamp (inclusive).\n   */\n  historicalCheckpoint: { timestamp: number };\n  /**\n   * Emitted when a historical sync task fails.\n   */\n  error: { error: Error };\n};\n\ntype LogSyncTask = {\n  kind: \"LOG_SYNC\";\n  logFilter: LogFilter;\n  fromBlock: number;\n  toBlock: number;\n};\n\ntype BlockSyncTask = {\n  kind: \"BLOCK_SYNC\";\n  logFilter: LogFilter;\n  blockNumberToCacheFrom: number;\n  blockNumber: number;\n  requiredTxHashes: Set<Hash>;\n};\n\ntype HistoricalSyncQueue = Queue<LogSyncTask | BlockSyncTask>;\n\nexport class HistoricalSyncService extends Emittery<HistoricalSyncEvents> {\n  private resources: Resources;\n  private eventStore: EventStore;\n  private logFilters: LogFilter[];\n  private network: Network;\n\n  private queue: HistoricalSyncQueue;\n\n  private logFilterCheckpoints: Record<string, number> = {};\n  private minimumLogFilterCheckpoint = 0;\n\n  private startTimestamp?: [number, number];\n  private killFunctions: (() => void | Promise<void>)[] = [];\n\n  constructor({\n    resources,\n    eventStore,\n    logFilters,\n    network,\n  }: {\n    resources: Resources;\n    eventStore: EventStore;\n    logFilters: LogFilter[];\n    network: Network;\n  }) {\n    super();\n\n    this.resources = resources;\n    this.eventStore = eventStore;\n    this.logFilters = logFilters;\n    this.network = network;\n\n    this.queue = this.buildQueue();\n\n    logFilters.forEach((logFilter) => {\n      this.logFilterCheckpoints[logFilter.name] = 0;\n    });\n\n    this.registerMetricCollectMethods();\n  }\n\n  async setup({ finalizedBlockNumber }: { finalizedBlockNumber: number }) {\n    await Promise.all(\n      this.logFilters.map(async (logFilter) => {\n        const { startBlock, endBlock: userDefinedEndBlock } = logFilter.filter;\n        const endBlock = userDefinedEndBlock ?? finalizedBlockNumber;\n        const maxBlockRange =\n          logFilter.maxBlockRange ?? this.network.defaultMaxBlockRange;\n\n        if (startBlock > endBlock) {\n          throw new Error(\n            `Start block number (${startBlock}) is greater than end block number (${endBlock}).\n             Are you sure the RPC endpoint is for the correct network?`\n          );\n        }\n\n        const cachedRanges = await this.eventStore.getLogFilterCachedRanges({\n          filterKey: logFilter.filter.key,\n        });\n\n        const requiredBlockRanges = findMissingIntervals(\n          [startBlock, endBlock],\n          cachedRanges.map((r) => [Number(r.startBlock), Number(r.endBlock)])\n        );\n\n        const totalBlockCount = endBlock - startBlock + 1;\n        const requiredBlockCount = requiredBlockRanges.reduce<number>(\n          (acc, range) => acc + range[1] + 1 - range[0],\n          0\n        );\n        const cachedBlockCount = totalBlockCount - requiredBlockCount;\n\n        const cacheRate = Math.min(\n          1,\n          cachedBlockCount / (totalBlockCount || 1)\n        );\n\n        this.resources.metrics.ponder_historical_total_blocks.set(\n          {\n            network: this.network.name,\n            logFilter: logFilter.name,\n          },\n          totalBlockCount\n        );\n        this.resources.metrics.ponder_historical_cached_blocks.set(\n          {\n            network: this.network.name,\n            logFilter: logFilter.name,\n          },\n          cachedBlockCount\n        );\n\n        this.resources.logger.info({\n          service: \"historical\",\n          msg: `Started sync with ${formatPercentage(\n            cacheRate\n          )} cached (network=${this.network.name})`,\n          network: this.network.name,\n          logFilter: logFilter.name,\n          totalBlockCount,\n          cacheRate,\n        });\n\n        for (const blockRange of requiredBlockRanges) {\n          const [startBlock, endBlock] = blockRange;\n\n          let fromBlock = startBlock;\n          let toBlock = Math.min(fromBlock + maxBlockRange - 1, endBlock);\n\n          while (fromBlock <= endBlock) {\n            this.queue.addTask(\n              {\n                kind: \"LOG_SYNC\",\n                logFilter,\n                fromBlock,\n                toBlock,\n              },\n              {\n                priority: Number.MAX_SAFE_INTEGER - fromBlock,\n              }\n            );\n            this.resources.metrics.ponder_historical_scheduled_tasks.inc({\n              network: this.network.name,\n              kind: \"log\",\n            });\n\n            fromBlock = toBlock + 1;\n            toBlock = Math.min(fromBlock + maxBlockRange - 1, endBlock);\n          }\n        }\n      })\n    );\n  }\n\n  start() {\n    this.startTimestamp = process.hrtime();\n\n    // Emit status update logs on an interval for each active log filter.\n    const updateLogInterval = setInterval(async () => {\n      const completionStats = await this.getCompletionStats();\n\n      completionStats.forEach(({ logFilter, rate, eta }) => {\n        if (rate === 1) return;\n        this.resources.logger.info({\n          service: \"historical\",\n          msg: `Sync is ${formatPercentage(rate)} complete${\n            eta !== undefined ? ` with ~${formatEta(eta)} remaining` : \"\"\n          } (logFilter=${logFilter})`,\n          network: this.network.name,\n        });\n      });\n    }, 10_000);\n    this.killFunctions.push(() => {\n      clearInterval(updateLogInterval);\n    });\n\n    // Edge case: If there are no tasks in the queue, this means the entire\n    // requested range was cached, so the sync is complete. However, we still\n    // need to emit the historicalCheckpoint event with some timestamp. It should\n    // be safe to use the current timestamp.\n    if (this.queue.size === 0) {\n      const now = Math.round(Date.now() / 1000);\n      this.emit(\"historicalCheckpoint\", { timestamp: now });\n      this.emit(\"syncComplete\");\n      this.resources.logger.info({\n        service: \"historical\",\n        msg: `Completed sync (network=${this.network.name})`,\n        network: this.network.name,\n      });\n    }\n\n    this.queue.start();\n  }\n\n  kill = async () => {\n    for (const fn of this.killFunctions) {\n      await fn();\n    }\n\n    this.queue.pause();\n    this.queue.clear();\n    // TODO: Figure out if it's necessary to wait for the queue to be idle before killing it.\n    // await this.onIdle();\n    this.resources.logger.debug({\n      service: \"historical\",\n      msg: `Killed historical sync service (network=${this.network.name})`,\n    });\n  };\n\n  onIdle = async () => {\n    await this.queue.onIdle();\n  };\n\n  private buildQueue = () => {\n    const worker: Worker<LogSyncTask | BlockSyncTask> = async ({\n      task,\n      queue,\n    }) => {\n      if (task.kind === \"LOG_SYNC\") {\n        await this.logTaskWorker({ task });\n      } else {\n        await this.blockTaskWorker({ task });\n      }\n\n      // If this is not the final task, return.\n      if (queue.size > 0 || queue.pending > 1) return;\n\n      // If this is the final task, run the cleanup/completion logic.\n\n      // It's possible for multiple block sync tasks to run simultaneously,\n      // resulting in a scenario where cached ranges are not fully merged.\n      // Merge all cached ranges once last time before emitting the `syncComplete` event.\n      await Promise.all(\n        this.logFilters.map((logFilter) =>\n          this.updateHistoricalCheckpoint({ logFilter })\n        )\n      );\n\n      this.emit(\"syncComplete\");\n      const duration = hrTimeToMs(process.hrtime(this.startTimestamp));\n      this.resources.logger.info({\n        service: \"historical\",\n        msg: `Completed sync in ${formatEta(duration)} (network=${\n          this.network.name\n        })`,\n        network: this.network.name,\n        duration,\n      });\n    };\n\n    const queue = createQueue<LogSyncTask | BlockSyncTask>({\n      worker,\n      options: {\n        concurrency: this.network.maxRpcRequestConcurrency,\n        autoStart: false,\n      },\n      onComplete: ({ task }) => {\n        const { logFilter } = task;\n\n        if (task.kind === \"BLOCK_SYNC\") {\n          this.resources.metrics.ponder_historical_completed_tasks.inc({\n            network: this.network.name,\n            kind: \"block\",\n            status: \"success\",\n          });\n\n          this.resources.logger.trace({\n            service: \"historical\",\n            msg: `Completed block sync task`,\n            network: this.network.name,\n            logFilter: logFilter.name,\n            blockNumberToCacheFrom: task.blockNumberToCacheFrom,\n            blockNumber: task.blockNumber,\n            requiredTransactionCount: task.requiredTxHashes.size,\n          });\n\n          // When a block task completes, a cached range record gets inserted.\n          // Update the block range progress metric accordingly.\n          this.resources.metrics.ponder_historical_completed_blocks.inc(\n            {\n              network: this.network.name,\n              logFilter: logFilter.name,\n            },\n            task.blockNumber - task.blockNumberToCacheFrom + 1\n          );\n        }\n\n        if (task.kind === \"LOG_SYNC\") {\n          this.resources.metrics.ponder_historical_completed_tasks.inc({\n            network: this.network.name,\n            kind: \"log\",\n            status: \"success\",\n          });\n\n          this.resources.logger.trace({\n            service: \"historical\",\n            msg: `Completed log sync task`,\n            network: this.network.name,\n            logFilter: logFilter.name,\n            fromBlock: task.fromBlock,\n            toBlock: task.toBlock,\n          });\n        }\n      },\n      onError: ({ error, task, queue }) => {\n        const { logFilter } = task;\n\n        this.resources.metrics.ponder_historical_completed_tasks.inc({\n          network: this.network.name,\n          kind: task.kind === \"LOG_SYNC\" ? \"log\" : \"block\",\n          status: \"failure\",\n        });\n\n        // Handle Alchemy response size error.\n        if (\n          task.kind === \"LOG_SYNC\" &&\n          error instanceof InvalidParamsRpcError &&\n          error.details.startsWith(\"Log response size exceeded.\")\n        ) {\n          const safe = error.details.split(\"this block range should work: \")[1];\n          const safeStart = Number(safe.split(\", \")[0].slice(1));\n          const safeEnd = Number(safe.split(\", \")[1].slice(0, -1));\n\n          queue.addTask(\n            { ...task, fromBlock: safeStart, toBlock: safeEnd },\n            {\n              priority: Number.MAX_SAFE_INTEGER - safeStart,\n            }\n          );\n          queue.addTask(\n            { ...task, fromBlock: safeEnd + 1 },\n            { priority: Number.MAX_SAFE_INTEGER - safeEnd + 1 }\n          );\n          // Splitting the task into two parts increases the total count by 1.\n          this.resources.metrics.ponder_historical_scheduled_tasks.inc({\n            network: this.network.name,\n            kind: \"log\",\n          });\n          return;\n        }\n\n        // Handle thirdweb block range limit error.\n        if (\n          task.kind === \"LOG_SYNC\" &&\n          error instanceof InvalidParamsRpcError &&\n          error.details.includes(\"block range less than 20000\")\n        ) {\n          const midpoint = Math.floor(\n            (task.toBlock - task.fromBlock) / 2 + task.fromBlock\n          );\n          queue.addTask(\n            { ...task, toBlock: midpoint },\n            { priority: Number.MAX_SAFE_INTEGER - task.fromBlock }\n          );\n          queue.addTask(\n            { ...task, fromBlock: midpoint + 1 },\n            { priority: Number.MAX_SAFE_INTEGER - midpoint + 1 }\n          );\n          // Splitting the task into two parts increases the total count by 1.\n          this.resources.metrics.ponder_historical_scheduled_tasks.inc({\n            network: this.network.name,\n            kind: \"log\",\n          });\n          return;\n        }\n\n        // Handle Quicknode block range limit error (should never happen).\n        if (\n          task.kind === \"LOG_SYNC\" &&\n          error instanceof HttpRequestError &&\n          error.details.includes(\n            \"eth_getLogs and eth_newFilter are limited to a 10,000 blocks range\"\n          )\n        ) {\n          const midpoint = Math.floor(\n            (task.toBlock - task.fromBlock) / 2 + task.fromBlock\n          );\n          queue.addTask(\n            { ...task, toBlock: midpoint },\n            { priority: Number.MAX_SAFE_INTEGER - task.fromBlock }\n          );\n          queue.addTask(\n            { ...task, fromBlock: midpoint + 1 },\n            { priority: Number.MAX_SAFE_INTEGER - midpoint + 1 }\n          );\n          // Splitting the task into two parts increases the total count by 1.\n          this.resources.metrics.ponder_historical_scheduled_tasks.inc({\n            network: this.network.name,\n            kind: \"log\",\n          });\n          return;\n        }\n\n        const queueError = new QueueError({\n          queueName: \"Historical sync queue\",\n          task: {\n            logFilterName: task.logFilter.name,\n            ...task,\n            logFilter: undefined,\n          },\n          cause: error,\n        });\n        this.emit(\"error\", { error: queueError });\n\n        if (task.kind === \"LOG_SYNC\") {\n          this.resources.logger.error({\n            service: \"historical\",\n            msg: `Log sync task failed (network=${this.network.name}, logFilter=${logFilter.name})`,\n            error,\n            network: this.network.name,\n            logFilter: logFilter.name,\n            fromBlock: task.fromBlock,\n            toBlock: task.toBlock,\n          });\n        }\n\n        if (task.kind === \"BLOCK_SYNC\") {\n          this.resources.logger.error({\n            service: \"historical\",\n            msg: `Block sync task failed (network=${this.network.name}, logFilter=${logFilter.name})`,\n            error,\n            network: this.network.name,\n            logFilter: logFilter.name,\n            blockNumberToCacheFrom: task.blockNumberToCacheFrom,\n            blockNumber: task.blockNumber,\n            requiredTransactionCount: task.requiredTxHashes.size,\n          });\n        }\n\n        // Default to a retry (uses the retry options passed to the queue).\n        const priority =\n          Number.MAX_SAFE_INTEGER -\n          (task.kind === \"LOG_SYNC\"\n            ? task.fromBlock\n            : task.blockNumberToCacheFrom);\n        queue.addTask(task, { priority, retry: true });\n      },\n    });\n\n    return queue;\n  };\n\n  private logTaskWorker = async ({ task }: { task: LogSyncTask }) => {\n    const { logFilter, fromBlock, toBlock } = task;\n\n    const stopClock = startClock();\n    const logs = await this.network.client.request({\n      method: \"eth_getLogs\",\n      params: [\n        {\n          address: logFilter.filter.address,\n          topics: logFilter.filter.topics,\n          fromBlock: toHex(fromBlock),\n          toBlock: toHex(toBlock),\n        },\n      ],\n    });\n    this.resources.metrics.ponder_historical_rpc_request_duration.observe(\n      {\n        method: \"eth_getLogs\",\n        network: this.network.name,\n      },\n      stopClock()\n    );\n\n    await this.eventStore.insertFinalizedLogs({\n      chainId: this.network.chainId,\n      logs,\n    });\n\n    const txHashesByBlockNumber = logs.reduce<Record<number, Set<Hash>>>(\n      (acc, log) => {\n        const blockNumber = Number(log.blockNumber);\n        acc[blockNumber] ||= new Set<Hash>();\n        acc[blockNumber].add(log.transactionHash!);\n        return acc;\n      },\n      {}\n    );\n    const requiredBlockNumbers = Object.keys(txHashesByBlockNumber)\n      .map(Number)\n      .sort((a, b) => a - b);\n\n    let blockNumberToCacheFrom = fromBlock;\n    const blockTasks: BlockSyncTask[] = [];\n\n    for (const blockNumber of requiredBlockNumbers) {\n      blockTasks.push({\n        kind: \"BLOCK_SYNC\",\n        logFilter,\n        blockNumberToCacheFrom,\n        blockNumber,\n        requiredTxHashes: txHashesByBlockNumber[blockNumber],\n      });\n      blockNumberToCacheFrom = blockNumber + 1;\n    }\n\n    // If there is a gap between the last required block and the toBlock\n    // of the log batch, add another task to cover the gap. This is necessary\n    // to properly updates the log filter cached range data.\n    if (blockNumberToCacheFrom <= toBlock) {\n      blockTasks.push({\n        kind: \"BLOCK_SYNC\",\n        logFilter,\n        blockNumberToCacheFrom,\n        blockNumber: toBlock,\n        requiredTxHashes: new Set(),\n      });\n    }\n\n    for (const blockTask of blockTasks) {\n      const priority =\n        Number.MAX_SAFE_INTEGER - blockTask.blockNumberToCacheFrom;\n      this.queue.addTask(blockTask, { priority });\n    }\n\n    this.resources.metrics.ponder_historical_scheduled_tasks.inc(\n      {\n        network: this.network.name,\n        kind: \"block\",\n      },\n      blockTasks.length\n    );\n  };\n\n  private blockTaskWorker = async ({ task }: { task: BlockSyncTask }) => {\n    const { logFilter, blockNumber, blockNumberToCacheFrom, requiredTxHashes } =\n      task;\n\n    const stopClock = startClock();\n    const block = await this.network.client.request({\n      method: \"eth_getBlockByNumber\",\n      params: [toHex(blockNumber), true],\n    });\n\n    this.resources.metrics.ponder_historical_rpc_request_duration.observe(\n      {\n        method: \"eth_getBlockByNumber\",\n        network: this.network.name,\n      },\n      stopClock()\n    );\n\n    if (!block) throw new Error(`Block not found: ${blockNumber}`);\n\n    // Filter down to only required transactions (transactions that emitted events we care about).\n    const transactions = (block.transactions as RpcTransaction[]).filter((tx) =>\n      requiredTxHashes.has(tx.hash)\n    );\n\n    await this.eventStore.insertFinalizedBlock({\n      chainId: this.network.chainId,\n      block,\n      transactions,\n      logFilterRange: {\n        logFilterKey: logFilter.filter.key,\n        blockNumberToCacheFrom,\n      },\n    });\n\n    await this.updateHistoricalCheckpoint({ logFilter });\n  };\n\n  private updateHistoricalCheckpoint = async ({\n    logFilter,\n  }: {\n    logFilter: LogFilter;\n  }) => {\n    const { startingRangeEndTimestamp } =\n      await this.eventStore.mergeLogFilterCachedRanges({\n        logFilterKey: logFilter.filter.key,\n        logFilterStartBlockNumber: logFilter.filter.startBlock,\n      });\n\n    this.logFilterCheckpoints[logFilter.name] = Math.max(\n      this.logFilterCheckpoints[logFilter.name],\n      startingRangeEndTimestamp\n    );\n\n    const historicalCheckpoint = Math.min(\n      ...Object.values(this.logFilterCheckpoints)\n    );\n    if (historicalCheckpoint > this.minimumLogFilterCheckpoint) {\n      this.minimumLogFilterCheckpoint = historicalCheckpoint;\n      this.emit(\"historicalCheckpoint\", {\n        timestamp: this.minimumLogFilterCheckpoint,\n      });\n    }\n  };\n\n  private getCompletionStats = async () => {\n    const cachedBlocksMetric = (\n      await this.resources.metrics.ponder_historical_cached_blocks.get()\n    ).values;\n    const totalBlocksMetric = (\n      await this.resources.metrics.ponder_historical_total_blocks.get()\n    ).values;\n    const completedBlocksMetric = (\n      await this.resources.metrics.ponder_historical_completed_blocks.get()\n    ).values;\n\n    return this.logFilters.map(({ name }) => {\n      const totalBlocks = totalBlocksMetric.find(\n        (m) => m.labels.logFilter === name\n      )?.value;\n      const cachedBlocks = cachedBlocksMetric.find(\n        (m) => m.labels.logFilter === name\n      )?.value;\n      const completedBlocks =\n        completedBlocksMetric.find((m) => m.labels.logFilter === name)?.value ??\n        0;\n\n      // Any of these mean setup is not complete.\n      if (\n        totalBlocks === undefined ||\n        totalBlocks === 0 ||\n        cachedBlocks === undefined ||\n        !this.startTimestamp\n      ) {\n        return { logFilter: name, rate: 0 };\n      }\n\n      const rate = (cachedBlocks + completedBlocks) / totalBlocks;\n\n      // If fewer than 3 blocks have been processsed, the ETA will be low quality.\n      if (completedBlocks < 3) return { logFilter: name, rate };\n\n      // If rate is 1, sync is complete, so set the ETA to zero.\n      if (rate === 1) return { logFilter: name, rate, eta: 0 };\n\n      // (time elapsed) / (% completion of remaining block range)\n      const elapsed = hrTimeToMs(process.hrtime(this.startTimestamp));\n      const estimatedTotalDuration =\n        elapsed / (completedBlocks / (totalBlocks - cachedBlocks));\n      const estimatedTimeRemaining = estimatedTotalDuration - elapsed;\n\n      return { logFilter: name, rate, eta: estimatedTimeRemaining };\n    });\n  };\n\n  private registerMetricCollectMethods = async () => {\n    // The `prom-client` base Metric class does allow dynamic assignment\n    // of the `collect()` method, but it's not typed as such.\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.resources.metrics.ponder_historical_completion_rate.collect =\n      async () => {\n        const completionStats = await this.getCompletionStats();\n        completionStats.forEach(({ logFilter, rate }) => {\n          this.resources.metrics.ponder_historical_completion_rate.set(\n            { logFilter, network: this.network.name },\n            rate\n          );\n        });\n      };\n\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.resources.metrics.ponder_historical_completion_eta.collect =\n      async () => {\n        const completionStats = await this.getCompletionStats();\n        completionStats.forEach(({ logFilter, eta }) => {\n          // If no progress has been made, can't calculate an accurate ETA.\n          if (eta) {\n            this.resources.metrics.ponder_historical_completion_eta.set(\n              { logFilter, network: this.network.name },\n              eta\n            );\n          }\n        });\n      };\n  };\n}\n","import { prettyPrint } from \"@/utils/print\";\n\nimport { BaseError } from \"./base\";\n\nexport class QueueError extends BaseError {\n  name = \"QueueError\";\n\n  constructor({\n    queueName,\n    task,\n    cause,\n  }: {\n    queueName: string;\n    task: any;\n    cause: Error;\n  }) {\n    const metaMessages = [];\n    metaMessages.push(`Task:\\n${prettyPrint(task)}`);\n    if (cause.stack) metaMessages.push(`Stack: ${cause.stack}`);\n\n    const shortMessage = `${queueName} error`;\n\n    super(shortMessage, {\n      metaMessages,\n    });\n  }\n}\n","export const formatEta = (ms: number) => {\n  // If less than 1 second, return ms.\n  if (ms < 1000) return `${Math.round(ms)}ms`;\n  const seconds = Math.floor(ms / 1000);\n\n  const h = Math.floor(seconds / 3600);\n  const m = Math.floor((seconds - h * 3600) / 60);\n  const s = seconds - h * 3600 - m * 60;\n\n  const hstr = h > 0 ? `${h}h ` : \"\";\n  const mstr = m > 0 || h > 0 ? `${m}m ` : \"\";\n  const sstr = s > 0 || m > 0 ? `${s}s` : \"\";\n\n  return `${hstr}${mstr}${sstr}`;\n};\n\nexport const formatPercentage = (cacheRate: number) => {\n  const decimal = Math.round(cacheRate * 1000) / 10;\n  return Number.isInteger(decimal) && decimal < 100\n    ? `${decimal}.0%`\n    : `${decimal}%`;\n};\n","import PQueue, { DefaultAddOptions, Options, Queue as TPQueue } from \"p-queue\";\nimport retry, { type CreateTimeoutOptions } from \"retry\";\nimport { setTimeout } from \"timers/promises\";\n\nimport { Prettify } from \"@/types/utils\";\n\ntype TaskOptions = { priority?: number; retry?: boolean };\n\nexport type Queue<TTask> = PQueue & {\n  addTask: (\n    task: TTask & { _retryCount?: number },\n    options?: TaskOptions\n  ) => Promise<void>;\n  addTasks: (\n    tasks: (TTask & { _retryCount?: number })[],\n    options?: TaskOptions\n  ) => Promise<void>;\n};\n\ntype QueueOptions = Prettify<\n  Options<\n    TPQueue<() => Promise<unknown>, DefaultAddOptions>,\n    DefaultAddOptions\n  > & { retryTimeoutOptions?: CreateTimeoutOptions }\n>;\n\nexport type Worker<TTask, TContext = undefined, TReturn = void> = (arg: {\n  task: TTask;\n  context: TContext | undefined;\n  queue: Queue<TTask>;\n}) => Promise<TReturn>;\n\ntype OnAdd<TTask, TContext = undefined> = (arg: {\n  task: TTask;\n  context: TContext | undefined;\n  queue: Queue<TTask>;\n}) => unknown;\n\ntype OnError<TTask, TContext = undefined> = (arg: {\n  error: Error;\n  task: TTask;\n  context: TContext | undefined;\n  queue: Queue<TTask>;\n}) => unknown;\n\ntype OnComplete<TTask, TContext = undefined, TReturn = void> = (arg: {\n  result: TReturn;\n  task: TTask;\n  context: TContext | undefined;\n  queue: Queue<TTask>;\n}) => unknown;\n\n/**\n * Creates a Queue object that has a number of features tailored\n * to Ponder's indexing engine, including:\n * - A shared context object accessible by all tasks\n * - An onError callback that is called _within_ the failed task scope,\n *   allowing the user to retry/add more tasks without the queue going idle.\n * - An onComplete callback that is called _within_ the completed task scope.\n * - A configurable retry scheme using `node-retry`.\n */\nexport function createQueue<TTask, TContext = undefined, TReturn = void>({\n  worker,\n  context,\n  options,\n  onAdd,\n  onComplete,\n  onError,\n  onIdle,\n}: {\n  worker: Worker<TTask, TContext, TReturn>;\n  context?: TContext;\n  options?: QueueOptions;\n  onAdd?: OnAdd<TTask, TContext>;\n  onComplete?: OnComplete<TTask, TContext, TReturn>;\n  onError?: OnError<TTask, TContext>;\n  onIdle?: () => unknown;\n}): Queue<TTask> {\n  const queue = new PQueue(options) as Queue<TTask>;\n\n  if (onIdle) {\n    queue.on(\"idle\", () => onIdle());\n  }\n\n  const controller = new AbortController();\n  const signal = controller.signal;\n\n  // Override clear to also abort any pending tasks.\n  const superClear = queue.clear.bind(queue);\n  queue.clear = () => {\n    controller.abort();\n    superClear();\n  };\n\n  const retryTimeouts: number[] = retry.timeouts(\n    options?.retryTimeoutOptions ?? {\n      retries: 3,\n      factor: 2,\n      minTimeout: 100, // 100 ms\n    }\n  );\n\n  queue.addTask = async (task, taskOptions) => {\n    const priority = taskOptions?.priority ?? 0;\n\n    let retryTimeout: number | undefined = undefined;\n    if (taskOptions?.retry) {\n      task._retryCount ||= 0;\n      task._retryCount += 1;\n      if (task._retryCount > retryTimeouts.length) {\n        console.log(\"too many retries!!!\");\n        return;\n      } else {\n        retryTimeout = retryTimeouts[task._retryCount];\n      }\n    }\n\n    onAdd?.({ task, context, queue });\n\n    await queue.add(\n      async () => {\n        let result: TReturn;\n        if (retryTimeout) await setTimeout(retryTimeout, false, { signal });\n        try {\n          result = await worker({ task, context, queue });\n        } catch (error_) {\n          await onError?.({ error: error_ as Error, task, context, queue });\n          return;\n        }\n        await onComplete?.({ result, task, context, queue });\n      },\n      { priority }\n    );\n  };\n\n  queue.addTasks = async (tasks, taskOptions) => {\n    await Promise.all(\n      tasks.map(async (task) => {\n        const priority = taskOptions?.priority ?? 0;\n\n        let retryTimeout: number | undefined = undefined;\n        if (taskOptions?.retry) {\n          task._retryCount ||= 0;\n          task._retryCount += 1;\n          if (task._retryCount > retryTimeouts.length) {\n            console.log(\"too many retries!!!\");\n            return;\n          } else {\n            retryTimeout = retryTimeouts[task._retryCount];\n          }\n        }\n\n        onAdd?.({ task, context, queue });\n\n        await queue.add(\n          async () => {\n            let result: TReturn;\n            if (retryTimeout) await setTimeout(retryTimeout, false, { signal });\n            try {\n              result = await worker({ task, context, queue });\n            } catch (error_) {\n              await onError?.({ error: error_ as Error, task, context, queue });\n              return;\n            }\n            await onComplete?.({ result, task, context, queue });\n          },\n          { priority }\n        );\n      })\n    );\n  };\n\n  return queue;\n}\n","/**\n * Measures the elapsed wall clock time in milliseconds (ms) between two points.\n * @returns A function returning the elapsed time in milliseconds (ms).\n */\nexport function startClock() {\n  const start = process.hrtime();\n  return () => hrTimeToMs(process.hrtime(start));\n}\n\n/**\n * Converts a process.hrtime() measurement to milliseconds (ms).\n * @returns The timestamp in milliseconds (ms).\n */\nexport function hrTimeToMs(diff: [number, number]) {\n  return Math.round(diff[0] * 1000 + diff[1] / 1000000);\n}\n","// These methods are used in the cached interval calculations\n// From https://stackoverflow.com/a/33857786/12841788\n\n/* This method is just a small helper method that takes an array\n * and returns a new array with duplicates removed\n */\nfunction remove_duplicates(arr: number[][]) {\n  const lookup: Record<string, number> = {};\n  const results = [];\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i];\n    const key = el.toString();\n    if (lookup[key]) continue;\n    lookup[key] = 1;\n    results.push(el);\n  }\n  return results;\n}\n\n/* This method takes 2 points p1 and p2 and returns an array of\n * points with the range of p2 removed, i.e. p1 = [1,7]\n * p2 = [4,5] returned = [[1,3],[6,7]]\n */\nfunction p1_excluding_p2(p1: number[], p2: number[]) {\n  if (p1[1] < p2[0]) return [p1]; // line p1 finishes before the exclusion line p2\n  if (p1[0] > p2[1]) return [p1]; // line p1 starts after exclusion line p1\n  const lines = [];\n  // calculate p1 before p2 starts\n  const line1 = [p1[0], Math.min(p1[1], p2[0] - 1)];\n  if (line1[0] <= line1[1]) lines.push(line1);\n  // calculate p1 after p2 ends\n  const line2 = [p2[1] + 1, p1[1]];\n  if (line2[0] <= line2[1]) lines.push(line2);\n  // these contain the lines we calculated above\n  return lines;\n}\n\n/* this performs the exact same operation as above, only it allows you to pass\n * multiple points (but still just 1 exclusion point) and returns results\n * in an identical format as above, i.e. points = [[1,7],[0,1]]\n *  p2 = [4,5] returned = [[0,1],[1,3],[6,7]]\n */\nfunction points_excluding_p2(points: number[][], p2: number[]) {\n  const results: number[][] = [];\n  for (let i = 0; i < points.length; i++) {\n    const lines = p1_excluding_p2(points[i], p2);\n    results.push(...lines);\n  }\n  return results;\n}\n\n/**\n * Previously called p1_excluding_all.\n * this method performs the same operation only this time it takes one point\n * and multiple exclusion points and returns an array of the results.\n * this is the important method of: given 1 point and many\n * exclusion points, return the remaining new ranges\n */\nexport function findMissingIntervals(p1: number[], exclude: number[][]) {\n  let checking = [p1];\n  for (let i = 0; i < exclude.length; i++) {\n    checking = points_excluding_p2(checking, exclude[i]);\n  }\n  return remove_duplicates(checking);\n}\n","import path from \"node:path\";\nimport pc from \"picocolors\";\nimport pino, { type LevelWithSilent, type Logger } from \"pino\";\n\ntype LogOptions = { msg?: string; service?: string } & { [key: string]: any };\n\nexport class LoggerService {\n  private logger: Logger;\n\n  constructor({\n    level = \"info\",\n    dir,\n  }: { level?: LevelWithSilent; dir?: string } = {}) {\n    const streams: (pino.DestinationStream | pino.StreamEntry)[] = [];\n\n    if (level !== \"silent\") {\n      streams.push({\n        level,\n        stream: {\n          write(logString: string) {\n            const log = JSON.parse(logString);\n            const prettyLog = formatMessage(log);\n            console.log(prettyLog);\n\n            // If there is an \"error\" property, log the stack trace.\n            if (log.error?.stack) console.log(log.error.stack);\n            if (log.error?.meta) console.log(log.error.meta);\n\n            // TODO: Consider also logging any inner `cause` errors.\n            // if (log.error?.cause?.stack) {\n            //   console.log(\"Details:\");\n            //   console.log(\"  \" + log.error.cause.stack);\n            // }\n          },\n        },\n      });\n    }\n\n    if (dir) {\n      const logFile = path.join(dir, `${new Date().toISOString()}.log`);\n      streams.push({\n        level: \"trace\",\n        stream: pino.destination({ dest: logFile, sync: false, mkdir: true }),\n      });\n    }\n\n    this.logger = pino(\n      {\n        level: \"trace\",\n        serializers: { error: pino.stdSerializers.errWithCause },\n      },\n      pino.multistream(streams)\n    );\n  }\n\n  fatal = (options: LogOptions & { error?: Error }) => {\n    this.logger.fatal(options);\n  };\n  error = (options: LogOptions & { error: Error }) => {\n    this.logger.error(options);\n  };\n  warn = (options: LogOptions & { msg: string }) => {\n    this.logger.warn(options);\n  };\n  info = (options: LogOptions & { msg: string }) => {\n    this.logger.info(options);\n  };\n  debug = (options: LogOptions & { msg: string }) => {\n    this.logger.debug(options);\n  };\n  trace = (options: LogOptions & { msg: string }) => {\n    this.logger.trace(options);\n  };\n}\n\nconst levels = {\n  60: { label: \"FATAL\", colorize: (s: string) => pc.bgRed(s) },\n  50: { label: \"ERROR\", colorize: (s: string) => pc.red(s) },\n  40: { label: \"WARN \", colorize: (s: string) => pc.yellow(s) },\n  30: { label: \"INFO \", colorize: (s: string) => pc.green(s) },\n  20: { label: \"DEBUG\", colorize: (s: string) => pc.blue(s) },\n  10: { label: \"TRACE\", colorize: (s: string) => pc.gray(s) },\n} as const;\n\nconst formatMessage = (log: { [key: string]: any }) => {\n  let result = \"\";\n\n  const timestamp = log.time as number;\n  const level = levels[(log.level as keyof typeof levels) ?? 30];\n  const msg = log.msg as string | undefined;\n  const errorMessage = log.error?.message as string | undefined;\n  const message = msg ?? errorMessage;\n  const service = log.service as string | undefined;\n\n  const date = new Date(timestamp);\n  const hours = String(date.getUTCHours()).padStart(2, \"0\");\n  const minutes = String(date.getUTCMinutes()).padStart(2, \"0\");\n  const seconds = String(date.getUTCSeconds()).padStart(2, \"0\");\n  const millis = String(date.getUTCMilliseconds()).padStart(3, \"0\");\n  const time = `${hours}:${minutes}:${seconds}.${millis} `;\n\n  result += pc.isColorSupported ? pc.gray(time) : time;\n\n  result += pc.isColorSupported ? level.colorize(level.label) : level.label;\n\n  if (service) {\n    result += pc.isColorSupported\n      ? \" \" + pc.cyan(service.padEnd(10, \" \"))\n      : \" \" + service.padEnd(10, \" \");\n  }\n\n  result += pc.reset(` ${message}`);\n\n  return result;\n};\n","import prometheus from \"prom-client\";\n\nconst httpRequestBucketsInMs = [\n  5, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 150, 200, 250, 300, 350, 400, 450,\n  500, 750, 1_000, 2_000, 10_000,\n];\n\nconst httpRequestSizeInBytes = [\n  10, 50, 100, 250, 500, 1_000, 2_500, 5_000, 10_000, 50_000, 100_000, 250_000,\n  500_000, 1_000_000, 5_000_000, 10_000_000,\n];\n\nexport class MetricsService {\n  private registry: prometheus.Registry;\n\n  ponder_historical_scheduled_tasks: prometheus.Counter<\"network\" | \"kind\">;\n  ponder_historical_completed_tasks: prometheus.Counter<\n    \"network\" | \"kind\" | \"status\"\n  >;\n  ponder_historical_rpc_request_duration: prometheus.Histogram<\n    \"network\" | \"method\"\n  >;\n  ponder_historical_total_blocks: prometheus.Gauge<\"network\" | \"logFilter\">;\n  ponder_historical_cached_blocks: prometheus.Gauge<\"network\" | \"logFilter\">;\n  ponder_historical_completed_blocks: prometheus.Gauge<\"network\" | \"logFilter\">;\n  ponder_historical_completion_rate: prometheus.Gauge<\"network\" | \"logFilter\">;\n  ponder_historical_completion_eta: prometheus.Gauge<\"network\" | \"logFilter\">;\n\n  ponder_realtime_is_connected: prometheus.Gauge<\"network\">;\n  ponder_realtime_latest_block_number: prometheus.Gauge<\"network\">;\n  ponder_realtime_latest_block_timestamp: prometheus.Gauge<\"network\">;\n  ponder_realtime_rpc_request_duration: prometheus.Histogram<\n    \"network\" | \"method\"\n  >;\n\n  ponder_handlers_matched_events: prometheus.Gauge<\"eventName\">;\n  ponder_handlers_handled_events: prometheus.Gauge<\"eventName\">;\n  ponder_handlers_processed_events: prometheus.Gauge<\"eventName\">;\n  ponder_handlers_has_error: prometheus.Gauge;\n  ponder_handlers_latest_processed_timestamp: prometheus.Gauge;\n\n  ponder_server_port: prometheus.Gauge;\n  ponder_server_request_size: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_server_response_size: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n  ponder_server_response_duration: prometheus.Histogram<\n    \"method\" | \"path\" | \"status\"\n  >;\n\n  constructor() {\n    this.registry = new prometheus.Registry();\n\n    prometheus.collectDefaultMetrics({\n      register: this.registry,\n      prefix: \"ponder_default_\",\n    });\n\n    this.ponder_historical_scheduled_tasks = new prometheus.Counter({\n      name: \"ponder_historical_scheduled_tasks\",\n      help: \"Number of historical sync tasks that have been scheduled\",\n      labelNames: [\"network\", \"kind\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_completed_tasks = new prometheus.Counter({\n      name: \"ponder_historical_completed_tasks\",\n      help: \"Number of historical sync tasks that have been processed\",\n      labelNames: [\"network\", \"kind\", \"status\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_rpc_request_duration = new prometheus.Histogram({\n      name: \"ponder_historical_rpc_request_duration\",\n      help: \"Duration of RPC requests completed during the historical sync\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: httpRequestBucketsInMs,\n      registers: [this.registry],\n    });\n    this.ponder_historical_total_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_total_blocks\",\n      help: \"Number of blocks required for the historical sync\",\n      labelNames: [\"network\", \"logFilter\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_cached_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_cached_blocks\",\n      help: \"Number of blocks that were found in the cache for the historical sync\",\n      labelNames: [\"network\", \"logFilter\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_completed_blocks = new prometheus.Gauge({\n      name: \"ponder_historical_completed_blocks\",\n      help: \"Number of blocks that have been processed for the historical sync\",\n      labelNames: [\"network\", \"logFilter\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_completion_rate = new prometheus.Gauge({\n      name: \"ponder_historical_completion_rate\",\n      help: \"Completion rate (0 to 1) of the historical sync\",\n      labelNames: [\"network\", \"logFilter\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_historical_completion_eta = new prometheus.Gauge({\n      name: \"ponder_historical_completion_eta\",\n      help: \"Estimated number of milliseconds remaining to complete the historical sync\",\n      labelNames: [\"network\", \"logFilter\"] as const,\n      registers: [this.registry],\n    });\n\n    this.ponder_realtime_is_connected = new prometheus.Gauge({\n      name: \"ponder_realtime_is_connected\",\n      help: \"Boolean (0 or 1) indicating if the historical sync service is connected\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_latest_block_number = new prometheus.Gauge({\n      name: \"ponder_realtime_latest_block_number\",\n      help: \"Block number of the latest synced block\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_latest_block_timestamp = new prometheus.Gauge({\n      name: \"ponder_realtime_latest_block_timestamp\",\n      help: \"Block timestamp of the latest synced block\",\n      labelNames: [\"network\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_realtime_rpc_request_duration = new prometheus.Histogram({\n      name: \"ponder_realtime_rpc_request_duration\",\n      help: \"Duration of RPC requests completed during the realtime sync\",\n      labelNames: [\"network\", \"method\"] as const,\n      buckets: httpRequestBucketsInMs,\n      registers: [this.registry],\n    });\n\n    this.ponder_handlers_matched_events = new prometheus.Gauge({\n      name: \"ponder_handlers_matched_events\",\n      help: \"Number of available events for all log filters\",\n      labelNames: [\"eventName\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_handlers_handled_events = new prometheus.Gauge({\n      name: \"ponder_handlers_handled_events\",\n      help: \"Number of available events for which there is a handler function registered\",\n      labelNames: [\"eventName\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_handlers_processed_events = new prometheus.Gauge({\n      name: \"ponder_handlers_processed_events\",\n      help: \"Number of available events that have been processed\",\n      labelNames: [\"eventName\"] as const,\n      registers: [this.registry],\n    });\n    this.ponder_handlers_has_error = new prometheus.Gauge({\n      name: \"ponder_handlers_has_error\",\n      help: \"Boolean (0 or 1) indicating if an error was encountered while running handlers\",\n      registers: [this.registry],\n    });\n    this.ponder_handlers_latest_processed_timestamp = new prometheus.Gauge({\n      name: \"ponder_handlers_latest_processed_timestamp\",\n      help: \"Block timestamp of the latest processed event\",\n      registers: [this.registry],\n    });\n\n    this.ponder_server_port = new prometheus.Gauge({\n      name: \"ponder_server_port\",\n      help: \"Port that the server is listening on\",\n      registers: [this.registry],\n    });\n    this.ponder_server_request_size = new prometheus.Histogram({\n      name: \"ponder_server_request_size\",\n      help: \"Size of HTTP requests received by the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeInBytes,\n      registers: [this.registry],\n    });\n    this.ponder_server_response_size = new prometheus.Histogram({\n      name: \"ponder_server_response_size\",\n      help: \"Size of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeInBytes,\n      registers: [this.registry],\n    });\n    this.ponder_server_response_duration = new prometheus.Histogram({\n      name: \"ponder_server_response_duration\",\n      help: \"Duration of HTTP responses served the server\",\n      labelNames: [\"method\", \"path\", \"status\"] as const,\n      buckets: httpRequestSizeInBytes,\n      registers: [this.registry],\n    });\n  }\n\n  /**\n   * Get string representation for all metrics.\n   * @returns Metrics encoded using Prometheus v0.0.4 format.\n   */\n  async getMetrics() {\n    return await this.registry.metrics();\n  }\n}\n","import Emittery from \"emittery\";\nimport pLimit from \"p-limit\";\nimport { hexToNumber, numberToHex } from \"viem\";\n\nimport type { LogFilter } from \"@/config/logFilters\";\nimport type { Network } from \"@/config/networks\";\nimport { QueueError } from \"@/errors/queue\";\nimport type { EventStore } from \"@/event-store/store\";\nimport { Resources } from \"@/Ponder\";\nimport { poll } from \"@/utils/poll\";\nimport { type Queue, createQueue } from \"@/utils/queue\";\nimport { range } from \"@/utils/range\";\nimport { startClock } from \"@/utils/timer\";\n\nimport { isMatchedLogInBloomFilter } from \"./bloom\";\nimport { filterLogs } from \"./filter\";\nimport {\n  type BlockWithTransactions,\n  type LightBlock,\n  rpcBlockToLightBlock,\n} from \"./format\";\n\ntype RealtimeSyncEvents = {\n  realtimeCheckpoint: { timestamp: number };\n  finalityCheckpoint: { timestamp: number };\n  shallowReorg: { commonAncestorTimestamp: number };\n  deepReorg: { detectedAtBlockNumber: number; minimumDepth: number };\n  error: { error: Error };\n};\n\ntype RealtimeSyncStats = {\n  // Block number -> log filter name -> matched log count.\n  // Note that finalized blocks are removed from this object.\n  blocks: Record<\n    number,\n    {\n      bloom: {\n        hit: boolean;\n        falsePositive: boolean;\n      };\n      matchedLogCount: number;\n    }\n  >;\n};\n\ntype RealtimeBlockTask = BlockWithTransactions;\ntype RealtimeSyncQueue = Queue<RealtimeBlockTask>;\n\nexport class RealtimeSyncService extends Emittery<RealtimeSyncEvents> {\n  private resources: Resources;\n  private eventStore: EventStore;\n  private logFilters: LogFilter[];\n  private network: Network;\n\n  stats: RealtimeSyncStats;\n\n  // Queue of unprocessed blocks.\n  private queue: RealtimeSyncQueue;\n  // Block number of the current finalized block.\n  private finalizedBlockNumber = 0;\n  // Local representation of the unfinalized portion of the chain.\n  private blocks: LightBlock[] = [];\n  // Function to stop polling for new blocks.\n  private unpoll?: () => any | Promise<any>;\n\n  constructor({\n    resources,\n    eventStore,\n    logFilters,\n    network,\n  }: {\n    resources: Resources;\n    eventStore: EventStore;\n    logFilters: LogFilter[];\n    network: Network;\n  }) {\n    super();\n\n    this.resources = resources;\n    this.eventStore = eventStore;\n    this.logFilters = logFilters;\n    this.network = network;\n\n    this.queue = this.buildQueue();\n    this.stats = { blocks: {} };\n  }\n\n  setup = async () => {\n    // Fetch the latest block for the network.\n    const latestBlock = await this.getLatestBlock();\n\n    this.resources.logger.info({\n      service: \"realtime\",\n      msg: `Fetched latest block at ${hexToNumber(\n        latestBlock.number\n      )} (network=${this.network.name})`,\n    });\n\n    this.resources.metrics.ponder_realtime_is_connected.set(\n      { network: this.network.name },\n      1\n    );\n\n    // Set the finalized block number according to the network's finality threshold.\n    // If the finality block count is greater than the latest block number, set to zero.\n    const finalizedBlockNumber = Math.max(\n      0,\n      hexToNumber(latestBlock.number) - this.network.finalityBlockCount\n    );\n    this.finalizedBlockNumber = finalizedBlockNumber;\n\n    // Add the latest block to the unfinalized block queue.\n    // The queue won't start immediately; see syncUnfinalizedData for details.\n    const priority = Number.MAX_SAFE_INTEGER - hexToNumber(latestBlock.number);\n    this.queue.addTask(latestBlock, { priority });\n\n    return { finalizedBlockNumber };\n  };\n\n  start = async () => {\n    // If an endBlock is specified for every log filter on this network, and the\n    // latest end blcock is less than the finalized block number, we can stop here.\n    // The service won't poll for new blocks and won't emit any events.\n    const endBlocks = this.logFilters.map((f) => f.filter.endBlock);\n    if (\n      endBlocks.every(\n        (endBlock) =>\n          endBlock !== undefined && endBlock < this.finalizedBlockNumber\n      )\n    ) {\n      this.resources.logger.warn({\n        service: \"realtime\",\n        msg: `No realtime log filters found (network=${this.network.name})`,\n      });\n      this.resources.metrics.ponder_realtime_is_connected.set(\n        { network: this.network.name },\n        0\n      );\n      return;\n    }\n\n    // If the latest block was not added to the queue, setup was not completed successfully.\n    if (this.queue.size === 0) {\n      throw new Error(\n        `Unable to start. Must call setup() method before start().`\n      );\n    }\n\n    // Fetch the block at the finalized block number.\n    const stopClock = startClock();\n    const finalizedBlock = await this.network.client.request({\n      method: \"eth_getBlockByNumber\",\n      params: [numberToHex(this.finalizedBlockNumber), false],\n    });\n    if (!finalizedBlock) throw new Error(`Unable to fetch finalized block`);\n    this.resources.metrics.ponder_realtime_rpc_request_duration.observe(\n      {\n        method: \"eth_getBlockByNumber\",\n        network: this.network.name,\n      },\n      stopClock()\n    );\n\n    this.resources.logger.info({\n      service: \"realtime\",\n      msg: `Fetched finalized block at ${hexToNumber(\n        finalizedBlock.number!\n      )} (network=${this.network.name})`,\n    });\n\n    // Add the finalized block as the first element of the list of unfinalized blocks.\n    this.blocks.push(rpcBlockToLightBlock(finalizedBlock));\n\n    // The latest block was already added to the unfinalized block queue during setup(),\n    // so here all we need to do is start the queue.\n    this.queue.start();\n\n    // Add an empty task the queue (the worker will fetch the latest block).\n    // TODO: optimistically optimize latency here using filters or subscriptions.\n    this.unpoll = poll(\n      async () => {\n        await this.addNewLatestBlock();\n      },\n      {\n        emitOnBegin: false,\n        interval: this.network.pollingInterval,\n      }\n    );\n  };\n\n  kill = async () => {\n    this.unpoll?.();\n    this.queue.pause();\n    this.queue.clear();\n    // TODO: Figure out if it's necessary to wait for the queue to be idle before killing it.\n    // await this.onIdle();\n\n    this.resources.logger.debug({\n      service: \"realtime\",\n      msg: `Killed realtime sync service (network=${this.network.name})`,\n    });\n  };\n\n  onIdle = async () => {\n    await this.queue.onIdle();\n  };\n\n  private getLatestBlock = async () => {\n    // Fetch the latest block for the network.\n    const stopClock = startClock();\n    const latestBlock_ = await this.network.client.request({\n      method: \"eth_getBlockByNumber\",\n      params: [\"latest\", true],\n    });\n    if (!latestBlock_) throw new Error(`Unable to fetch latest block`);\n    this.resources.metrics.ponder_realtime_rpc_request_duration.observe(\n      {\n        method: \"eth_getBlockByNumber\",\n        network: this.network.name,\n      },\n      stopClock()\n    );\n    return latestBlock_ as BlockWithTransactions;\n  };\n\n  addNewLatestBlock = async () => {\n    const block = await this.getLatestBlock();\n    const priority = Number.MAX_SAFE_INTEGER - hexToNumber(block.number);\n    this.queue.addTask(block, { priority });\n  };\n\n  private buildQueue = () => {\n    const queue = createQueue<RealtimeBlockTask>({\n      worker: async ({ task }: { task: RealtimeBlockTask }) => {\n        await this.blockTaskWorker(task);\n      },\n      options: { concurrency: 1, autoStart: false },\n      onError: ({ error, task }) => {\n        const queueError = new QueueError({\n          queueName: \"Realtime sync queue\",\n          task: {\n            hash: task.hash,\n            parentHash: task.parentHash,\n            number: task.number,\n            timestamp: task.timestamp,\n            transactionCount: task.transactions.length,\n          },\n          cause: error,\n        });\n        this.emit(\"error\", { error: queueError });\n\n        // Default to a retry (uses the retry options passed to the queue).\n        // queue.addTask(task, { retry: true });\n      },\n    });\n\n    return queue;\n  };\n\n  private blockTaskWorker = async (block: BlockWithTransactions) => {\n    const previousHeadBlock = this.blocks[this.blocks.length - 1];\n\n    // If no block is passed, fetch the latest block.\n    const newBlockWithTransactions = block;\n    const newBlock = rpcBlockToLightBlock(newBlockWithTransactions);\n\n    // 1) We already saw and handled this block. No-op.\n    if (this.blocks.find((b) => b.hash === newBlock.hash)) {\n      this.resources.logger.debug({\n        service: \"realtime\",\n        msg: `Already processed block at ${newBlock.number} (network=${this.network.name})`,\n      });\n      return;\n    }\n\n    // 2) This is the new head block (happy path). Yay!\n    if (\n      newBlock.number == previousHeadBlock.number + 1 &&\n      newBlock.parentHash == previousHeadBlock.hash\n    ) {\n      // First, check if the new block _might_ contain any logs that match the registered filters.\n      const isMatchedLogPresentInBlock = isMatchedLogInBloomFilter({\n        bloom: newBlockWithTransactions.logsBloom!,\n        logFilters: this.logFilters.map((l) => l.filter),\n      });\n\n      let matchedLogCount = 0;\n\n      if (isMatchedLogPresentInBlock) {\n        // If there's a potential match, fetch the logs from the block.\n        const stopClock = startClock();\n        const logs = await this.network.client.request({\n          method: \"eth_getLogs\",\n          params: [\n            {\n              blockHash: newBlock.hash,\n            },\n          ],\n        });\n        this.resources.metrics.ponder_realtime_rpc_request_duration.observe(\n          {\n            method: \"eth_getLogs\",\n            network: this.network.name,\n          },\n          stopClock()\n        );\n\n        // Filter logs down to those that actually match the registered filters.\n        const filteredLogs = filterLogs({\n          logs,\n          logFilters: this.logFilters.map((l) => l.filter),\n        });\n        matchedLogCount = filteredLogs.length;\n\n        // Filter transactions down to those that are required by the matched logs.\n        const requiredTransactionHashes = new Set(\n          filteredLogs.map((l) => l.transactionHash)\n        );\n        const filteredTransactions =\n          newBlockWithTransactions.transactions.filter((t) =>\n            requiredTransactionHashes.has(t.hash)\n          );\n\n        // If there are indeed any matched logs, insert them into the store.\n        if (filteredLogs.length > 0) {\n          await this.eventStore.insertUnfinalizedBlock({\n            chainId: this.network.chainId,\n            block: newBlockWithTransactions,\n            transactions: filteredTransactions,\n            logs: filteredLogs,\n          });\n        }\n      }\n\n      this.emit(\"realtimeCheckpoint\", {\n        timestamp: hexToNumber(newBlockWithTransactions.timestamp),\n      });\n\n      // Add this block the local chain.\n      this.blocks.push(newBlock);\n\n      this.resources.metrics.ponder_realtime_latest_block_number.set(\n        { network: this.network.name },\n        newBlock.number\n      );\n      this.resources.metrics.ponder_realtime_latest_block_timestamp.set(\n        { network: this.network.name },\n        newBlock.timestamp\n      );\n\n      this.resources.logger.debug({\n        service: \"realtime\",\n        msg: `Processed new head block at ${newBlock.number} (network=${this.network.name})`,\n      });\n\n      if (matchedLogCount > 0) {\n        this.resources.logger.info({\n          service: \"realtime\",\n          msg: `Found ${\n            matchedLogCount === 1\n              ? \"1 matched log\"\n              : `${matchedLogCount} matched logs`\n          } in new head block ${newBlock.number} (network=${\n            this.network.name\n          })`,\n        });\n      }\n\n      this.stats.blocks[newBlock.number] = {\n        bloom: {\n          hit: isMatchedLogPresentInBlock,\n          falsePositive: isMatchedLogPresentInBlock && matchedLogCount === 0,\n        },\n        matchedLogCount,\n      };\n\n      // If this block moves the finality checkpoint, remove now-finalized blocks from the local chain\n      // and mark data as finalized in the store.\n      if (\n        newBlock.number >\n        this.finalizedBlockNumber + 2 * this.network.finalityBlockCount\n      ) {\n        const newFinalizedBlock = this.blocks.find(\n          (block) =>\n            block.number ===\n            this.finalizedBlockNumber + this.network.finalityBlockCount\n        )!;\n\n        // Remove now-finalized blocks from the local chain (except for the block at newFinalizedBlockNumber).\n        this.blocks = this.blocks.filter(\n          (block) => block.number >= newFinalizedBlock.number\n        );\n\n        // Clean up metrics for now-finalized blocks.\n        for (const blockNumber in this.stats.blocks) {\n          if (Number(blockNumber) < newFinalizedBlock.number) {\n            delete this.stats.blocks[blockNumber];\n          }\n        }\n\n        await this.eventStore.finalizeData({\n          chainId: this.network.chainId,\n          toBlockNumber: newFinalizedBlock.number,\n        });\n\n        this.finalizedBlockNumber = newFinalizedBlock.number;\n\n        this.emit(\"finalityCheckpoint\", {\n          timestamp: newFinalizedBlock.timestamp,\n        });\n\n        this.resources.logger.debug({\n          service: \"realtime\",\n          msg: `Updated finality checkpoint to ${newFinalizedBlock.number} (network=${this.network.name})`,\n          matchedLogCount,\n        });\n      }\n\n      return;\n    }\n\n    // 3) At least one block is missing. Note that this is the happy path for the first task after setup.\n    if (newBlock.number > previousHeadBlock.number + 1) {\n      const missingBlockNumbers = range(\n        previousHeadBlock.number + 1,\n        newBlock.number\n      );\n\n      // Fetch all missing blocks using a request concurrency limit of 10.\n      const limit = pLimit(10);\n\n      const missingBlockRequests = missingBlockNumbers.map((number) => {\n        return limit(async () => {\n          const stopClock = startClock();\n          const block = await this.network.client.request({\n            method: \"eth_getBlockByNumber\",\n            params: [numberToHex(number), true],\n          });\n          if (!block) {\n            throw new Error(`Failed to fetch block number: ${number}`);\n          }\n          this.resources.metrics.ponder_realtime_rpc_request_duration.observe(\n            {\n              method: \"eth_getBlockByNumber\",\n              network: this.network.name,\n            },\n            stopClock()\n          );\n          return block as BlockWithTransactions;\n        });\n      });\n\n      const missingBlocks = await Promise.all(missingBlockRequests);\n\n      // Add blocks to the queue from oldest to newest. Include the current block.\n      for (const block of [...missingBlocks, newBlockWithTransactions]) {\n        const priority = Number.MAX_SAFE_INTEGER - hexToNumber(block.number);\n        this.queue.addTask(block, { priority });\n      }\n\n      this.resources.logger.info({\n        service: \"realtime\",\n        msg: `Fetched unfinalized block range [${missingBlockNumbers[0]}, ${\n          missingBlockNumbers[missingBlockNumbers.length - 1]\n        }] (network=${this.network.name})`,\n      });\n\n      return;\n    }\n\n    // 4) There has been a reorg, because:\n    //   a) newBlock.number <= headBlock + 1.\n    //   b) newBlock.hash is not found in our local chain.\n    // which means newBlock is on a fork of our local chain.\n    //\n    // To reconcile, traverse up the remote (canonical) chain until we find the first\n    // block that is present in both chains (the common ancestor block).\n\n    // Store the block objects as we fetch them.\n    // Once we find the common ancestor, we will add these blocks to the queue.\n    const canonicalBlocksWithTransactions = [newBlockWithTransactions];\n\n    // Keep track of the current canonical block\n    let canonicalBlock = newBlock;\n    let depth = 0;\n\n    while (canonicalBlock.number > this.finalizedBlockNumber) {\n      const commonAncestorBlock = this.blocks.find(\n        (b) => b.hash === canonicalBlock.parentHash\n      );\n\n      // If the common ancestor block is present in our local chain, this is a short reorg.\n      if (commonAncestorBlock) {\n        // Remove all non-canonical blocks from the local chain.\n        this.blocks = this.blocks.filter(\n          (block) => block.number <= commonAncestorBlock.number\n        );\n\n        await this.eventStore.deleteUnfinalizedData({\n          chainId: this.network.chainId,\n          fromBlockNumber: commonAncestorBlock.number + 1,\n        });\n\n        // Clear the queue of all blocks (some might be from the non-canonical chain).\n        // TODO: Figure out if this is indeed required by some edge case.\n        this.queue.clear();\n\n        // Add blocks from the canonical chain (they've already been fetched).\n        for (const block of canonicalBlocksWithTransactions) {\n          const priority = Number.MAX_SAFE_INTEGER - hexToNumber(block.number);\n          this.queue.addTask(block, { priority });\n        }\n\n        // Also add a new latest block, so we don't have to wait for the next poll to\n        // start fetching any newer blocks on the canonical chain.\n        await this.addNewLatestBlock();\n        this.emit(\"shallowReorg\", {\n          commonAncestorTimestamp: commonAncestorBlock.timestamp,\n        });\n\n        this.resources.logger.info({\n          service: \"realtime\",\n          msg: `Reconciled ${depth}-block reorg with common ancestor block ${commonAncestorBlock.number} (network=${this.network.name})`,\n        });\n\n        return;\n      }\n\n      // If the parent block is not present in our local chain, keep traversing up the canonical chain.\n      const stopClock = startClock();\n      const parentBlock_ = await this.network.client.request({\n        method: \"eth_getBlockByHash\",\n        params: [canonicalBlock.parentHash, true],\n      });\n      this.resources.metrics.ponder_realtime_rpc_request_duration.observe(\n        {\n          method: \"eth_getBlockByHash\",\n          network: this.network.name,\n        },\n        stopClock()\n      );\n\n      if (!parentBlock_)\n        throw new Error(\n          `Failed to fetch parent block with hash: ${canonicalBlock.parentHash}`\n        );\n\n      canonicalBlocksWithTransactions.unshift(\n        parentBlock_ as BlockWithTransactions\n      );\n      depth += 1;\n      canonicalBlock = rpcBlockToLightBlock(parentBlock_);\n    }\n\n    // 5) If the common ancestor was not found in our local chain, this is a deep reorg.\n    this.emit(\"deepReorg\", {\n      detectedAtBlockNumber: newBlock.number,\n      minimumDepth: depth,\n    });\n\n    this.resources.logger.warn({\n      service: \"realtime\",\n      msg: `Unable to reconcile >${depth}-block reorg (network=${this.network.name})`,\n    });\n  };\n}\n","/** Waits a specified amount of time.\n *\n * @param milliseconds Number of milliseconds to wait.\n */\nexport async function wait(milliseconds: number) {\n  return new Promise<void>((res) => setTimeout(res, milliseconds));\n}\n","import { wait } from \"./wait\";\n\n// Adapted from viem.\n// https://github.com/wagmi-dev/viem/blob/38422ac7617022761ee7aa87310dd89adb34573c/src/utils/poll.ts\n\ntype PollOptions = {\n  // Whether or not to emit when the polling starts.\n  emitOnBegin?: boolean;\n  // The interval (in ms).\n  interval: number;\n};\n\n/**\n * @description Polls a function at a specified interval.\n */\nexport function poll(\n  fn: ({ unpoll }: { unpoll: () => void }) => Promise<unknown> | unknown,\n  { emitOnBegin, interval }: PollOptions\n) {\n  let active = true;\n\n  const unwatch = () => (active = false);\n\n  const watch = async () => {\n    if (emitOnBegin) await fn({ unpoll: unwatch });\n    await wait(interval);\n\n    const poll = async () => {\n      if (!active) return;\n      await fn({ unpoll: unwatch });\n      await wait(interval);\n      poll();\n    };\n\n    poll();\n  };\n  watch();\n\n  return unwatch;\n}\n","//\n\n/**\n * Generates an array of integers between two bounds. Exclusive on the right.\n *\n * @param start Integer to start at.\n * @param stop Integer to stop at (exclusive).\n */\nexport const range = (start: number, stop: number) =>\n  Array.from({ length: stop - start }, (_, i) => start + i);\n","import {\n  isContractAddressInBloom,\n  isTopicInBloom,\n} from \"ethereum-bloom-filters\";\nimport { Address, Hex } from \"viem\";\n\nexport function isMatchedLogInBloomFilter({\n  bloom,\n  logFilters,\n}: {\n  bloom: Hex;\n  logFilters: {\n    address?: Address | Address[];\n    topics?: (Hex | Hex[] | null)[];\n  }[];\n}) {\n  const allAddresses: Address[] = [];\n  logFilters.forEach((logFilter) => {\n    const address =\n      logFilter.address === undefined\n        ? []\n        : Array.isArray(logFilter.address)\n        ? logFilter.address\n        : [logFilter.address];\n    allAddresses.push(...address);\n  });\n  if (allAddresses.some((a) => isContractAddressInBloom(bloom, a))) {\n    return true;\n  }\n\n  const allTopics: Hex[] = [];\n  logFilters.forEach((logFilter) => {\n    logFilter.topics?.forEach((topic) => {\n      if (topic === null) return;\n      if (Array.isArray(topic)) allTopics.push(...topic);\n      else allTopics.push(topic);\n    });\n  });\n  if (allTopics.some((a) => isTopicInBloom(bloom, a))) {\n    return true;\n  }\n\n  return false;\n}\n","import { Address, Hex, RpcLog } from \"viem\";\n\nexport function filterLogs({\n  logs,\n  logFilters,\n}: {\n  logs: RpcLog[];\n  logFilters: {\n    address?: Address | Address[];\n    topics?: (Hex | Hex[] | null)[];\n  }[];\n}) {\n  return logs.filter((log) => {\n    for (const { address, topics } of logFilters) {\n      if (!isLogMatchedByFilter({ log, address, topics })) return false;\n    }\n    return true;\n  });\n}\n\nexport function isLogMatchedByFilter({\n  log,\n  address,\n  topics,\n}: {\n  log: {\n    address: Address;\n    topics: Hex[];\n  };\n  address?: Address | Address[];\n  topics?: (Hex | Hex[] | null)[];\n}) {\n  if (address) {\n    if (Array.isArray(address)) {\n      if (!address.includes(log.address)) return false;\n    } else {\n      if (log.address !== address) return false;\n    }\n  }\n\n  if (topics) {\n    for (const [index, topic] of topics.entries()) {\n      if (topic === null) continue;\n      if (Array.isArray(topic)) {\n        if (!topic.includes(log.topics[index])) return false;\n      } else {\n        if (log.topics[index] !== topic) return false;\n      }\n    }\n  }\n\n  return true;\n}\n","import { type Hash, type RpcBlock, hexToNumber, RpcTransaction } from \"viem\";\n\nimport { Prettify } from \"@/types/utils\";\n\nexport type LightBlock = {\n  hash: Hash;\n  parentHash: Hash;\n  number: number;\n  timestamp: number;\n};\n\nexport function rpcBlockToLightBlock(block: RpcBlock): LightBlock {\n  return {\n    hash: block.hash!,\n    parentHash: block.parentHash,\n    number: hexToNumber(block.number!),\n    timestamp: hexToNumber(block.timestamp),\n  };\n}\n\nexport type BlockWithTransactions = Prettify<\n  Omit<RpcBlock, \"hash\" | \"transactions\"> & {\n    hash: Hash;\n    number: Hash;\n    transactions: RpcTransaction[];\n  }\n>;\n","import cors from \"cors\";\nimport express from \"express\";\nimport { graphqlHTTP } from \"express-graphql\";\nimport type { GraphQLSchema } from \"graphql\";\nimport { createHttpTerminator } from \"http-terminator\";\nimport { createServer, Server } from \"node:http\";\n\nimport { Resources } from \"@/Ponder\";\nimport { UserStore } from \"@/user-store/store\";\nimport { startClock } from \"@/utils/timer\";\n\nexport class ServerService {\n  private resources: Resources;\n  private userStore: UserStore;\n\n  private port: number;\n  app?: express.Express;\n\n  private terminate?: () => Promise<void>;\n  private graphqlMiddleware?: express.Handler;\n\n  isHistoricalEventProcessingComplete = false;\n\n  constructor({\n    resources,\n    userStore,\n  }: {\n    resources: Resources;\n    userStore: UserStore;\n  }) {\n    this.resources = resources;\n    this.userStore = userStore;\n    this.port = this.resources.options.port;\n  }\n\n  async start() {\n    this.app = express();\n    this.app.use(cors());\n\n    this.app.use((req, res, next) => {\n      const endClock = startClock();\n      res.on(\"finish\", () => {\n        const responseDuration = endClock();\n        const method = req.method;\n        const path = new URL(req.url, `http://${req.get(\"host\")}`).pathname;\n        const status =\n          res.statusCode >= 200 && res.statusCode < 300\n            ? \"2XX\"\n            : res.statusCode >= 300 && res.statusCode < 400\n            ? \"3XX\"\n            : res.statusCode >= 400 && res.statusCode < 500\n            ? \"4XX\"\n            : \"5XX\";\n\n        const requestSize = Number(req.get(\"Content-Length\") ?? 0);\n        this.resources.metrics.ponder_server_request_size.observe(\n          { method, path, status },\n          Number(requestSize)\n        );\n\n        const responseSize = Number(res.get(\"Content-Length\") ?? 0);\n        this.resources.metrics.ponder_server_response_size.observe(\n          { method, path, status },\n          Number(responseSize)\n        );\n\n        this.resources.metrics.ponder_server_response_duration.observe(\n          { method, path, status },\n          responseDuration\n        );\n      });\n      next();\n    });\n\n    const server = await new Promise<Server>((resolve, reject) => {\n      const server = createServer(this.app)\n        .on(\"error\", (error) => {\n          if ((error as any).code === \"EADDRINUSE\") {\n            this.resources.logger.warn({\n              service: \"server\",\n              msg: `Port ${this.port} was in use, trying port ${this.port + 1}`,\n            });\n            this.port += 1;\n            setTimeout(() => {\n              server.close();\n              server.listen(this.port);\n            }, 5);\n          } else {\n            reject(error);\n          }\n        })\n        .on(\"listening\", () => {\n          this.resources.metrics.ponder_server_port.set(this.port);\n          resolve(server);\n        })\n        .listen(this.port);\n    });\n\n    const terminator = createHttpTerminator({ server });\n    this.terminate = () => terminator.terminate();\n\n    this.resources.logger.info({\n      service: \"server\",\n      msg: `Started listening on port ${this.port}`,\n    });\n\n    this.app.post(\"/metrics\", async (_, res) => {\n      try {\n        res.set(\"Content-Type\", \"text/plain; version=0.0.4; charset=utf-8\");\n        res.end(await this.resources.metrics.getMetrics());\n      } catch (error) {\n        res.status(500).end(error);\n      }\n    });\n\n    this.app.get(\"/metrics\", async (_, res) => {\n      try {\n        res.set(\"Content-Type\", \"text/plain; version=0.0.4; charset=utf-8\");\n        res.end(await this.resources.metrics.getMetrics());\n      } catch (error) {\n        res.status(500).end(error);\n      }\n    });\n\n    // By default, the server will respond as unhealthy until historical events have\n    // been processed OR 4.5 minutes have passed since the app was created. This\n    // enables zero-downtime deployments on PaaS platforms like Railway and Render.\n    // Also see https://github.com/0xOlias/ponder/issues/24\n    this.app.get(\"/health\", (_, res) => {\n      if (this.isHistoricalEventProcessingComplete) {\n        return res.status(200).send();\n      }\n\n      const max = this.resources.options.maxHealthcheckDuration;\n      const elapsed = Math.floor(process.uptime());\n\n      if (elapsed > max) {\n        this.resources.logger.warn({\n          service: \"server\",\n          msg: `Historical sync duration has exceeded the max healthcheck duration of ${max} seconds (current: ${elapsed}). Sevice is now responding as healthy and may serve incomplete data.`,\n        });\n        return res.status(200).send();\n      }\n\n      return res.status(503).send();\n    });\n  }\n\n  reload({ graphqlSchema }: { graphqlSchema: GraphQLSchema }) {\n    // This uses a small hack to update the GraphQL server on the fly.\n    const graphqlMiddleware = graphqlHTTP({\n      schema: graphqlSchema,\n      context: { store: this.userStore },\n      graphiql: true,\n    });\n\n    this.app?.use(\"/\", graphqlMiddleware);\n  }\n\n  async kill() {\n    await this.terminate?.();\n    this.resources.logger.debug({\n      service: \"server\",\n      msg: `Stopped listening on port ${this.port}`,\n    });\n  }\n\n  setIsHistoricalEventProcessingComplete() {\n    this.isHistoricalEventProcessingComplete = true;\n\n    this.resources.logger.info({\n      service: \"server\",\n      msg: `Started responding as healthy`,\n    });\n  }\n}\n","import { Box, Newline, render as inkRender, Text } from \"ink\";\nimport React from \"react\";\n\nimport { LogFilter } from \"@/config/logFilters\";\n\nimport { HandlersBar } from \"./HandlersBar\";\nimport { HistoricalBar } from \"./HistoricalBar\";\n\nexport type UiState = {\n  port: number;\n\n  historicalSyncLogFilterStats: Record<\n    string,\n    {\n      rate: number;\n      eta?: number;\n    }\n  >;\n\n  isHistoricalSyncComplete: boolean;\n\n  handlerError: boolean;\n  handlersCurrent: number;\n  handlersTotal: number;\n  handlersHandledTotal: number;\n  handlersToTimestamp: number;\n\n  networks: string[];\n};\n\nexport const buildUiState = ({ logFilters }: { logFilters: LogFilter[] }) => {\n  const ui: UiState = {\n    port: 0,\n\n    historicalSyncLogFilterStats: {},\n\n    isHistoricalSyncComplete: false,\n\n    handlerError: false,\n    handlersCurrent: 0,\n    handlersTotal: 0,\n    handlersHandledTotal: 0,\n    handlersToTimestamp: 0,\n\n    networks: [],\n  };\n\n  logFilters.forEach((logFilter) => {\n    ui.historicalSyncLogFilterStats[logFilter.name] = {\n      rate: 0,\n    };\n  });\n\n  return ui;\n};\n\nconst App = (ui: UiState) => {\n  const {\n    port,\n    historicalSyncLogFilterStats,\n    isHistoricalSyncComplete,\n    handlersCurrent,\n    handlerError,\n    networks,\n  } = ui;\n\n  if (handlerError) {\n    return (\n      <Box flexDirection=\"column\">\n        <Text> </Text>\n        <Text color=\"cyan\">\n          Resolve the error and save your changes to reload the server.\n        </Text>\n      </Box>\n    );\n  }\n\n  return (\n    <Box flexDirection=\"column\">\n      {/* Newline above interface */}\n      <Text> </Text>\n      <Box flexDirection=\"row\">\n        <Text bold={true}>Historical sync </Text>\n        {isHistoricalSyncComplete ? (\n          <Text color=\"green\">\n            (complete)\n            <Newline />\n          </Text>\n        ) : (\n          <Text color=\"yellow\">(in progress)</Text>\n        )}\n      </Box>\n      {!isHistoricalSyncComplete && (\n        <Box flexDirection=\"column\">\n          {Object.entries(historicalSyncLogFilterStats).map(\n            ([logFilterName, stat]) => (\n              <HistoricalBar\n                key={logFilterName}\n                title={logFilterName}\n                stat={stat}\n              />\n            )\n          )}\n          <Text> </Text>\n        </Box>\n      )}\n\n      <HandlersBar ui={ui} />\n\n      {networks.length > 0 && (\n        <Box flexDirection=\"column\">\n          <Text bold={true}>Networks</Text>\n          {networks.map((network) => (\n            <Box flexDirection=\"row\" key={network}>\n              <Text>\n                {network.slice(0, 1).toUpperCase() + network.slice(1)} (live)\n              </Text>\n            </Box>\n          ))}\n          <Text> </Text>\n        </Box>\n      )}\n\n      {handlersCurrent > 0 && (\n        <Box flexDirection=\"column\">\n          <Text bold={true}>GraphQL </Text>\n          <Box flexDirection=\"row\">\n            <Text>Server live at http://localhost:{port}</Text>\n          </Box>\n        </Box>\n      )}\n    </Box>\n  );\n};\n\nexport const setupInkApp = (ui: UiState) => {\n  const { rerender, unmount: inkUnmount, clear } = inkRender(<App {...ui} />);\n\n  const render = (ui: UiState) => {\n    rerender(<App {...ui} />);\n  };\n\n  const unmount = () => {\n    clear();\n    inkUnmount();\n  };\n  return { render, unmount };\n};\n","import { Box, Text } from \"ink\";\nimport React from \"react\";\n\nimport { UiState } from \"./app\";\nimport { ProgressBar } from \"./ProgressBar\";\n\nexport const HandlersBar = ({ ui }: { ui: UiState }) => {\n  const completionRate =\n    ui.handlersCurrent / Math.max(ui.handlersHandledTotal, 1);\n  const completionDecimal = Math.round(completionRate * 1000) / 10;\n  const completionText =\n    Number.isInteger(completionDecimal) && completionDecimal < 100\n      ? `${completionDecimal}.0%`\n      : `${completionDecimal}%`;\n\n  const date = new Date(ui.handlersToTimestamp * 1000);\n  const year = date.getFullYear();\n  const months = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\",\n  ];\n  const month = months[date.getMonth()];\n  const day = date.getDate();\n  const dateText = `${month} ${day}, ${year}`;\n\n  const isUpToDate =\n    ui.isHistoricalSyncComplete &&\n    ui.handlersCurrent === ui.handlersHandledTotal;\n  const isStarted = ui.handlersToTimestamp > 0;\n\n  const titleText = () => {\n    if (isUpToDate) return <Text color=\"green\">(up to date)</Text>;\n    if (isStarted)\n      return (\n        <Text color=\"yellow\">\n          (up to {ui.handlersToTimestamp === 0 ? \"\" : dateText})\n        </Text>\n      );\n    return <Text>(not started)</Text>;\n  };\n\n  const countText = () => {\n    if (isUpToDate)\n      return (\n        <Text>\n          {\" \"}\n          | {ui.handlersCurrent}/{ui.handlersHandledTotal} events (\n          {ui.handlersTotal} total)\n        </Text>\n      );\n    if (isStarted)\n      return (\n        <Text>\n          {\" \"}\n          | {ui.handlersCurrent}/\n          {\"?\".repeat(ui.handlersCurrent.toString().length)} events (\n          {ui.handlersTotal} total)\n        </Text>\n      );\n    return null;\n  };\n\n  return (\n    <Box flexDirection=\"column\">\n      <Box flexDirection=\"row\">\n        <Text bold={true}>Event handlers </Text>\n        <Text>{titleText()}</Text>\n      </Box>\n      {/* {!isUpToDate && ( */}\n      <Box flexDirection=\"row\">\n        <ProgressBar\n          current={ui.handlersCurrent}\n          end={Math.max(ui.handlersHandledTotal, 1)}\n        />\n        <Text>\n          {\" \"}\n          {completionText}\n          {countText()}\n        </Text>\n      </Box>\n      {/* )} */}\n\n      <Text> </Text>\n    </Box>\n  );\n};\n","import { Text } from \"ink\";\nimport React from \"react\";\n\nexport const ProgressBar = ({ current = 5, end = 10, width = 36 }) => {\n  const maxCount = width || process.stdout.columns || 80;\n\n  const fraction = current / end;\n  const count = Math.min(Math.floor(maxCount * fraction), maxCount);\n\n  return (\n    <Text>\n      <Text>{\"█\".repeat(count)}</Text>\n      <Text>{\"░\".repeat(maxCount - count)}</Text>\n    </Text>\n  );\n};\n","import { Box, Text } from \"ink\";\nimport React from \"react\";\n\nimport { formatEta, formatPercentage } from \"@/utils/format\";\n\nimport { UiState } from \"./app\";\nimport { ProgressBar } from \"./ProgressBar\";\n\nexport const HistoricalBar = ({\n  title,\n  stat,\n}: {\n  title: string;\n  stat: UiState[\"historicalSyncLogFilterStats\"][0];\n}) => {\n  const { rate, eta } = stat;\n\n  const etaText = eta ? ` | ~${formatEta(eta)}` : null;\n\n  const rateText = formatPercentage(rate);\n\n  return (\n    <Box flexDirection=\"column\">\n      <Text>{title}</Text>\n      <Box flexDirection=\"row\">\n        <ProgressBar current={rate} end={1} />\n        <Text>\n          {\" \"}\n          {rateText}\n          {etaText}\n        </Text>\n      </Box>\n      {/* <Text> </Text> */}\n    </Box>\n  );\n};\n","import { LogFilter } from \"@/config/logFilters\";\nimport { Resources } from \"@/Ponder\";\n\nimport { buildUiState, setupInkApp, UiState } from \"./app\";\n\nexport class UiService {\n  private resources: Resources;\n  private logFilters: LogFilter[];\n\n  ui: UiState;\n  renderInterval: NodeJS.Timer;\n  render: () => void;\n  unmount: () => void;\n\n  constructor({\n    resources,\n    logFilters,\n  }: {\n    resources: Resources;\n    logFilters: LogFilter[];\n  }) {\n    this.resources = resources;\n    this.logFilters = logFilters;\n\n    this.ui = buildUiState({ logFilters: this.logFilters });\n\n    if (this.resources.options.uiEnabled) {\n      const { render, unmount } = setupInkApp(this.ui);\n      this.render = () => render(this.ui);\n      this.unmount = unmount;\n    } else {\n      this.render = () => undefined;\n      this.unmount = () => undefined;\n    }\n\n    this.renderInterval = setInterval(async () => {\n      const logFilterNames = Object.keys(this.ui.historicalSyncLogFilterStats);\n\n      // Historical sync\n      const rateMetric = (\n        await this.resources.metrics.ponder_historical_completion_rate.get()\n      ).values;\n      const etaMetric = (\n        await this.resources.metrics.ponder_historical_completion_eta.get()\n      ).values;\n\n      logFilterNames.forEach((name) => {\n        const rate = rateMetric.find((m) => m.labels.logFilter === name)?.value;\n        const eta = etaMetric.find((m) => m.labels.logFilter === name)?.value;\n\n        if (rate !== undefined) {\n          this.ui.historicalSyncLogFilterStats[name].rate = rate;\n        }\n        this.ui.historicalSyncLogFilterStats[name].eta = eta;\n      });\n\n      const minRate = Math.min(\n        ...logFilterNames.map(\n          (name) => this.ui.historicalSyncLogFilterStats[name].rate\n        )\n      );\n\n      if (!this.ui.isHistoricalSyncComplete && minRate === 1) {\n        this.ui.isHistoricalSyncComplete = true;\n      }\n\n      // Realtime sync\n      const connectedNetworks = (\n        await this.resources.metrics.ponder_realtime_is_connected.get()\n      ).values\n        .filter((m) => m.value === 1)\n        .map((m) => m.labels.network)\n        .filter((n): n is string => typeof n === \"string\");\n\n      this.ui.networks = connectedNetworks;\n\n      // Handlers\n      const matchedEvents = (\n        await this.resources.metrics.ponder_handlers_matched_events.get()\n      ).values.reduce((a, v) => a + v.value, 0);\n      const handledEvents = (\n        await this.resources.metrics.ponder_handlers_handled_events.get()\n      ).values.reduce((a, v) => a + v.value, 0);\n      const processedEvents = (\n        await this.resources.metrics.ponder_handlers_processed_events.get()\n      ).values.reduce((a, v) => a + v.value, 0);\n      const latestProcessedTimestamp =\n        (\n          await this.resources.metrics.ponder_handlers_latest_processed_timestamp.get()\n        ).values[0].value ?? 0;\n      this.ui.handlersTotal = matchedEvents;\n      this.ui.handlersHandledTotal = handledEvents;\n      this.ui.handlersCurrent = processedEvents;\n      this.ui.handlersToTimestamp = latestProcessedTimestamp;\n\n      // Errors\n      this.ui.handlerError = this.resources.errors.hasUserError;\n\n      // Server\n      const port = (await this.resources.metrics.ponder_server_port.get())\n        .values[0].value;\n      this.ui.port = port;\n\n      this.render();\n    }, 17);\n  }\n\n  kill() {\n    clearInterval(this.renderInterval);\n    this.unmount();\n  }\n}\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\nimport { AbiEvent } from \"abitype\";\nimport { E_CANCELED, Mutex } from \"async-mutex\";\nimport Emittery from \"emittery\";\nimport { encodeEventTopics, getAbiItem, Hex } from \"viem\";\n\nimport type { Handlers } from \"@/build/handlers\";\nimport type { Contract } from \"@/config/contracts\";\nimport type { LogFilter } from \"@/config/logFilters\";\nimport { UserError } from \"@/errors/user\";\nimport type {\n  EventAggregatorService,\n  LogEvent,\n} from \"@/event-aggregator/service\";\nimport type { EventStore } from \"@/event-store/store\";\nimport type { Resources } from \"@/Ponder\";\nimport type { Schema } from \"@/schema/types\";\nimport type { ReadOnlyContract } from \"@/types/contract\";\nimport type { Model } from \"@/types/model\";\nimport type { ModelInstance, UserStore } from \"@/user-store/store\";\nimport { prettyPrint } from \"@/utils/print\";\nimport { type Queue, type Worker, createQueue } from \"@/utils/queue\";\n\nimport { buildReadOnlyContracts } from \"./contract\";\nimport { buildModels } from \"./model\";\nimport { getStackTrace } from \"./trace\";\n\ntype EventHandlerEvents = {\n  eventsProcessed: { toTimestamp: number };\n};\n\ntype SetupTask = { kind: \"SETUP\" };\ntype LogEventTask = { kind: \"LOG\"; event: LogEvent };\ntype EventHandlerTask = SetupTask | LogEventTask;\ntype EventHandlerQueue = Queue<EventHandlerTask>;\n\nexport class EventHandlerService extends Emittery<EventHandlerEvents> {\n  private resources: Resources;\n  private userStore: UserStore;\n  private eventAggregatorService: EventAggregatorService;\n  private logFilters: LogFilter[];\n\n  private readOnlyContracts: Record<string, ReadOnlyContract> = {};\n\n  private schema?: Schema;\n  private models: Record<string, Model<ModelInstance>> = {};\n\n  private handlers?: Handlers;\n  private handledLogFilters: Record<\n    string,\n    {\n      eventName: string;\n      topic0: Hex;\n      abiItem: AbiEvent;\n    }[]\n  > = {};\n\n  private eventProcessingMutex: Mutex;\n  private queue?: EventHandlerQueue;\n\n  private eventsProcessedToTimestamp = 0;\n  private hasError = false;\n\n  private currentEventBlockNumber = 0n;\n  private currentEventTimestamp = 0;\n\n  constructor({\n    resources,\n    eventStore,\n    userStore,\n    eventAggregatorService,\n    contracts,\n    logFilters,\n  }: {\n    resources: Resources;\n    eventStore: EventStore;\n    userStore: UserStore;\n    eventAggregatorService: EventAggregatorService;\n    contracts: Contract[];\n    logFilters: LogFilter[];\n  }) {\n    super();\n    this.resources = resources;\n    this.userStore = userStore;\n    this.eventAggregatorService = eventAggregatorService;\n    this.logFilters = logFilters;\n\n    // The read-only contract objects only depend on config, so they can\n    // be built in the constructor (they can't be hot-reloaded).\n    this.readOnlyContracts = buildReadOnlyContracts({\n      contracts,\n      getCurrentBlockNumber: () => this.currentEventBlockNumber,\n      eventStore,\n    });\n\n    this.eventProcessingMutex = new Mutex();\n  }\n\n  kill = () => {\n    this.queue?.clear();\n    this.eventProcessingMutex.cancel();\n\n    this.resources.logger.debug({\n      service: \"handlers\",\n      msg: `Killed user handler service`,\n    });\n  };\n\n  /**\n   * Registers a new set of handler functions and/or a new schema, cancels\n   * the current event processing mutex & event queue, drops and re-creates\n   * all tables from the user store, and resets eventsProcessedToTimestamp to zero.\n   *\n   * Note: Caller should (probably) immediately call processEvents after this method.\n   */\n  reset = async ({\n    handlers: newHandlers,\n    schema: newSchema,\n  }: {\n    handlers?: Handlers;\n    schema?: Schema;\n  } = {}) => {\n    if (newSchema) {\n      this.schema = newSchema;\n      this.models = buildModels({\n        userStore: this.userStore,\n        schema: this.schema,\n        getCurrentEventTimestamp: () => this.currentEventTimestamp,\n      });\n    }\n\n    if (newHandlers) {\n      this.handlers = newHandlers;\n      this.handledLogFilters = {};\n\n      // Get the set of events that the user has provided a handler for.\n      this.logFilters.forEach((logFilter) => {\n        const handledEventSignatureTopics = Object.keys(\n          (this.handlers ?? {})[logFilter.name] ?? {}\n        ).map((eventName) => {\n          // TODO: Disambiguate overloaded ABI event signatures BEFORE getting here.\n          const topics = encodeEventTopics({\n            abi: logFilter.abi,\n            eventName,\n          });\n\n          const abiItem = getAbiItem({\n            abi: logFilter.abi,\n            name: eventName,\n          }) as AbiEvent;\n\n          return { eventName, topic0: topics[0], abiItem };\n        });\n\n        this.handledLogFilters[logFilter.name] = handledEventSignatureTopics;\n      });\n    }\n\n    // If either the schema or handlers have not been provided yet,\n    // we're not ready to process events. Just return early.\n    if (!this.schema || !this.handlers) return;\n\n    // Cancel all pending calls to processEvents, reset the mutex, and create\n    // a new queue using the latest available handlers and schema.\n    this.eventProcessingMutex.cancel();\n    this.eventProcessingMutex = new Mutex();\n    this.queue = this.createEventQueue({ handlers: this.handlers });\n\n    this.hasError = false;\n    this.resources.metrics.ponder_handlers_has_error.set(0);\n\n    this.resources.metrics.ponder_handlers_matched_events.reset();\n    this.resources.metrics.ponder_handlers_handled_events.reset();\n    this.resources.metrics.ponder_handlers_processed_events.reset();\n\n    await this.userStore.reload({ schema: this.schema });\n    this.resources.logger.debug({\n      service: \"handlers\",\n      msg: `Reset user store (versionId=${this.userStore.versionId})`,\n    });\n\n    // When we call userStore.reload() above, the user store is dropped.\n    // Set the latest processed timestamp to zero accordingly.\n    this.eventsProcessedToTimestamp = 0;\n    this.resources.metrics.ponder_handlers_latest_processed_timestamp.set(0);\n  };\n\n  /**\n   * This method is triggered by the realtime sync service detecting a reorg,\n   * which can happen at any time. The event queue and the user store can be\n   * in one of several different states that we need to keep in mind:\n   *\n   * 1) No events have been added to the queue yet.\n   * 2) No unsafe events have been processed (eventsProcessedToTimestamp <= commonAncestorTimestamp).\n   * 3) Unsafe events may have been processed (eventsProcessedToTimestamp > commonAncestorTimestamp).\n   * 4) The queue has encountered a user error and is waiting for a reload.\n   *\n   * Note: It's crucial that we acquire a mutex lock while handling the reorg.\n   * This will only ever run while the queue is idle, so we can be confident\n   * that eventsProcessedToTimestamp matches the current state of the user store,\n   * and that no unsafe events will get processed after handling the reorg.\n   *\n   * Note: Caller should (probably) immediately call processEvents after this method.\n   */\n  handleReorg = async ({\n    commonAncestorTimestamp,\n  }: {\n    commonAncestorTimestamp: number;\n  }) => {\n    try {\n      await this.eventProcessingMutex.runExclusive(async () => {\n        // If there is a user error, the queue & user store will be wiped on reload (case 4).\n        if (this.hasError) return;\n\n        if (this.eventsProcessedToTimestamp <= commonAncestorTimestamp) {\n          // No unsafe events have been processed, so no need to revert (case 1 & case 2).\n          this.resources.logger.debug({\n            service: \"handlers\",\n            msg: `No unsafe events were detected while reconciling a reorg, no-op`,\n          });\n        } else {\n          // Unsafe events have been processed, must revert the user store and update\n          // eventsProcessedToTimestamp accordingly (case 3).\n          await this.userStore.revert({\n            safeTimestamp: commonAncestorTimestamp,\n          });\n\n          this.eventsProcessedToTimestamp = commonAncestorTimestamp;\n          this.resources.metrics.ponder_handlers_latest_processed_timestamp.set(\n            commonAncestorTimestamp\n          );\n\n          // Note: There's currently no way to know how many events are \"thrown out\"\n          // during the reorg reconciliation, so the event count metrics\n          // (e.g. ponder_handlers_processed_events) will be slightly inflated.\n\n          this.resources.logger.debug({\n            service: \"handlers\",\n            msg: `Reverted user store to safe timestamp ${commonAncestorTimestamp}`,\n          });\n        }\n      });\n    } catch (error) {\n      // Pending locks get cancelled in reset(). This is expected, so it's safe to\n      // ignore the error that is thrown when a pending lock is cancelled.\n      if (error !== E_CANCELED) throw error;\n    }\n  };\n\n  /**\n   * Processes all newly available events.\n   *\n   * Acquires a lock on the event processing mutex, then gets the latest checkpoint\n   * from the event aggregator service. Fetches events between previous checkpoint\n   * and the new checkpoint, adds them to the queue, then processes them.\n   */\n  processEvents = async () => {\n    try {\n      await this.eventProcessingMutex.runExclusive(async () => {\n        if (this.hasError || !this.queue) return;\n\n        const eventsAvailableTo = this.eventAggregatorService.checkpoint;\n\n        // If we have already added events to the queue for the current checkpoint,\n        // do nothing and return. This can happen if a number of calls to processEvents\n        // \"stack up\" while one is being processed, and then they all run sequentially\n        // but the event aggregator service checkpoint has not moved.\n        if (this.eventsProcessedToTimestamp >= eventsAvailableTo) {\n          return;\n        }\n\n        // The getEvents method is inclusive on both sides, so we need to add 1 here\n        // to avoid fetching the same event twice.\n        const fromTimestamp =\n          this.eventsProcessedToTimestamp === 0\n            ? 0\n            : this.eventsProcessedToTimestamp + 1;\n\n        const toTimestamp = eventsAvailableTo;\n\n        const { events, totalEventCount } =\n          await this.eventAggregatorService.getEvents({\n            fromTimestamp,\n            toTimestamp,\n            handledLogFilters: this.handledLogFilters,\n          });\n\n        // TODO: Add the \"eventName\" label here by updating getEvents\n        // implementation to return a count for each event name rather\n        // than all lumped together.\n        this.resources.metrics.ponder_handlers_matched_events.inc(\n          totalEventCount\n        );\n\n        // If no events have been added yet, add the setup event.\n        if (this.eventsProcessedToTimestamp === 0 && this.handlers?.setup) {\n          this.queue.addTask({ kind: \"SETUP\" });\n          this.resources.metrics.ponder_handlers_handled_events.inc({\n            eventName: \"setup\",\n          });\n        }\n\n        // Add new events to the queue.\n        for (const event of events) {\n          this.queue.addTask({\n            kind: \"LOG\",\n            event,\n          });\n          this.resources.metrics.ponder_handlers_handled_events.inc({\n            eventName: `${event.logFilterName}:${event.eventName}`,\n          });\n        }\n\n        // Process new events that were added to the queue.\n        this.queue.start();\n        await this.queue.onIdle();\n        this.queue.pause();\n\n        this.eventsProcessedToTimestamp = toTimestamp;\n\n        this.emit(\"eventsProcessed\", { toTimestamp });\n\n        this.resources.metrics.ponder_handlers_latest_processed_timestamp.set(\n          toTimestamp\n        );\n\n        if (events.length > 0) {\n          this.resources.logger.info({\n            service: \"handlers\",\n            msg: `Processed ${\n              events.length === 1 ? \"1 event\" : `${events.length} events`\n            }`,\n          });\n        }\n      });\n    } catch (error) {\n      // Pending locks get cancelled in reset(). This is expected, so it's safe to\n      // ignore the error that is thrown when a pending lock is cancelled.\n      if (error !== E_CANCELED) throw error;\n    }\n  };\n\n  private createEventQueue = ({ handlers }: { handlers: Handlers }) => {\n    const context = {\n      contracts: this.readOnlyContracts,\n      entities: this.models,\n    };\n\n    const eventHandlerWorker: Worker<EventHandlerTask> = async ({\n      task,\n      queue,\n    }) => {\n      switch (task.kind) {\n        case \"SETUP\": {\n          const setupHandler = handlers[\"setup\"];\n          if (!setupHandler) return;\n\n          try {\n            // Running user code here!\n            await setupHandler({ context });\n\n            this.resources.metrics.ponder_handlers_processed_events.inc({\n              eventName: \"setup\",\n            });\n          } catch (error_) {\n            // Remove all remaining tasks from the queue.\n            queue.clear();\n\n            this.hasError = true;\n            this.resources.metrics.ponder_handlers_has_error.set(1);\n\n            const error = error_ as Error;\n            const trace = getStackTrace(error, this.resources.options);\n\n            const message = `Error while handling \"setup\" event: ${error.message}`;\n\n            const userError = new UserError(message, {\n              stack: trace,\n              cause: error,\n            });\n\n            this.resources.logger.error({\n              service: \"handlers\",\n              error: userError,\n            });\n            this.resources.errors.submitUserError({ error: userError });\n          }\n\n          break;\n        }\n        case \"LOG\": {\n          const event = task.event;\n\n          const handler = handlers[event.logFilterName]?.[event.eventName];\n          if (!handler) return;\n\n          // This enables contract calls occurring within the\n          // handler code to use the event block number by default.\n          this.currentEventBlockNumber = event.block.number;\n          this.currentEventTimestamp = Number(event.block.timestamp);\n\n          try {\n            // Running user code here!\n            await handler({\n              event: {\n                ...event,\n                name: event.eventName,\n              },\n              context,\n            });\n\n            this.resources.metrics.ponder_handlers_processed_events.inc({\n              eventName: `${event.logFilterName}:${event.eventName}`,\n            });\n          } catch (error_) {\n            // Remove all remaining tasks from the queue.\n            queue.clear();\n\n            this.hasError = true;\n            this.resources.metrics.ponder_handlers_has_error.set(1);\n\n            const error = error_ as Error;\n            const trace = getStackTrace(error, this.resources.options);\n\n            const message = `Error while handling \"${event.logFilterName}:${\n              event.eventName\n            }\" event at block ${Number(event.block.number)}: ${error.message}`;\n\n            const metaMessage = `Event params:\\n${prettyPrint(event.params)}`;\n\n            const userError = new UserError(message, {\n              stack: trace,\n              meta: metaMessage,\n              cause: error,\n            });\n\n            this.resources.logger.error({\n              service: \"handlers\",\n              error: userError,\n            });\n            this.resources.errors.submitUserError({ error: userError });\n          }\n\n          break;\n        }\n      }\n    };\n\n    const queue = createQueue({\n      worker: eventHandlerWorker,\n      context: undefined,\n      options: {\n        concurrency: 1,\n        autoStart: false,\n      },\n    });\n\n    return queue;\n  };\n}\n","import {\n  type Abi,\n  type BaseError,\n  type CallParameters,\n  type GetContractReturnType,\n  type Hex,\n  type PublicClient,\n  type ReadContractParameters,\n  decodeFunctionResult,\n  encodeFunctionData,\n  getContract,\n  getContractError,\n} from \"viem\";\n\nimport type { Contract } from \"@/config/contracts\";\nimport type { EventStore } from \"@/event-store/store\";\n\nexport function buildReadOnlyContracts({\n  contracts,\n  eventStore,\n  getCurrentBlockNumber,\n}: {\n  contracts: Contract[];\n  eventStore: EventStore;\n  getCurrentBlockNumber: () => bigint;\n}) {\n  return contracts.reduce<\n    Record<string, GetContractReturnType<Abi, PublicClient>>\n  >((acc, { name, abi, address, network }) => {\n    const { chainId, client: publicClient } = network;\n\n    const readOnlyContract = getContract({ abi, address, publicClient });\n\n    readOnlyContract.read = new Proxy(\n      {},\n      {\n        get(_, functionName: string) {\n          return async (\n            ...parameters: [\n              args?: readonly unknown[],\n              options?: Omit<\n                ReadContractParameters,\n                \"abi\" | \"address\" | \"functionName\" | \"args\"\n              >\n            ]\n          ) => {\n            const { args, options } = getFunctionParameters(parameters);\n\n            // If the user specified a block tag, serve the request as normal (no caching).\n            if (options?.blockTag) {\n              return publicClient.readContract({\n                abi,\n                address,\n                functionName,\n                args,\n                ...options,\n              } as ReadContractParameters);\n            }\n\n            // If the user specified a block number, use it, otherwise use the\n            // block number of the current event being handled.\n            const blockNumber = options?.blockNumber ?? getCurrentBlockNumber();\n\n            const calldata = encodeFunctionData({ abi, args, functionName });\n\n            const decodeRawResult = (rawResult: Hex) => {\n              try {\n                return decodeFunctionResult({\n                  abi,\n                  args,\n                  functionName,\n                  data: rawResult,\n                });\n              } catch (err) {\n                throw getContractError(err as BaseError, {\n                  abi,\n                  address,\n                  args,\n                  docsPath: \"/docs/contract/readContract\",\n                  functionName,\n                });\n              }\n            };\n\n            // Check if this request can be served from the cache.\n            const cachedContractReadResult =\n              await eventStore.getContractReadResult({\n                address,\n                blockNumber,\n                chainId,\n                data: calldata,\n              });\n\n            if (cachedContractReadResult) {\n              return decodeRawResult(cachedContractReadResult.result);\n            }\n\n            // Cache miss. Make the RPC request, then add to the cache.\n            let rawResult: Hex;\n            try {\n              const { data } = await publicClient.call({\n                data: calldata,\n                to: address,\n                ...{\n                  ...options,\n                  blockNumber,\n                },\n              } as unknown as CallParameters);\n\n              rawResult = data || \"0x\";\n            } catch (err) {\n              throw getContractError(err as BaseError, {\n                abi,\n                address,\n                args,\n                docsPath: \"/docs/contract/readContract\",\n                functionName,\n              });\n            }\n\n            await eventStore.insertContractReadResult({\n              address,\n              blockNumber,\n              chainId,\n              data: calldata,\n              finalized: false,\n              result: rawResult,\n            });\n\n            return decodeRawResult(rawResult);\n          };\n        },\n      }\n    );\n\n    acc[name] = readOnlyContract;\n\n    return acc;\n  }, {});\n}\n\nfunction getFunctionParameters(\n  values: [args?: readonly unknown[], options?: object]\n) {\n  const hasArgs = values.length && Array.isArray(values[0]);\n  const args = hasArgs ? values[0]! : [];\n  const options = ((hasArgs ? values[1] : values[0]) ?? {}) as Omit<\n    ReadContractParameters,\n    \"abi\" | \"address\" | \"functionName\" | \"args\"\n  >;\n  return { args, options };\n}\n","import { Schema } from \"@/schema/types\";\nimport { Model } from \"@/types/model\";\nimport { ModelInstance, UserStore } from \"@/user-store/store\";\n\nexport function buildModels({\n  userStore,\n  schema,\n  getCurrentEventTimestamp,\n}: {\n  userStore: UserStore;\n  schema: Schema;\n  getCurrentEventTimestamp: () => number;\n}) {\n  return schema.entities.reduce<Record<string, Model<ModelInstance>>>(\n    (acc, { name: modelName }) => {\n      acc[modelName] = {\n        findUnique: ({ id }) =>\n          userStore.findUnique({\n            modelName,\n            timestamp: getCurrentEventTimestamp(),\n            id,\n          }),\n        create: ({ id, data }) =>\n          userStore.create({\n            modelName,\n            timestamp: getCurrentEventTimestamp(),\n            id,\n            data,\n          }),\n        update: ({ id, data }) =>\n          userStore.update({\n            modelName,\n            timestamp: getCurrentEventTimestamp(),\n            id,\n            data,\n          }),\n        upsert: ({ id, create, update }) =>\n          userStore.upsert({\n            modelName,\n            timestamp: getCurrentEventTimestamp(),\n            id,\n            create,\n            update,\n          }),\n        delete: ({ id }) =>\n          userStore.delete({\n            modelName,\n            timestamp: getCurrentEventTimestamp(),\n            id,\n          }),\n      };\n      return acc;\n    },\n    {}\n  );\n}\n","import { codeFrameColumns } from \"@babel/code-frame\";\nimport {\n  DecodedSourceMap,\n  originalPositionFor,\n  sourceContentFor,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\nimport type { MimeBuffer } from \"data-uri-to-buffer\";\nimport dataUriToBuffer from \"data-uri-to-buffer\";\nimport { readFileSync } from \"node:fs\";\nimport path from \"node:path\";\nimport { parse as parseStackTrace, StackFrame } from \"stacktrace-parser\";\n\nimport { Options } from \"@/config/options\";\n\nexport const getStackTrace = (error: Error, options: Options) => {\n  if (!error.stack) return undefined;\n\n  const buildDir = path.join(options.ponderDir, \"out\");\n\n  const stackTrace = parseStackTrace(error.stack);\n\n  let codeFrame: string | undefined;\n\n  const sourceMappedStackTrace = stackTrace\n    .map((frame) => {\n      if (!frame.file || !frame.lineNumber) return;\n\n      const sourceMappedStackFrame = getSourceMappedStackFrame(\n        frame.file,\n        frame.lineNumber,\n        frame.column\n      );\n\n      // If this frame cannot be mapped to the user code build directory, skip it.\n      if (!sourceMappedStackFrame) return;\n\n      const {\n        sourceFile,\n        sourceLineNumber,\n        sourceColumnNumber,\n        sourceContent,\n      } = sourceMappedStackFrame;\n\n      // If this is the first frame within the build directory, generate the code frame.\n      if (\n        frame.file.includes(buildDir) &&\n        codeFrame == null &&\n        sourceContent !== null\n      ) {\n        codeFrame = codeFrameColumns(\n          sourceContent,\n          {\n            start: {\n              line: sourceLineNumber,\n              column: sourceColumnNumber ?? undefined,\n            },\n          },\n          {\n            highlightCode: true,\n          }\n        );\n      }\n\n      return {\n        ...frame,\n        file: sourceFile,\n        lineNumber: sourceLineNumber,\n        column: sourceColumnNumber,\n      } as StackFrame;\n    })\n    .filter((f): f is StackFrame => !!f);\n\n  if (sourceMappedStackTrace.length === 0 || !codeFrame) {\n    return undefined;\n  }\n\n  const formattedStackTrace = [\n    ...sourceMappedStackTrace.map((frame) => {\n      let result = \"  at\";\n\n      result += ` ${\n        frame.methodName === \"<unknown>\" ? \"(anonymous)\" : frame.methodName\n      }`;\n\n      result += ` (${frame.file}:${frame.lineNumber}${\n        frame.column !== null ? `:${frame.column}` : \"\"\n      })`;\n\n      return result;\n    }),\n    codeFrame,\n  ].join(\"\\n\");\n\n  return formattedStackTrace;\n};\n\nfunction getSourceMappedStackFrame(\n  file: string,\n  lineNumber: number,\n  columnNumber: number | null\n) {\n  let fileContents: string;\n  try {\n    fileContents = readFileSync(file, { encoding: \"utf-8\" });\n  } catch (_) {\n    return null;\n  }\n\n  const sourceMap = getRawSourceMap(fileContents);\n  if (!sourceMap) return null;\n\n  const result = getSourcePositionAndContent(\n    sourceMap,\n    lineNumber,\n    columnNumber\n  );\n\n  const sourceFileRelative = result?.sourcePosition?.source;\n\n  const sourceLineNumber = result?.sourcePosition?.line;\n  const sourceColumnNumber = result?.sourcePosition?.column ?? null;\n  const sourceContent = result?.sourceContent ?? null;\n\n  if (!sourceFileRelative || !sourceLineNumber) return null;\n\n  const sourceFile = path.resolve(path.dirname(file), sourceFileRelative);\n\n  return {\n    sourceFile,\n    sourceLineNumber,\n    sourceColumnNumber,\n    sourceContent,\n  };\n}\n\nfunction getSourceMapUrl(fileContents: string): string | null {\n  const regex = /\\/\\/[#@] ?sourceMappingURL=([^\\s'\"]+)\\s*$/gm;\n  let match = null;\n  for (;;) {\n    const next = regex.exec(fileContents);\n    if (next == null) {\n      break;\n    }\n    match = next;\n  }\n  if (!(match && match[1])) {\n    return null;\n  }\n  return match[1].toString();\n}\n\nfunction getRawSourceMap(fileContents: string): DecodedSourceMap | null {\n  const sourceUrl = getSourceMapUrl(fileContents);\n  if (!sourceUrl?.startsWith(\"data:\")) {\n    return null;\n  }\n\n  let buffer: MimeBuffer;\n  try {\n    buffer = dataUriToBuffer(sourceUrl);\n  } catch (err) {\n    console.error(\"Failed to parse source map URL:\", err);\n    return null;\n  }\n\n  if (buffer.type !== \"application/json\") {\n    console.error(`Unknown source map type: ${buffer.typeFull}.`);\n    return null;\n  }\n\n  try {\n    return JSON.parse(buffer.toString());\n  } catch {\n    console.error(\"Failed to parse source map.\");\n    return null;\n  }\n}\n\nfunction getSourcePositionAndContent(\n  rawSourceMap: DecodedSourceMap,\n  lineNumber: number,\n  columnNumber: number | null\n) {\n  const tracer = new TraceMap(rawSourceMap);\n\n  const sourcePosition = originalPositionFor(tracer, {\n    line: lineNumber,\n    column: columnNumber ?? 0,\n  });\n\n  if (!sourcePosition.source) {\n    return null;\n  }\n\n  const sourceContent = sourceContentFor(tracer, sourcePosition.source) ?? null;\n\n  return {\n    sourcePosition,\n    sourceContent,\n  };\n}\n","import { randomBytes } from \"crypto\";\nimport { CompiledQuery, Kysely, PostgresDialect, sql } from \"kysely\";\nimport { Pool } from \"pg\";\n\nimport type { Schema } from \"@/schema/types\";\nimport { blobToBigInt } from \"@/utils/decode\";\n\nimport type { ModelFilter, ModelInstance, UserStore } from \"../store\";\nimport {\n  type FilterType,\n  formatModelFieldValue,\n  formatModelInstance,\n  getWhereOperatorAndValue,\n  parseModelFilter,\n} from \"../utils\";\n\nconst gqlScalarToSqlType = {\n  Boolean: \"integer\",\n  Int: \"integer\",\n  String: \"text\",\n  BigInt: sql`bytea`,\n  Bytes: \"text\",\n  Float: \"text\",\n} as const;\n\nconst MAX_INTEGER = 2_147_483_647 as const;\n\nexport class PostgresUserStore implements UserStore {\n  db: Kysely<any>;\n\n  schema?: Schema;\n  versionId?: string;\n\n  constructor({\n    pool,\n    databaseSchema,\n  }: {\n    pool: Pool;\n    databaseSchema?: string;\n  }) {\n    this.db = new Kysely({\n      dialect: new PostgresDialect({\n        pool,\n        onCreateConnection: databaseSchema\n          ? async (connection) => {\n              await connection.executeQuery(\n                CompiledQuery.raw(\n                  `CREATE SCHEMA IF NOT EXISTS ${databaseSchema}`\n                )\n              );\n              await connection.executeQuery(\n                CompiledQuery.raw(`SET search_path = ${databaseSchema}`)\n              );\n            }\n          : undefined,\n      }),\n    });\n  }\n\n  /**\n   * Resets the database by dropping existing tables and creating new tables.\n   * If no new schema is provided, the existing schema is used.\n   *\n   * @param options.schema New schema to be used.\n   */\n  reload = async ({ schema }: { schema?: Schema } = {}) => {\n    // If there is no existing schema and no schema was provided, do nothing.\n    if (!this.schema && !schema) return;\n\n    await this.db.transaction().execute(async (tx) => {\n      // Drop tables from existing schema.\n      if (this.schema) {\n        await Promise.all(\n          this.schema.entities.map((model) => {\n            const tableName = `${model.name}_${this.versionId}`;\n            tx.schema.dropTable(tableName);\n          })\n        );\n      }\n\n      if (schema) this.schema = schema;\n\n      this.versionId = randomBytes(4).toString(\"hex\");\n\n      // Create tables for new schema.\n      await Promise.all(\n        this.schema!.entities.map(async (model) => {\n          const tableName = `${model.name}_${this.versionId}`;\n          let tableBuilder = tx.schema.createTable(tableName);\n          model.fields.forEach((field) => {\n            switch (field.kind) {\n              case \"SCALAR\": {\n                tableBuilder = tableBuilder.addColumn(\n                  field.name,\n                  gqlScalarToSqlType[field.scalarTypeName],\n                  (col) => {\n                    if (field.notNull) col = col.notNull();\n                    return col;\n                  }\n                );\n                break;\n              }\n              case \"ENUM\": {\n                tableBuilder = tableBuilder.addColumn(\n                  field.name,\n                  \"text\",\n                  (col) => {\n                    if (field.notNull) col = col.notNull();\n                    col = col.check(\n                      sql`${sql.ref(field.name)} in (${sql.join(\n                        field.enumValues.map((v) => sql.lit(v))\n                      )})`\n                    );\n                    return col;\n                  }\n                );\n                break;\n              }\n              case \"LIST\": {\n                tableBuilder = tableBuilder.addColumn(\n                  field.name,\n                  \"text\",\n                  (col) => {\n                    if (field.notNull) col = col.notNull();\n                    return col;\n                  }\n                );\n                break;\n              }\n              case \"RELATIONSHIP\": {\n                tableBuilder = tableBuilder.addColumn(\n                  field.name,\n                  gqlScalarToSqlType[field.relatedEntityIdType.name],\n                  (col) => {\n                    if (field.notNull) col = col.notNull();\n                    return col;\n                  }\n                );\n                break;\n              }\n            }\n          });\n\n          // Add the effective timestamp columns.\n          tableBuilder = tableBuilder.addColumn(\n            \"effectiveFrom\",\n            \"integer\",\n            (col) => col.notNull()\n          );\n          tableBuilder = tableBuilder.addColumn(\n            \"effectiveTo\",\n            \"integer\",\n            (col) => col.notNull()\n          );\n          tableBuilder = tableBuilder.addPrimaryKeyConstraint(\n            `${tableName}_id_effectiveTo_unique`,\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            [\"id\", \"effectiveTo\"]\n          );\n\n          await tableBuilder.execute();\n        })\n      );\n    });\n  };\n\n  /**\n   * Tears down the store by dropping all tables for the current schema.\n   */\n  teardown = async () => {\n    if (!this.schema) return;\n\n    // Drop tables from existing schema.\n    await this.db.transaction().execute(async (tx) => {\n      await Promise.all(\n        this.schema!.entities.map((model) => {\n          const tableName = `${model.name}_${this.versionId}`;\n          tx.schema.dropTable(tableName);\n        })\n      );\n    });\n  };\n\n  findUnique = async ({\n    modelName,\n    timestamp = MAX_INTEGER,\n    id,\n  }: {\n    modelName: string;\n    timestamp?: number;\n    id: string | number | bigint;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const formattedId = formatModelFieldValue({ value: id });\n\n    const instances = await this.db\n      .selectFrom(tableName)\n      .selectAll()\n      .where(\"id\", \"=\", formattedId)\n      .where(\"effectiveFrom\", \"<=\", timestamp)\n      .where(\"effectiveTo\", \">=\", timestamp)\n      .execute();\n\n    if (instances.length > 1) {\n      throw new Error(`Expected 1 instance, found ${instances.length}`);\n    }\n\n    return instances[0]\n      ? this.deserializeInstance({ modelName, instance: instances[0] })\n      : null;\n  };\n\n  create = async ({\n    modelName,\n    timestamp,\n    id,\n    data = {},\n  }: {\n    modelName: string;\n    timestamp: number;\n    id: string | number | bigint;\n    data?: Omit<ModelInstance, \"id\">;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const createInstance = formatModelInstance({ id, data });\n\n    const instance = await this.db\n      .insertInto(tableName)\n      .values({\n        ...createInstance,\n        effectiveFrom: timestamp,\n        effectiveTo: MAX_INTEGER,\n      })\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return this.deserializeInstance({ modelName, instance });\n  };\n\n  update = async ({\n    modelName,\n    timestamp,\n    id,\n    data = {},\n  }: {\n    modelName: string;\n    timestamp: number;\n    id: string | number | bigint;\n    data?: Partial<Omit<ModelInstance, \"id\">>;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const formattedId = formatModelFieldValue({ value: id });\n    const updateInstance = formatModelInstance({ id, data });\n\n    const instance = await this.db.transaction().execute(async (tx) => {\n      // Find the latest version of this instance.\n      const latestInstance = await tx\n        .selectFrom(tableName)\n        .selectAll()\n        .where(\"id\", \"=\", formattedId)\n        .orderBy(\"effectiveTo\", \"desc\")\n        .executeTakeFirstOrThrow();\n\n      // If the latest version has the same effectiveFrom timestamp as the update,\n      // this update is occurring within the same block/second. Update in place.\n      if (latestInstance.effectiveFrom === timestamp) {\n        return await tx\n          .updateTable(tableName)\n          .set(updateInstance)\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveFrom\", \"=\", timestamp)\n          .returningAll()\n          .executeTakeFirstOrThrow();\n      }\n\n      if (latestInstance.effectiveFrom > timestamp) {\n        throw new Error(`Cannot update an instance in the past`);\n      }\n\n      // If the latest version has an earlier effectiveFrom timestamp than the update,\n      // we need to update the latest version AND insert a new version.\n      await tx\n        .updateTable(tableName)\n        .set({ effectiveTo: timestamp - 1 })\n        .where(\"id\", \"=\", formattedId)\n        .where(\"effectiveTo\", \"=\", MAX_INTEGER)\n        .execute();\n\n      return await tx\n        .insertInto(tableName)\n        .values({\n          ...latestInstance,\n          ...updateInstance,\n          effectiveFrom: timestamp,\n          effectiveTo: MAX_INTEGER,\n        })\n        .returningAll()\n        .executeTakeFirstOrThrow();\n    });\n\n    return this.deserializeInstance({ modelName, instance });\n  };\n\n  upsert = async ({\n    modelName,\n    timestamp,\n    id,\n    create = {},\n    update = {},\n  }: {\n    modelName: string;\n    timestamp: number;\n    id: string | number | bigint;\n    create?: Omit<ModelInstance, \"id\">;\n    update?: Partial<Omit<ModelInstance, \"id\">>;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const formattedId = formatModelFieldValue({ value: id });\n    const createInstance = formatModelInstance({ id, data: create });\n    const updateInstance = formatModelInstance({ id, data: update });\n\n    const instance = await this.db.transaction().execute(async (tx) => {\n      // Attempt to find the latest version of this instance.\n      const latestInstance = await tx\n        .selectFrom(tableName)\n        .selectAll()\n        .where(\"id\", \"=\", formattedId)\n        .orderBy(\"effectiveTo\", \"desc\")\n        .executeTakeFirst();\n\n      // If there is no latest version, insert a new version using the create data.\n      if (!latestInstance) {\n        return await tx\n          .insertInto(tableName)\n          .values({\n            ...createInstance,\n            effectiveFrom: timestamp,\n            effectiveTo: MAX_INTEGER,\n          })\n          .returningAll()\n          .executeTakeFirstOrThrow();\n      }\n\n      // If the latest version has the same effectiveFrom timestamp as the update,\n      // this update is occurring within the same block/second. Update in place.\n      if (latestInstance.effectiveFrom === timestamp) {\n        return await tx\n          .updateTable(tableName)\n          .set(updateInstance)\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveFrom\", \"=\", timestamp)\n          .returningAll()\n          .executeTakeFirstOrThrow();\n      }\n\n      if (latestInstance.effectiveFrom > timestamp) {\n        throw new Error(`Cannot update an instance in the past`);\n      }\n\n      // If the latest version has an earlier effectiveFrom timestamp than the update,\n      // we need to update the latest version AND insert a new version.\n      await tx\n        .updateTable(tableName)\n        .set({ effectiveTo: timestamp - 1 })\n        .where(\"id\", \"=\", formattedId)\n        .where(\"effectiveTo\", \"=\", MAX_INTEGER)\n        .execute();\n\n      return await tx\n        .insertInto(tableName)\n        .values({\n          ...latestInstance,\n          ...updateInstance,\n          effectiveFrom: timestamp,\n          effectiveTo: MAX_INTEGER,\n        })\n        .returningAll()\n        .executeTakeFirstOrThrow();\n    });\n\n    return this.deserializeInstance({ modelName, instance });\n  };\n\n  delete = async ({\n    modelName,\n    timestamp,\n    id,\n  }: {\n    modelName: string;\n    timestamp: number;\n    id: string | number | bigint;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const formattedId = formatModelFieldValue({ value: id });\n\n    const instance = await this.db.transaction().execute(async (tx) => {\n      // Update the latest version to be effective until the delete timestamp.\n      const deletedInstance = await tx\n        .updateTable(tableName)\n        .set({ effectiveTo: timestamp - 1 })\n        .where(\"id\", \"=\", formattedId)\n        .where(\"effectiveTo\", \"=\", MAX_INTEGER)\n        .returning([\"id\", \"effectiveFrom\"])\n        .executeTakeFirst();\n\n      // If, after the update, the latest version is only effective from\n      // the delete timestamp, delete the instance in place. It \"never existed\".\n      if (deletedInstance?.effectiveFrom === timestamp) {\n        await tx\n          .deleteFrom(tableName)\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveFrom\", \"=\", timestamp)\n          .returning([\"id\"])\n          .executeTakeFirst();\n      }\n\n      return !!deletedInstance;\n    });\n\n    return instance;\n  };\n\n  findMany = async ({\n    modelName,\n    timestamp = MAX_INTEGER,\n    filter = {},\n  }: {\n    modelName: string;\n    timestamp: number;\n    filter?: ModelFilter;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n\n    let query = this.db\n      .selectFrom(tableName)\n      .selectAll()\n      .where(\"effectiveFrom\", \"<=\", timestamp)\n      .where(\"effectiveTo\", \">=\", timestamp);\n\n    const { where, first, skip, orderBy, orderDirection } =\n      parseModelFilter(filter);\n\n    if (where) {\n      Object.entries(where).forEach(([whereKey, rawValue]) => {\n        const [fieldName, rawFilterType] = whereKey.split(/_(.*)/s);\n        // This is a hack to handle the \"\" operator, which the regex above doesn't handle\n        const filterType = (\n          rawFilterType === undefined ? \"\" : rawFilterType\n        ) as FilterType;\n\n        const { operator, value } = getWhereOperatorAndValue({\n          filterType,\n          value: rawValue,\n        });\n\n        query = query.where(fieldName, operator, value);\n      });\n    }\n\n    // TODO: test if skip works without first.\n    if (skip) {\n      query = query.offset(skip);\n    }\n    if (first) {\n      query = query.limit(first);\n    }\n    if (orderBy) {\n      query = query.orderBy(\n        orderBy,\n        orderDirection === \"asc\" || orderDirection === undefined\n          ? sql`asc nulls first`\n          : sql`desc nulls last`\n      );\n    }\n\n    const instances = await query.execute();\n\n    return instances.map((instance) =>\n      this.deserializeInstance({ modelName, instance })\n    );\n  };\n\n  revert = async ({ safeTimestamp }: { safeTimestamp: number }) => {\n    await this.db.transaction().execute(async (tx) => {\n      await Promise.all(\n        (this.schema?.entities ?? []).map(async (entity) => {\n          const modelName = entity.name;\n          const tableName = `${modelName}_${this.versionId}`;\n\n          // Delete any versions that are newer than the safe timestamp.\n          await tx\n            .deleteFrom(tableName)\n            .where(\"effectiveFrom\", \">\", safeTimestamp)\n            .execute();\n\n          // Now, any versions that have effectiveTo greater than or equal\n          // to the safe timestamp are the new latest version.\n          await tx\n            .updateTable(tableName)\n            .where(\"effectiveTo\", \">=\", safeTimestamp)\n            .set({ effectiveTo: MAX_INTEGER })\n            .execute();\n        })\n      );\n    });\n  };\n\n  private deserializeInstance = ({\n    modelName,\n    instance,\n  }: {\n    modelName: string;\n    instance: Record<string, unknown>;\n  }) => {\n    const entity = this.schema!.entities.find((e) => e.name === modelName)!;\n\n    const deserializedInstance = {} as ModelInstance;\n\n    entity.fields.forEach((field) => {\n      const value = instance[field.name] as string | number | null | undefined;\n\n      if (value === null || value === undefined) {\n        deserializedInstance[field.name] = null;\n        return;\n      }\n\n      if (field.kind === \"SCALAR\" && field.scalarTypeName === \"Boolean\") {\n        deserializedInstance[field.name] = value === 1 ? true : false;\n        return;\n      }\n\n      if (field.kind === \"SCALAR\" && field.scalarTypeName === \"BigInt\") {\n        deserializedInstance[field.name] = blobToBigInt(\n          value as unknown as Buffer\n        );\n        return;\n      }\n\n      if (\n        field.kind === \"RELATIONSHIP\" &&\n        field.relatedEntityIdType.name === \"BigInt\"\n      ) {\n        deserializedInstance[field.name] = blobToBigInt(\n          value as unknown as Buffer\n        );\n        return;\n      }\n\n      if (field.kind === \"LIST\") {\n        let parsedValue = JSON.parse(value as string);\n        if (field.baseGqlType.name === \"BigInt\")\n          parsedValue = parsedValue.map(BigInt);\n        deserializedInstance[field.name] = parsedValue;\n        return;\n      }\n\n      deserializedInstance[field.name] = value;\n    });\n\n    return deserializedInstance;\n  };\n}\n","import { BaseError } from \"@/errors/base\";\nimport { intToBlob } from \"@/utils/encode\";\n\nimport { ModelFilter, ModelInstance } from \"./store\";\n\nexport const filterTypes = {\n  // universal\n  \"\": { operator: \"=\", patternPrefix: undefined, patternSuffix: undefined },\n  not: { operator: \"!=\", patternPrefix: undefined, patternSuffix: undefined },\n  // singular\n  in: { operator: \"in\", patternPrefix: undefined, patternSuffix: undefined },\n  not_in: {\n    operator: \"not in\",\n    patternPrefix: undefined,\n    patternSuffix: undefined,\n  },\n  // plural\n  contains: { operator: \"like\", patternPrefix: \"%\", patternSuffix: \"%\" },\n  not_contains: {\n    operator: \"not like\",\n    patternPrefix: \"%\",\n    patternSuffix: \"%\",\n  },\n  // numeric\n  gt: { operator: \">\", patternPrefix: undefined, patternSuffix: undefined },\n  lt: { operator: \"<\", patternPrefix: undefined, patternSuffix: undefined },\n  gte: { operator: \">=\", patternPrefix: undefined, patternSuffix: undefined },\n  lte: { operator: \"<=\", patternPrefix: undefined, patternSuffix: undefined },\n  // string\n  starts_with: {\n    operator: \"like\",\n    patternPrefix: undefined,\n    patternSuffix: \"%\",\n  },\n  ends_with: { operator: \"like\", patternPrefix: \"%\", patternSuffix: undefined },\n  not_starts_with: {\n    operator: \"not like\",\n    patternPrefix: undefined,\n    patternSuffix: \"%\",\n  },\n  not_ends_with: {\n    operator: \"not like\",\n    patternPrefix: \"%\",\n    patternSuffix: undefined,\n  },\n} as const;\n\nexport type FilterType =\n  | \"\"\n  | \"not\"\n  | \"in\"\n  | \"not_in\"\n  | \"contains\"\n  | \"not_contains\"\n  | \"gt\"\n  | \"lt\"\n  | \"gte\"\n  | \"lte\"\n  | \"starts_with\"\n  | \"not_starts_with\"\n  | \"ends_with\"\n  | \"not_ends_with\";\n\nexport function getWhereOperatorAndValue({\n  filterType,\n  value,\n}: {\n  filterType: FilterType;\n  value: unknown;\n}) {\n  const { operator, patternPrefix, patternSuffix } = filterTypes[filterType];\n\n  if (value === null || value === undefined) {\n    return {\n      operator:\n        operator === \"=\"\n          ? (\"is\" as const)\n          : operator === \"!=\"\n          ? (\"is not\" as const)\n          : operator,\n      value: null,\n    };\n  }\n\n  if (Array.isArray(value)) {\n    // Handle basic list equals.\n    if (filterType === \"\" || filterType === \"not\") {\n      return { operator, value: JSON.stringify(value) };\n    }\n\n    // Handle list contains.\n    return {\n      operator,\n      value: value.map((v) => {\n        if (typeof v === \"boolean\") {\n          return v ? 1 : 0;\n        } else if (typeof v === \"bigint\") {\n          return intToBlob(v);\n        } else {\n          return v;\n        }\n      }),\n    };\n  }\n\n  if (typeof value === \"boolean\") {\n    return { operator, value: value ? 1 : 0 };\n  }\n\n  if (typeof value === \"bigint\") {\n    return { operator, value: intToBlob(value) };\n  }\n\n  // At this point, treat the value as a string.\n  let finalValue = value;\n  if (patternPrefix) finalValue = `${patternPrefix}${finalValue}`;\n  if (patternSuffix) finalValue = `${finalValue}${patternSuffix}`;\n\n  return { operator, value: finalValue };\n}\n\nexport function formatModelFieldValue({ value }: { value: unknown }) {\n  if (typeof value === \"boolean\") {\n    return value ? 1 : 0;\n  } else if (typeof value === \"bigint\") {\n    return intToBlob(value);\n  } else if (typeof value === \"undefined\") {\n    return null;\n  } else if (Array.isArray(value)) {\n    if (typeof value[0] === \"bigint\") {\n      return JSON.stringify(value.map(String));\n    } else {\n      return JSON.stringify(value);\n    }\n  } else {\n    return value as string | number | null;\n  }\n}\n\nexport function formatModelInstance({\n  id,\n  data,\n}: {\n  id: string | number | bigint;\n  data: Partial<Omit<ModelInstance, \"id\">>;\n}) {\n  const instance: { [key: string]: string | number | null | Buffer } = {};\n\n  instance[\"id\"] = formatModelFieldValue({ value: id });\n\n  Object.entries(data).forEach(([key, value]) => {\n    instance[key] = formatModelFieldValue({ value });\n  });\n\n  return instance;\n}\n\nexport function parseModelFilter(filter: ModelFilter = {}): ModelFilter {\n  const parsedFilter: ModelFilter = {};\n\n  if (filter.first) {\n    if (filter.first > MAX_LIMIT) {\n      throw new BaseError(\"Cannot query more than 1000 rows.\");\n    }\n    parsedFilter.first = filter.first;\n  } else {\n    parsedFilter.first = DEFAULT_LIMIT;\n  }\n\n  if (filter.skip) {\n    if (filter.skip > MAX_SKIP)\n      throw new BaseError(\"Cannot skip more than 5000 rows.\");\n    parsedFilter.skip = filter.skip;\n  }\n\n  parsedFilter.orderBy = filter.orderBy || \"id\";\n  parsedFilter.orderDirection = filter.orderDirection || \"asc\";\n  parsedFilter.where = filter.where;\n\n  return parsedFilter;\n}\n\nconst DEFAULT_LIMIT = 100;\nconst MAX_LIMIT = 1000;\nconst MAX_SKIP = 5000;\n","import type Sqlite from \"better-sqlite3\";\nimport { randomBytes } from \"crypto\";\nimport { Kysely, sql, SqliteDialect } from \"kysely\";\n\nimport type { Schema } from \"@/schema/types\";\nimport { blobToBigInt } from \"@/utils/decode\";\n\nimport type { ModelFilter, ModelInstance, UserStore } from \"../store\";\nimport {\n  type FilterType,\n  formatModelFieldValue,\n  formatModelInstance,\n  getWhereOperatorAndValue,\n  parseModelFilter,\n} from \"../utils\";\n\nconst gqlScalarToSqlType = {\n  Boolean: \"integer\",\n  Int: \"integer\",\n  String: \"text\",\n  BigInt: \"blob\",\n  Bytes: \"text\",\n  Float: \"text\",\n} as const;\n\nconst MAX_INTEGER = 2_147_483_647 as const;\n\nexport class SqliteUserStore implements UserStore {\n  db: Kysely<any>;\n\n  schema?: Schema;\n  versionId?: string;\n\n  constructor({ db }: { db: Sqlite.Database }) {\n    this.db = new Kysely({\n      dialect: new SqliteDialect({ database: db }),\n    });\n  }\n\n  /**\n   * Resets the database by dropping existing tables and creating new tables.\n   * If no new schema is provided, the existing schema is used.\n   *\n   * @param options.schema New schema to be used.\n   */\n  reload = async ({ schema }: { schema?: Schema } = {}) => {\n    // If there is no existing schema and no schema was provided, do nothing.\n    if (!this.schema && !schema) return;\n\n    await this.db.transaction().execute(async (tx) => {\n      // Drop tables from existing schema.\n      if (this.schema) {\n        await Promise.all(\n          this.schema.entities.map((model) => {\n            const tableName = `${model.name}_${this.versionId}`;\n            tx.schema.dropTable(tableName);\n          })\n        );\n      }\n\n      if (schema) this.schema = schema;\n\n      this.versionId = randomBytes(4).toString(\"hex\");\n\n      // Create tables for new schema.\n      await Promise.all(\n        this.schema!.entities.map(async (model) => {\n          const tableName = `${model.name}_${this.versionId}`;\n          let tableBuilder = tx.schema.createTable(tableName);\n          model.fields.forEach((field) => {\n            switch (field.kind) {\n              case \"SCALAR\": {\n                tableBuilder = tableBuilder.addColumn(\n                  field.name,\n                  gqlScalarToSqlType[field.scalarTypeName],\n                  (col) => {\n                    if (field.notNull) col = col.notNull();\n                    return col;\n                  }\n                );\n                break;\n              }\n              case \"ENUM\": {\n                tableBuilder = tableBuilder.addColumn(\n                  field.name,\n                  \"text\",\n                  (col) => {\n                    if (field.notNull) col = col.notNull();\n                    col = col.check(\n                      sql`${sql.ref(field.name)} in (${sql.join(\n                        field.enumValues.map((v) => sql.lit(v))\n                      )})`\n                    );\n                    return col;\n                  }\n                );\n                break;\n              }\n              case \"LIST\": {\n                tableBuilder = tableBuilder.addColumn(\n                  field.name,\n                  \"text\",\n                  (col) => {\n                    if (field.notNull) col = col.notNull();\n                    return col;\n                  }\n                );\n                break;\n              }\n              case \"RELATIONSHIP\": {\n                tableBuilder = tableBuilder.addColumn(\n                  field.name,\n                  gqlScalarToSqlType[field.relatedEntityIdType.name],\n                  (col) => {\n                    if (field.notNull) col = col.notNull();\n                    return col;\n                  }\n                );\n                break;\n              }\n            }\n          });\n\n          // Add the effective timestamp columns.\n          tableBuilder = tableBuilder.addColumn(\n            \"effectiveFrom\",\n            \"integer\",\n            (col) => col.notNull()\n          );\n          tableBuilder = tableBuilder.addColumn(\n            \"effectiveTo\",\n            \"integer\",\n            (col) => col.notNull()\n          );\n          tableBuilder = tableBuilder.addPrimaryKeyConstraint(\n            `${tableName}_id_effectiveTo_unique`,\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            [\"id\", \"effectiveTo\"]\n          );\n\n          await tableBuilder.execute();\n        })\n      );\n    });\n  };\n\n  /**\n   * Tears down the store by dropping all tables for the current schema.\n   */\n  teardown = async () => {\n    if (!this.schema) return;\n\n    // Drop tables from existing schema.\n    await this.db.transaction().execute(async (tx) => {\n      await Promise.all(\n        this.schema!.entities.map((model) => {\n          const tableName = `${model.name}_${this.versionId}`;\n          tx.schema.dropTable(tableName);\n        })\n      );\n    });\n  };\n\n  findUnique = async ({\n    modelName,\n    timestamp = MAX_INTEGER,\n    id,\n  }: {\n    modelName: string;\n    timestamp?: number;\n    id: string | number | bigint;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const formattedId = formatModelFieldValue({ value: id });\n\n    const instances = await this.db\n      .selectFrom(tableName)\n      .selectAll()\n      .where(\"id\", \"=\", formattedId)\n      .where(\"effectiveFrom\", \"<=\", timestamp)\n      .where(\"effectiveTo\", \">=\", timestamp)\n      .execute();\n\n    if (instances.length > 1) {\n      throw new Error(`Expected 1 instance, found ${instances.length}`);\n    }\n\n    return instances[0]\n      ? this.deserializeInstance({ modelName, instance: instances[0] })\n      : null;\n  };\n\n  create = async ({\n    modelName,\n    timestamp,\n    id,\n    data = {},\n  }: {\n    modelName: string;\n    timestamp: number;\n    id: string | number | bigint;\n    data?: Omit<ModelInstance, \"id\">;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const createInstance = formatModelInstance({ id, data });\n\n    const instance = await this.db\n      .insertInto(tableName)\n      .values({\n        ...createInstance,\n        effectiveFrom: timestamp,\n        effectiveTo: MAX_INTEGER,\n      })\n      .returningAll()\n      .executeTakeFirstOrThrow();\n\n    return this.deserializeInstance({ modelName, instance });\n  };\n\n  update = async ({\n    modelName,\n    timestamp,\n    id,\n    data = {},\n  }: {\n    modelName: string;\n    timestamp: number;\n    id: string | number | bigint;\n    data?: Partial<Omit<ModelInstance, \"id\">>;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const formattedId = formatModelFieldValue({ value: id });\n    const updateInstance = formatModelInstance({ id, data });\n\n    const instance = await this.db.transaction().execute(async (tx) => {\n      // Find the latest version of this instance.\n      const latestInstance = await tx\n        .selectFrom(tableName)\n        .selectAll()\n        .where(\"id\", \"=\", formattedId)\n        .orderBy(\"effectiveTo\", \"desc\")\n        .executeTakeFirstOrThrow();\n\n      // If the latest version has the same effectiveFrom timestamp as the update,\n      // this update is occurring within the same block/second. Update in place.\n      if (latestInstance.effectiveFrom === timestamp) {\n        return await tx\n          .updateTable(tableName)\n          .set(updateInstance)\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveFrom\", \"=\", timestamp)\n          .returningAll()\n          .executeTakeFirstOrThrow();\n      }\n\n      if (latestInstance.effectiveFrom > timestamp) {\n        throw new Error(`Cannot update an instance in the past`);\n      }\n\n      // If the latest version has an earlier effectiveFrom timestamp than the update,\n      // we need to update the latest version AND insert a new version.\n      await tx\n        .updateTable(tableName)\n        .set({ effectiveTo: timestamp - 1 })\n        .where(\"id\", \"=\", formattedId)\n        .where(\"effectiveTo\", \"=\", MAX_INTEGER)\n        .execute();\n\n      return await tx\n        .insertInto(tableName)\n        .values({\n          ...latestInstance,\n          ...updateInstance,\n          effectiveFrom: timestamp,\n          effectiveTo: MAX_INTEGER,\n        })\n        .returningAll()\n        .executeTakeFirstOrThrow();\n    });\n\n    return this.deserializeInstance({ modelName, instance });\n  };\n\n  upsert = async ({\n    modelName,\n    timestamp,\n    id,\n    create = {},\n    update = {},\n  }: {\n    modelName: string;\n    timestamp: number;\n    id: string | number | bigint;\n    create?: Omit<ModelInstance, \"id\">;\n    update?: Partial<Omit<ModelInstance, \"id\">>;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const formattedId = formatModelFieldValue({ value: id });\n    const createInstance = formatModelInstance({ id, data: create });\n    const updateInstance = formatModelInstance({ id, data: update });\n\n    const instance = await this.db.transaction().execute(async (tx) => {\n      // Attempt to find the latest version of this instance.\n      const latestInstance = await tx\n        .selectFrom(tableName)\n        .selectAll()\n        .where(\"id\", \"=\", formattedId)\n        .orderBy(\"effectiveTo\", \"desc\")\n        .executeTakeFirst();\n\n      // If there is no latest version, insert a new version using the create data.\n      if (!latestInstance) {\n        return await tx\n          .insertInto(tableName)\n          .values({\n            ...createInstance,\n            effectiveFrom: timestamp,\n            effectiveTo: MAX_INTEGER,\n          })\n          .returningAll()\n          .executeTakeFirstOrThrow();\n      }\n\n      // If the latest version has the same effectiveFrom timestamp as the update,\n      // this update is occurring within the same block/second. Update in place.\n      if (latestInstance.effectiveFrom === timestamp) {\n        return await tx\n          .updateTable(tableName)\n          .set(updateInstance)\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveFrom\", \"=\", timestamp)\n          .returningAll()\n          .executeTakeFirstOrThrow();\n      }\n\n      if (latestInstance.effectiveFrom > timestamp) {\n        throw new Error(`Cannot update an instance in the past`);\n      }\n\n      // If the latest version has an earlier effectiveFrom timestamp than the update,\n      // we need to update the latest version AND insert a new version.\n      await tx\n        .updateTable(tableName)\n        .set({ effectiveTo: timestamp - 1 })\n        .where(\"id\", \"=\", formattedId)\n        .where(\"effectiveTo\", \"=\", MAX_INTEGER)\n        .execute();\n\n      return await tx\n        .insertInto(tableName)\n        .values({\n          ...latestInstance,\n          ...updateInstance,\n          effectiveFrom: timestamp,\n          effectiveTo: MAX_INTEGER,\n        })\n        .returningAll()\n        .executeTakeFirstOrThrow();\n    });\n\n    return this.deserializeInstance({ modelName, instance });\n  };\n\n  delete = async ({\n    modelName,\n    timestamp,\n    id,\n  }: {\n    modelName: string;\n    timestamp: number;\n    id: string | number | bigint;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n    const formattedId = formatModelFieldValue({ value: id });\n\n    const instance = await this.db.transaction().execute(async (tx) => {\n      // Update the latest version to be effective until the delete timestamp.\n      const deletedInstance = await tx\n        .updateTable(tableName)\n        .set({ effectiveTo: timestamp - 1 })\n        .where(\"id\", \"=\", formattedId)\n        .where(\"effectiveTo\", \"=\", MAX_INTEGER)\n        .returning([\"id\", \"effectiveFrom\"])\n        .executeTakeFirst();\n\n      // If, after the update, the latest version is only effective from\n      // the delete timestamp, delete the instance in place. It \"never existed\".\n      if (deletedInstance?.effectiveFrom === timestamp) {\n        await tx\n          .deleteFrom(tableName)\n          .where(\"id\", \"=\", formattedId)\n          .where(\"effectiveFrom\", \"=\", timestamp)\n          .returning([\"id\"])\n          .executeTakeFirst();\n      }\n\n      return !!deletedInstance;\n    });\n\n    return instance;\n  };\n\n  findMany = async ({\n    modelName,\n    timestamp = MAX_INTEGER,\n    filter = {},\n  }: {\n    modelName: string;\n    timestamp: number;\n    filter?: ModelFilter;\n  }) => {\n    const tableName = `${modelName}_${this.versionId}`;\n\n    let query = this.db\n      .selectFrom(tableName)\n      .selectAll()\n      .where(\"effectiveFrom\", \"<=\", timestamp)\n      .where(\"effectiveTo\", \">=\", timestamp);\n\n    const { where, first, skip, orderBy, orderDirection } =\n      parseModelFilter(filter);\n\n    if (where) {\n      Object.entries(where).forEach(([whereKey, rawValue]) => {\n        const [fieldName, rawFilterType] = whereKey.split(/_(.*)/s);\n        // This is a hack to handle the \"\" operator, which the regex above doesn't handle\n        const filterType = (\n          rawFilterType === undefined ? \"\" : rawFilterType\n        ) as FilterType;\n\n        const { operator, value } = getWhereOperatorAndValue({\n          filterType,\n          value: rawValue,\n        });\n\n        query = query.where(fieldName, operator, value);\n      });\n    }\n\n    if (skip) {\n      query = query.offset(skip);\n    }\n    if (first) {\n      query = query.limit(first);\n    }\n    if (orderBy) {\n      query = query.orderBy(orderBy, orderDirection);\n    }\n\n    const instances = await query.execute();\n\n    return instances.map((instance) =>\n      this.deserializeInstance({ modelName, instance })\n    );\n  };\n\n  revert = async ({ safeTimestamp }: { safeTimestamp: number }) => {\n    await this.db.transaction().execute(async (tx) => {\n      await Promise.all(\n        (this.schema?.entities ?? []).map(async (entity) => {\n          const modelName = entity.name;\n          const tableName = `${modelName}_${this.versionId}`;\n\n          // Delete any versions that are newer than the safe timestamp.\n          await tx\n            .deleteFrom(tableName)\n            .where(\"effectiveFrom\", \">\", safeTimestamp)\n            .execute();\n\n          // Now, any versions that have effectiveTo greater than or equal\n          // to the safe timestamp are the new latest version.\n          await tx\n            .updateTable(tableName)\n            .where(\"effectiveTo\", \">=\", safeTimestamp)\n            .set({ effectiveTo: MAX_INTEGER })\n            .execute();\n        })\n      );\n    });\n  };\n\n  private deserializeInstance = ({\n    modelName,\n    instance,\n  }: {\n    modelName: string;\n    instance: Record<string, unknown>;\n  }) => {\n    const entity = this.schema!.entities.find((e) => e.name === modelName)!;\n\n    const deserializedInstance = {} as ModelInstance;\n\n    entity.fields.forEach((field) => {\n      const value = instance[field.name] as string | number | null | undefined;\n\n      if (value === null || value === undefined) {\n        deserializedInstance[field.name] = null;\n        return;\n      }\n\n      if (field.kind === \"SCALAR\" && field.scalarTypeName === \"Boolean\") {\n        deserializedInstance[field.name] = value === 1 ? true : false;\n        return;\n      }\n\n      if (field.kind === \"SCALAR\" && field.scalarTypeName === \"BigInt\") {\n        deserializedInstance[field.name] = blobToBigInt(\n          value as unknown as Buffer\n        );\n        return;\n      }\n\n      if (\n        field.kind === \"RELATIONSHIP\" &&\n        field.relatedEntityIdType.name === \"BigInt\"\n      ) {\n        deserializedInstance[field.name] = blobToBigInt(\n          value as unknown as Buffer\n        );\n        return;\n      }\n\n      if (field.kind === \"LIST\") {\n        let parsedValue = JSON.parse(value as string);\n        if (field.baseGqlType.name === \"BigInt\")\n          parsedValue = parsedValue.map(BigInt);\n        deserializedInstance[field.name] = parsedValue;\n        return;\n      }\n\n      deserializedInstance[field.name] = value;\n    });\n\n    return deserializedInstance;\n  };\n}\n"],"mappings":"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","names":["path","glob","import_node_path","import_node_fs","import_node_path","fieldTypeName","import_graphql","import_graphql","import_graphql","import_graphql","import_graphql","import_node_fs","Emittery","chokidar","path","import_emittery","import_graphql","import_node_fs","import_node_path","import_node_fs","import_node_path","path","import_graphql","prettier","Emittery","path","import_node_fs","import_node_path","path","import_node_path","pg","path","Sqlite","import_viem","import_emittery","Emittery","import_emittery","import_viem","Emittery","import_kysely","EVM_MAX_UINT","import_viem","range","import_kysely","import_viem","migrations","StaticMigrationProvider","migrationProvider","migrationProvider","range","buildLogFilterValues","getLogFilterAddressOrTopic","getLogFilterTopics","import_emittery","import_viem","PQueue","retry","Emittery","range","startBlock","endBlock","queue","import_node_path","path","pino","pc","prometheus","import_emittery","import_viem","poll","import_viem","Emittery","block","pLimit","express","cors","path","server","import_ink","import_react","import_ink","import_react","React","React","import_ink","import_react","React","React","inkRender","ui","import_emittery","import_viem","import_viem","rawResult","import_node_fs","import_node_path","path","parseStackTrace","dataUriToBuffer","Emittery","queue","import_kysely","query","import_crypto","import_kysely","gqlScalarToSqlType","MAX_INTEGER","query","path"]}